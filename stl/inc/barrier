// barrier standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _BARRIER_
#define _BARRIER_
#include <yvals.h>
#if _STL_COMPILER_PREPROCESSOR

#ifdef _M_CEE_PURE
#error <barrier> is not supported when compiling with /clr:pure.
#endif // _M_CEE_PURE

#if !_HAS_CXX20
#pragma message("The contents of <barrier> are available only with C++20 or later.")
#else // ^^^ !_HAS_CXX20 / _HAS_CXX20 vvv

#include <atomic>
#include <limits.h>
#include <type_traits>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("max")
#undef max

_STD_BEGIN

struct _No_completion_function {
    void operator()() noexcept {}
};

template <class _Completion_function = _No_completion_function>
class barrier;

inline constexpr ptrdiff_t _Barrier_arrival_token_mask = 1;
inline constexpr ptrdiff_t _Barrier_value_mask         = ~_Barrier_arrival_token_mask;
inline constexpr ptrdiff_t _Barrier_value_shift        = 1;
inline constexpr ptrdiff_t _Barrier_invalid_token      = 0;
inline constexpr ptrdiff_t _Barrier_value_step         = 1 << _Barrier_value_shift;
inline constexpr ptrdiff_t _Barrier_max                = (1ULL << (sizeof(ptrdiff_t) * CHAR_BIT - 2)) - 1;

template <class _Completion_function>
class _Arrival_token {
public:
    _Arrival_token(_Arrival_token&& _Other) noexcept {
        _Value        = _Other._Value;
        _Other._Value = _Barrier_invalid_token;
    }

    _Arrival_token& operator=(_Arrival_token&& _Other) noexcept {
        _Value        = _Other._Value;
        _Other._Value = _Barrier_invalid_token;
    }

    ptrdiff_t _Value;

private:
    explicit _Arrival_token(ptrdiff_t _Value) noexcept : _Value(_Value) {}
    friend class barrier<_Completion_function>;
};

// TRANSITION, ABI: simplify this when [[no_unique_address]] is working
template <class _Completion_function>
inline constexpr bool _Is_barrier_empty_base = is_class_v<_Completion_function> && !is_final_v<_Completion_function>;

template <class _Completion_function, bool _Is_base = _Is_barrier_empty_base<_Completion_function>>
class _Barrier_completion;

template <class _Completion_function>
class _Barrier_completion<_Completion_function, false> {
public:
    _Barrier_completion(_Completion_function _Fn) : _Fn(_STD move(_Fn)) {}

    void _Call_completion() noexcept {
        _Fn();
    }

    _Completion_function _Fn;
};

template <class _Completion_function>
class _Barrier_completion<_Completion_function, true> : private _Completion_function {
public:
    _Barrier_completion(_Completion_function _Fn) : _Completion_function(_STD move(_Fn)) {}

    void _Call_completion() noexcept {
        auto& _Fn = static_cast<_Completion_function&>(*this);
        _Fn();
    }
};

template <class _Completion_function>
class barrier : private _Barrier_completion<_Completion_function> {
public:
    static_assert(is_nothrow_invocable_v<_Completion_function>, "Barrier completion function shall not throw");

    using arrival_token = _Arrival_token<_Completion_function>;

    constexpr explicit barrier(
        const ptrdiff_t _Phase_count, _Completion_function _Fn = _Completion_function()) noexcept /* strengthened */
        : _Barrier_completion<_Completion_function>(_STD move(_Fn)),
          _Current_phase(_Phase_count << _Barrier_value_shift), _Phase_count(_Phase_count << _Barrier_value_shift) {
        _STL_VERIFY(_Phase_count >= 0 && _Phase_count <= _Barrier_max,
            "Phase count shall be non-negative and shall not exceed max()");
    }

    ~barrier() = default;

    barrier(const barrier&) = delete;
    barrier& operator=(const barrier&) = delete;

    [[nodiscard]] static constexpr ptrdiff_t max() noexcept {
        return _Barrier_max;
    }

    [[nodiscard]] arrival_token arrive(ptrdiff_t _Update = 1) noexcept /* strengthened */ {
        _Update <<= _Barrier_value_shift;
        _STL_VERIFY(_Update >= 0, "update count shall be non-negative");
        // TRANSITION, GH-1133: should be memory_order_release
        ptrdiff_t _Current = _Current_phase.fetch_sub(_Update, memory_order_seq_cst) - _Update;
        _STL_VERIFY(_Current >= 0, "phase count shall be non-negative");
        if ((_Current & _Barrier_value_mask) == 0) {
            // TRANSITION, GH-1133: should have this fence:
            // atomic_thread_fence(memory_order_acquire);
            _Completion(_Current);
        }
        return _Arrival_token<_Completion_function>(
            (_Current & _Barrier_arrival_token_mask) | reinterpret_cast<intptr_t>(this));
    }

    void wait(arrival_token&& _Arrival) const noexcept /* strengthened */ {
        _STL_VERIFY((_Arrival._Value & _Barrier_value_mask) == reinterpret_cast<intptr_t>(this),
            "arrival token should be the same token from previous phase");

        for (;;) {
            // TRANSITION, GH-1133: should be memory_order_acquire
            const ptrdiff_t _Current = _Current_phase.load(memory_order_seq_cst);
            _STL_VERIFY(_Current >= 0, "phase count shall be non-negative");
            if ((_Current & _Barrier_arrival_token_mask) != (_Arrival._Value & _Barrier_arrival_token_mask)) {
                break;
            }
            _Current_phase.wait(_Current, memory_order_relaxed);
        }
    }

    void arrive_and_wait() noexcept /* strengthened */ {
        // TRANSITION, GH-1133: should be memory_order_acq_rel
        ptrdiff_t _Current = _Current_phase.fetch_sub(_Barrier_value_step, memory_order_seq_cst) - _Barrier_value_step;
        const ptrdiff_t _Arrival = _Current & _Barrier_arrival_token_mask;
        _STL_VERIFY(_Current >= 0, "phase count shall be non-negative");
        if ((_Current & _Barrier_value_mask) == 0) {
            _Completion(_Current);
            return;
        }

        for (;;) {
            _Current_phase.wait(_Current, memory_order_relaxed);
            // TRANSITION, GH-1133: should be memory_order_acquire
            _Current = _Current_phase.load(memory_order_seq_cst);
            _STL_VERIFY(_Current >= 0, "phase count shall be non-negative");
            if ((_Current & _Barrier_arrival_token_mask) != _Arrival) {
                break;
            }
        }
    }

    void arrive_and_drop() noexcept /* strengthened */ {
        ptrdiff_t _Rem_count = _Phase_count.fetch_sub(_Barrier_value_step, memory_order_relaxed) - _Barrier_value_step;
        _STL_VERIFY(_Rem_count >= 0, "remaining phase count shall be non-negative");

        (void) arrive(1);
    }

private:
    void _Completion(const ptrdiff_t _Current) noexcept {
        ptrdiff_t _Rem_count = _Phase_count.load(memory_order_relaxed);
        _STL_VERIFY(_Rem_count >= 0, "remaining phase count shall be non-negative");

        this->_Call_completion();
        const ptrdiff_t _New_phase_count = _Rem_count | ((_Current + 1) & _Barrier_arrival_token_mask);
        // TRANSITION, GH-1133: should be memory_order_release
        _Current_phase.store(_New_phase_count, memory_order_seq_cst);
        _Current_phase.notify_all();
    }

    atomic<ptrdiff_t> _Current_phase;
    atomic<ptrdiff_t> _Phase_count;
};

_STD_END

#pragma pop_macro("max")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // ^^^ _HAS_CXX20 ^^^

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _BARRIER_
