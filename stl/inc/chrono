// chrono standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _CHRONO_
#define _CHRONO_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR
#include <ctime>
#include <limits>
#include <ratio>
#include <sstream>
#include <utility>
#include <xtimec.h>

#if _HAS_CXX20
#include <compare>
#ifdef __cpp_lib_concepts
#include <concepts>
#endif // defined(__cpp_lib_concepts)
#endif // _HAS_CXX20

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
namespace chrono {
    // STRUCT TEMPLATE treat_as_floating_point
    template <class _Rep>
    struct treat_as_floating_point : is_floating_point<_Rep> {}; // tests for floating-point type

    template <class _Rep>
    _INLINE_VAR constexpr bool treat_as_floating_point_v = treat_as_floating_point<_Rep>::value;

    // STRUCT TEMPLATE duration_values
    template <class _Rep>
    struct duration_values { // gets arithmetic properties of a type
        _NODISCARD static constexpr _Rep zero() noexcept {
            // get zero value
            return _Rep(0);
        }

        _NODISCARD static constexpr _Rep(min)() noexcept {
            // get smallest value
            return numeric_limits<_Rep>::lowest();
        }

        _NODISCARD static constexpr _Rep(max)() noexcept {
            // get largest value
            return (numeric_limits<_Rep>::max)();
        }
    };

#if _HAS_CXX20
    template <class _Clock, class = void>
    inline constexpr bool _Is_clock_v = false;

    template <class _Clock>
    inline constexpr bool
        _Is_clock_v<_Clock, void_t<typename _Clock::rep, typename _Clock::period, typename _Clock::duration,
                                typename _Clock::time_point, decltype(_Clock::is_steady), decltype(_Clock::now())>> =
            true; // TRANSITION, GH-602

    template <class _Clock>
    struct is_clock : bool_constant<_Is_clock_v<_Clock>> {};
    template <class _Clock>
    inline constexpr bool is_clock_v = _Is_clock_v<_Clock>;
#endif // _HAS_CXX20

    // CLASS TEMPLATE duration
    template <class _Rep, class _Period = ratio<1>>
    class duration;

    // VARIABLE TEMPLATE _Is_duration_v
    template <class _Ty>
    _INLINE_VAR constexpr bool _Is_duration_v = _Is_specialization_v<_Ty, duration>;

    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> = 0>
    constexpr _To duration_cast(const duration<_Rep, _Period>&) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>); // strengthened

    template <class _Rep, class _Period>
    class duration { // represents a time duration
    public:
        using rep    = _Rep;
        using period = typename _Period::type;

        static_assert(!_Is_duration_v<_Rep>, "duration can't have duration as first template argument");
        static_assert(_Is_ratio_v<_Period>, "period not an instance of std::ratio");
        static_assert(0 < _Period::num, "period negative or zero");

        constexpr duration() = default;

        template <class _Rep2,
            enable_if_t<is_convertible_v<const _Rep2&,
                            _Rep> && (treat_as_floating_point_v<_Rep> || !treat_as_floating_point_v<_Rep2>),
                int> = 0>
        constexpr explicit duration(const _Rep2& _Val) noexcept(
            is_arithmetic_v<_Rep>&& is_arithmetic_v<_Rep2>) // strengthened
            : _MyRep(static_cast<_Rep>(_Val)) {}

        template <class _Rep2, class _Period2,
            enable_if_t<
                treat_as_floating_point_v<
                    _Rep> || (_Ratio_divide_sfinae<_Period2, _Period>::den == 1 && !treat_as_floating_point_v<_Rep2>),
                int> = 0>
        constexpr duration(const duration<_Rep2, _Period2>& _Dur) noexcept(
            is_arithmetic_v<_Rep>&& is_arithmetic_v<_Rep2>) // strengthened
            : _MyRep(_CHRONO duration_cast<duration>(_Dur).count()) {}

        _NODISCARD constexpr _Rep count() const noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            return _MyRep;
        }

        _NODISCARD constexpr common_type_t<duration> operator+() const
            noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            return common_type_t<duration>(*this);
        }

        _NODISCARD constexpr common_type_t<duration> operator-() const
            noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            return common_type_t<duration>(-_MyRep);
        }

        _CONSTEXPR17 duration& operator++() noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            ++_MyRep;
            return *this;
        }

        _CONSTEXPR17 duration operator++(int) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            return duration(_MyRep++);
        }

        _CONSTEXPR17 duration& operator--() noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            --_MyRep;
            return *this;
        }

        _CONSTEXPR17 duration operator--(int) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            return duration(_MyRep--);
        }

        _CONSTEXPR17 duration& operator+=(const duration& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            _MyRep += _Right._MyRep;
            return *this;
        }

        _CONSTEXPR17 duration& operator-=(const duration& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            _MyRep -= _Right._MyRep;
            return *this;
        }

        _CONSTEXPR17 duration& operator*=(const _Rep& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            _MyRep *= _Right;
            return *this;
        }

        _CONSTEXPR17 duration& operator/=(const _Rep& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            _MyRep /= _Right;
            return *this;
        }

        _CONSTEXPR17 duration& operator%=(const _Rep& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            _MyRep %= _Right;
            return *this;
        }

        _CONSTEXPR17 duration& operator%=(const duration& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            _MyRep %= _Right.count();
            return *this;
        }

        _NODISCARD static constexpr duration zero() noexcept {
            // get zero value
            return duration(duration_values<_Rep>::zero());
        }

        _NODISCARD static constexpr duration(min)() noexcept {
            // get minimum value
            return duration((duration_values<_Rep>::min)());
        }

        _NODISCARD static constexpr duration(max)() noexcept {
            // get maximum value
            return duration((duration_values<_Rep>::max)());
        }

    private:
        _Rep _MyRep; // the stored rep
    };

    template <class _Clock, class _Duration = typename _Clock::duration>
    class time_point { // represents a point in time
    public:
        using clock    = _Clock;
        using duration = _Duration;
        using rep      = typename _Duration::rep;
        using period   = typename _Duration::period;

        static_assert(_Is_duration_v<_Duration>, "duration must be an instance of std::duration");

        constexpr time_point() = default;

        constexpr explicit time_point(const _Duration& _Other) noexcept(is_arithmetic_v<rep>) // strengthened
            : _MyDur(_Other) {}

        template <class _Duration2, enable_if_t<is_convertible_v<_Duration2, _Duration>, int> = 0>
        constexpr time_point(const time_point<_Clock, _Duration2>& _Tp) noexcept(
            is_arithmetic_v<rep>&& is_arithmetic_v<typename _Duration2::rep>) // strengthened
            : _MyDur(_Tp.time_since_epoch()) {}

        _NODISCARD constexpr _Duration time_since_epoch() const noexcept(is_arithmetic_v<rep>) /* strengthened */ {
            return _MyDur;
        }

#if _HAS_CXX20
        constexpr time_point& operator++() noexcept(is_arithmetic_v<rep>) /* strengthened */ {
            ++_MyDur;
            return *this;
        }
        constexpr time_point operator++(int) noexcept(is_arithmetic_v<rep>) /* strengthened */ {
            return time_point{_MyDur++};
        }
        constexpr time_point& operator--() noexcept(is_arithmetic_v<rep>) /* strengthened */ {
            --_MyDur;
            return *this;
        }
        constexpr time_point operator--(int) noexcept(is_arithmetic_v<rep>) /* strengthened */ {
            return time_point{_MyDur--};
        }
#endif // _HAS_CXX20

        _CONSTEXPR17 time_point& operator+=(const _Duration& _Dur) noexcept(is_arithmetic_v<rep>) /* strengthened */ {
            _MyDur += _Dur;
            return *this;
        }

        _CONSTEXPR17 time_point& operator-=(const _Duration& _Dur) noexcept(is_arithmetic_v<rep>) /* strengthened */ {
            _MyDur -= _Dur;
            return *this;
        }

        _NODISCARD static constexpr time_point(min)() noexcept {
            return time_point((_Duration::min)());
        }

        _NODISCARD static constexpr time_point(max)() noexcept {
            return time_point((_Duration::max)());
        }

    private:
        _Duration _MyDur{duration::zero()}; // duration since the epoch
    };
} // namespace chrono

// STRUCT TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
template <intmax_t _Ax, intmax_t _Bx>
struct _Lcm : integral_constant<intmax_t, (_Ax / _Gcd<_Ax, _Bx>::value) * _Bx> {}; // compute LCM of _Ax and _Bx

// STRUCT TEMPLATE common_type SPECIALIZATIONS
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct common_type<_CHRONO duration<_Rep1, _Period1>,
    _CHRONO duration<_Rep2, _Period2>> { // common type of two durations
    using type = _CHRONO duration<common_type_t<_Rep1, _Rep2>,
        ratio<_Gcd<_Period1::num, _Period2::num>::value, _Lcm<_Period1::den, _Period2::den>::value>>;
};

template <class _Clock, class _Duration1, class _Duration2>
struct common_type<_CHRONO time_point<_Clock, _Duration1>,
    _CHRONO time_point<_Clock, _Duration2>> { // common type of two time points
    using type = _CHRONO time_point<_Clock, common_type_t<_Duration1, _Duration2>>;
};

namespace chrono {
    // duration ARITHMETIC
    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>
        operator+(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_CD(_Left).count() + _CD(_Right).count());
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>
        operator-(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_CD(_Left).count() - _CD(_Right).count());
    }

    template <class _Rep1, class _Period1, class _Rep2,
        enable_if_t<is_convertible_v<const _Rep2&, common_type_t<_Rep1, _Rep2>>, int> = 0>
    _NODISCARD constexpr duration<common_type_t<_Rep1, _Rep2>, _Period1> operator*(
        const duration<_Rep1, _Period1>& _Left,
        const _Rep2& _Right) noexcept(is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CR = common_type_t<_Rep1, _Rep2>;
        using _CD = duration<_CR, _Period1>;
        return _CD(_CD(_Left).count() * _Right);
    }

    template <class _Rep1, class _Rep2, class _Period2,
        enable_if_t<is_convertible_v<const _Rep1&, common_type_t<_Rep1, _Rep2>>, int> = 0>
    _NODISCARD constexpr duration<common_type_t<_Rep1, _Rep2>, _Period2>
        operator*(const _Rep1& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        return _Right * _Left;
    }

    template <class _CR, class _Period1, class _Rep2, bool = is_convertible_v<const _Rep2&, _CR>>
    struct _Duration_div_mod1 { // return type for duration / rep and duration % rep
        using type = duration<_CR, _Period1>;
    };

    template <class _CR, class _Period1, class _Rep2>
    struct _Duration_div_mod1<_CR, _Period1, _Rep2, false> {}; // no return type

    template <class _CR, class _Period1, class _Rep2, bool = _Is_duration_v<_Rep2>>
    struct _Duration_div_mod {}; // no return type

    template <class _CR, class _Period1, class _Rep2>
    struct _Duration_div_mod<_CR, _Period1, _Rep2, false> : _Duration_div_mod1<_CR, _Period1, _Rep2> {
        // return type for duration / rep and duration % rep
    };

    template <class _Rep1, class _Period1, class _Rep2>
    _NODISCARD constexpr typename _Duration_div_mod<common_type_t<_Rep1, _Rep2>, _Period1, _Rep2>::type operator/(
        const duration<_Rep1, _Period1>& _Left,
        const _Rep2& _Right) noexcept(is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CR = common_type_t<_Rep1, _Rep2>;
        using _CD = duration<_CR, _Period1>;
        return _CD(_CD(_Left).count() / _Right);
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr common_type_t<_Rep1, _Rep2>
        operator/(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_Left).count() / _CD(_Right).count();
    }

    template <class _Rep1, class _Period1, class _Rep2>
    _NODISCARD constexpr typename _Duration_div_mod<common_type_t<_Rep1, _Rep2>, _Period1, _Rep2>::type operator%(
        const duration<_Rep1, _Period1>& _Left,
        const _Rep2& _Right) noexcept(is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CR = common_type_t<_Rep1, _Rep2>;
        using _CD = duration<_CR, _Period1>;
        return _CD(_CD(_Left).count() % _Right);
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>
        operator%(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_CD(_Left).count() % _CD(_Right).count());
    }

    // duration COMPARISONS
    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr bool
        operator==(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CT(_Left).count() == _CT(_Right).count();
    }

#if !_HAS_CXX20
    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr bool
        operator!=(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        return !(_Left == _Right);
    }
#endif // !_HAS_CXX20

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr bool
        operator<(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CT(_Left).count() < _CT(_Right).count();
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr bool
        operator<=(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        return !(_Right < _Left);
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr bool
        operator>(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        return _Right < _Left;
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr bool
        operator>=(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        return !(_Left < _Right);
    }

#ifdef __cpp_lib_concepts
    // clang-format off
    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
        requires three_way_comparable<typename common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>::rep>
    _NODISCARD constexpr auto
        operator<=>(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        // clang-format on
        using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CT(_Left).count() <=> _CT(_Right).count();
    }
#endif // defined(__cpp_lib_concepts)

    // FUNCTION TEMPLATE duration_cast
    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> _Enabled>
    _NODISCARD constexpr _To duration_cast(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // convert duration to another duration; truncate
        using _CF = ratio_divide<_Period, typename _To::period>;

        using _ToRep = typename _To::rep;
        using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;

        constexpr bool _Num_is_one = _CF::num == 1;
        constexpr bool _Den_is_one = _CF::den == 1;

        if (_Den_is_one) {
            if (_Num_is_one) {
                return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));
            } else {
                return static_cast<_To>(
                    static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
            }
        } else {
            if (_Num_is_one) {
                return static_cast<_To>(
                    static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
            } else {
                return static_cast<_To>(static_cast<_ToRep>(
                    static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
            }
        }
    }

    // FUNCTION TEMPLATE floor
    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> = 0>
    _NODISCARD constexpr _To floor(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // convert duration to another duration; round towards negative infinity
        // i.e. the greatest integral result such that the result <= _Dur
        const _To _Casted{_CHRONO duration_cast<_To>(_Dur)};
        if (_Casted > _Dur) {
            return _To{_Casted.count() - static_cast<typename _To::rep>(1)};
        }

        return _Casted;
    }

    // FUNCTION TEMPLATE ceil
    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> = 0>
    _NODISCARD constexpr _To ceil(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // convert duration to another duration; round towards positive infinity
        // i.e. the least integral result such that _Dur <= the result
        const _To _Casted{_CHRONO duration_cast<_To>(_Dur)};
        if (_Casted < _Dur) {
            return _To{_Casted.count() + static_cast<typename _To::rep>(1)};
        }

        return _Casted;
    }

    // FUNCTION TEMPLATE round
    template <class _Rep>
    constexpr bool _Is_even(_Rep _Val) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
        // Tests whether _Val is even
        return _Val % 2 == 0;
    }

    template <class _To, class _Rep, class _Period,
        enable_if_t<_Is_duration_v<_To> && !treat_as_floating_point_v<typename _To::rep>, int> = 0>
    _NODISCARD constexpr _To round(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // convert duration to another duration, round to nearest, ties to even
        const _To _Floored{_CHRONO floor<_To>(_Dur)};
        const _To _Ceiled{_Floored + _To{1}};
        const auto _Floor_adjustment = _Dur - _Floored;
        const auto _Ceil_adjustment  = _Ceiled - _Dur;
        if (_Floor_adjustment < _Ceil_adjustment
            || (_Floor_adjustment == _Ceil_adjustment && _Is_even(_Floored.count()))) {
            return _Floored;
        }

        return _Ceiled;
    }

    // FUNCTION TEMPLATE abs
    template <class _Rep, class _Period, enable_if_t<numeric_limits<_Rep>::is_signed, int> = 0>
    _NODISCARD constexpr duration<_Rep, _Period> abs(const duration<_Rep, _Period> _Dur) noexcept(
        is_arithmetic_v<_Rep>) /* strengthened */ {
        // create a duration with count() the absolute value of _Dur.count()
        return _Dur < duration<_Rep, _Period>::zero() ? duration<_Rep, _Period>::zero() - _Dur : _Dur;
    }

    // duration TYPES
    using nanoseconds  = duration<long long, nano>;
    using microseconds = duration<long long, micro>;
    using milliseconds = duration<long long, milli>;
    using seconds      = duration<long long>;
    using minutes      = duration<int, ratio<60>>;
    using hours        = duration<int, ratio<3600>>;
#if _HAS_CXX20
    using days   = duration<int, ratio_multiply<ratio<24>, hours::period>>;
    using weeks  = duration<int, ratio_multiply<ratio<7>, days::period>>;
    using years  = duration<int, ratio_multiply<ratio<146097, 400>, days::period>>;
    using months = duration<int, ratio_divide<years::period, ratio<12>>>;
#endif // _HAS_CXX20

    // time_point ARITHMETIC
    template <class _Clock, class _Duration, class _Rep, class _Period>
    _NODISCARD constexpr time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>
        operator+(const time_point<_Clock, _Duration>& _Left, const duration<_Rep, _Period>& _Right) noexcept(
            is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<_Rep>) /* strengthened */ {
        using _RT = time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>;
        return _RT(_Left.time_since_epoch() + _Right);
    }

    template <class _Rep, class _Period, class _Clock, class _Duration>
    _NODISCARD constexpr time_point<_Clock, common_type_t<duration<_Rep, _Period>, _Duration>>
        operator+(const duration<_Rep, _Period>& _Left, const time_point<_Clock, _Duration>& _Right) noexcept(
            is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _Duration::rep>) /* strengthened */ {
        return _Right + _Left;
    }

    template <class _Clock, class _Duration, class _Rep, class _Period>
    _NODISCARD constexpr time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>
        operator-(const time_point<_Clock, _Duration>& _Left, const duration<_Rep, _Period>& _Right) noexcept(
            is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<_Rep>) /* strengthened */ {
        using _RT = time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>;
        return _RT(_Left.time_since_epoch() - _Right);
    }

    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr common_type_t<_Duration1, _Duration2>
        operator-(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return _Left.time_since_epoch() - _Right.time_since_epoch();
    }

    // time_point COMPARISONS
    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr bool
        operator==(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return _Left.time_since_epoch() == _Right.time_since_epoch();
    }

#if !_HAS_CXX20
    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr bool
        operator!=(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return !(_Left == _Right);
    }
#endif // !_HAS_CXX20

    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr bool
        operator<(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return _Left.time_since_epoch() < _Right.time_since_epoch();
    }

    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr bool
        operator<=(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return !(_Right < _Left);
    }

    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr bool
        operator>(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return _Right < _Left;
    }

    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr bool
        operator>=(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return !(_Left < _Right);
    }

#ifdef __cpp_lib_concepts
    template <class _Clock, class _Duration1, three_way_comparable_with<_Duration1> _Duration2>
    _NODISCARD constexpr auto
        operator<=>(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return _Left.time_since_epoch() <=> _Right.time_since_epoch();
    }
#endif // defined(__cpp_lib_concepts)

    // FUNCTION TEMPLATE time_point_cast
    template <class _To, class _Clock, class _Duration, enable_if_t<_Is_duration_v<_To>, int> = 0>
    _NODISCARD constexpr time_point<_Clock, _To> time_point_cast(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // change the duration type of a time_point; truncate
        return time_point<_Clock, _To>(_CHRONO duration_cast<_To>(_Time.time_since_epoch()));
    }

    // FUNCTION TEMPLATE floor (for time_point instances)
    template <class _To, class _Clock, class _Duration, enable_if_t<_Is_duration_v<_To>, int> = 0>
    _NODISCARD constexpr time_point<_Clock, _To> floor(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // change the duration type of a time_point; round towards negative infinity
        return time_point<_Clock, _To>(_CHRONO floor<_To>(_Time.time_since_epoch()));
    }

    // FUNCTION TEMPLATE ceil (for time_point instances)
    template <class _To, class _Clock, class _Duration, enable_if_t<_Is_duration_v<_To>, int> = 0>
    _NODISCARD constexpr time_point<_Clock, _To> ceil(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // change the duration type of a time_point; round towards positive infinity
        return time_point<_Clock, _To>(_CHRONO ceil<_To>(_Time.time_since_epoch()));
    }

    // FUNCTION TEMPLATE round (for time_point instances)
    template <class _To, class _Clock, class _Duration,
        enable_if_t<_Is_duration_v<_To> && !treat_as_floating_point_v<typename _To::rep>, int> = 0>
    _NODISCARD constexpr time_point<_Clock, _To> round(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // change the duration type of a time_point; round to nearest, ties to even
        return time_point<_Clock, _To>(_CHRONO round<_To>(_Time.time_since_epoch()));
    }

    // CLOCKS
    struct system_clock { // wraps GetSystemTimePreciseAsFileTime/GetSystemTimeAsFileTime
        using rep                       = long long;
        using period                    = ratio<1, 10'000'000>; // 100 nanoseconds
        using duration                  = _CHRONO duration<rep, period>;
        using time_point                = _CHRONO time_point<system_clock>;
        static constexpr bool is_steady = false;

        _NODISCARD static time_point now() noexcept { // get current time
            return time_point(duration(_Xtime_get_ticks()));
        }

        _NODISCARD static __time64_t to_time_t(const time_point& _Time) noexcept { // convert to __time64_t
            return duration_cast<seconds>(_Time.time_since_epoch()).count();
        }

        _NODISCARD static time_point from_time_t(__time64_t _Tm) noexcept { // convert from __time64_t
            return time_point{seconds{_Tm}};
        }
    };

#if _HAS_CXX20
    // sys_time ALIASES
    template <class _Duration>
    using sys_time    = time_point<system_clock, _Duration>;
    using sys_seconds = sys_time<seconds>;
    using sys_days    = sys_time<days>;
#endif // _HAS_CXX20

    struct steady_clock { // wraps QueryPerformanceCounter
        using rep                       = long long;
        using period                    = nano;
        using duration                  = nanoseconds;
        using time_point                = _CHRONO time_point<steady_clock>;
        static constexpr bool is_steady = true;

        _NODISCARD static time_point now() noexcept { // get current time
            const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot
            const long long _Ctr  = _Query_perf_counter();
            static_assert(period::num == 1, "This assumes period::num == 1.");
            // Instead of just having "(_Ctr * period::den) / _Freq",
            // the algorithm below prevents overflow when _Ctr is sufficiently large.
            // It assumes that _Freq * period::den does not overflow, which is currently true for nano period.
            // It is not realistic for _Ctr to accumulate to large values from zero with this assumption,
            // but the initial value of _Ctr could be large.
            const long long _Whole = (_Ctr / _Freq) * period::den;
            const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;
            return time_point(duration(_Whole + _Part));
        }
    };

    using high_resolution_clock = steady_clock;

#if _HAS_CXX20
    // [time.duration.io]

#define _IF_PERIOD_RETURN_SUFFIX_ELSE(_TYPE, _SUFFIX) \
    if constexpr (is_same_v<_Period, _TYPE>) {        \
        if constexpr (is_same_v<_CharT, char>) {      \
            return _SUFFIX;                           \
        } else {                                      \
            return L##_SUFFIX;                        \
        }                                             \
    } else

    template <class _CharT, class _Period>
    _NODISCARD constexpr const _CharT* _Get_literal_unit_suffix() {
        _IF_PERIOD_RETURN_SUFFIX_ELSE(atto, "as")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(femto, "fs")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(pico, "ps")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(nano, "ns")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(micro, "us")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(milli, "ms")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(centi, "cs")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(deci, "ds")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(seconds::period, "s")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(deca, "das")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(hecto, "hs")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(kilo, "ks")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(mega, "Ms")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(giga, "Gs")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(tera, "Ts")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(peta, "Ps")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(exa, "Es")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(minutes::period, "min")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(hours::period, "h")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(ratio<86400>, "d")

        {
            return nullptr;
        }
    }

#undef _IF_PERIOD_RETURN_SUFFIX_ELSE

    template <class _CharT>
    _NODISCARD _CharT* _Get_general_unit_suffix(_CharT* _Rnext, const intmax_t _Num, const intmax_t _Den) {
        // Returns the head pointer of the string, built in reverse.
        _STL_INTERNAL_CHECK(_Num > 0 && _Den > 0);
        *--_Rnext = '\0';
        *--_Rnext = 's';
        *--_Rnext = ']';
        if (_Den != 1) {
            _Rnext    = _UIntegral_to_buff(_Rnext, static_cast<uintmax_t>(_Den));
            *--_Rnext = '/';
        }

        _Rnext    = _UIntegral_to_buff(_Rnext, static_cast<uintmax_t>(_Num));
        *--_Rnext = '[';
        return _Rnext;
    }

    template <class _CharT, class _Traits, class _Rep, class _Period>
    basic_ostream<_CharT, _Traits>& operator<<(
        basic_ostream<_CharT, _Traits>& _Os, const duration<_Rep, _Period>& _Dur) {
        basic_ostringstream<_CharT, _Traits> _Sstr;
        _Sstr.flags(_Os.flags());
        _Sstr.imbue(_Os.getloc());
        _Sstr.precision(_Os.precision());
        _Sstr << _Dur.count();

        constexpr auto _Suffix = _Get_literal_unit_suffix<_CharT, _Period>();
        if constexpr (_Suffix == nullptr) {
            _CharT _Buffer[2 * (numeric_limits<intmax_t>::digits10 + 1) + 5] = {}; // 2 numbers + "[/]s\0"
            const _CharT* const _Begin =
                _Get_general_unit_suffix<_CharT>(_STD end(_Buffer), _Period::num, _Period::den);
            _Sstr << _Begin;
        } else {
            _Sstr << _Suffix;
        }

        return _Os << _Sstr.str();
    }

    struct local_t {};

    template <class _Duration>
    using local_time    = time_point<local_t, _Duration>;
    using local_seconds = local_time<seconds>;
    using local_days    = local_time<days>;

    struct last_spec {
        explicit last_spec() = default;
    };
    inline constexpr last_spec last{};

    class day {
    public:
        day() = default;
        constexpr explicit day(unsigned int _Val) noexcept : _Day{static_cast<unsigned char>(_Val)} {}

        constexpr day& operator++() noexcept {
            ++_Day;
            return *this;
        }
        constexpr day operator++(int) noexcept {
            return day{_Day++};
        }
        constexpr day& operator--() noexcept {
            --_Day;
            return *this;
        }
        constexpr day operator--(int) noexcept {
            return day{_Day--};
        }

        constexpr day& operator+=(const days& _Days) noexcept {
            _Day += static_cast<unsigned char>(_Days.count());
            return *this;
        }
        constexpr day& operator-=(const days& _Days) noexcept {
            _Day -= static_cast<unsigned char>(_Days.count());
            return *this;
        }

        _NODISCARD constexpr explicit operator unsigned int() const noexcept {
            return _Day;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Day >= 1 && _Day <= 31;
        }

    private:
        unsigned char _Day;
    };

    _NODISCARD constexpr bool operator==(const day& _Left, const day& _Right) noexcept {
        return static_cast<unsigned int>(_Left) == static_cast<unsigned int>(_Right);
    }
    _NODISCARD constexpr strong_ordering operator<=>(const day& _Left, const day& _Right) noexcept {
        return static_cast<unsigned int>(_Left) <=> static_cast<unsigned int>(_Right);
    }

    _NODISCARD constexpr day operator+(const day& _Left, const days& _Right) noexcept {
        return day{static_cast<unsigned int>(_Left) + _Right.count()};
    }
    _NODISCARD constexpr day operator+(const days& _Left, const day& _Right) noexcept {
        return _Right + _Left;
    }
    _NODISCARD constexpr day operator-(const day& _Left, const days& _Right) noexcept {
        return day{static_cast<unsigned int>(_Left) - _Right.count()};
    }
    _NODISCARD constexpr days operator-(const day& _Left, const day& _Right) noexcept {
        return days{
            static_cast<int>(static_cast<unsigned int>(_Left)) - static_cast<int>(static_cast<unsigned int>(_Right))};
    }

    class month {
    public:
        month() = default;
        constexpr explicit month(unsigned int _Val) noexcept : _Month{static_cast<unsigned char>(_Val)} {}

        constexpr month& operator++() noexcept {
            *this += months{1};
            return *this;
        }
        constexpr month operator++(int) noexcept {
            month _Temp{*this};
            ++*this;
            return _Temp;
        }
        constexpr month& operator--() noexcept {
            *this -= months{1};
            return *this;
        }
        constexpr month operator--(int) noexcept {
            month _Temp{*this};
            --*this;
            return _Temp;
        }

        constexpr month& operator+=(const months& _Months) noexcept;
        constexpr month& operator-=(const months& _Months) noexcept;

        _NODISCARD constexpr explicit operator unsigned int() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Month >= 1 && _Month <= 12;
        }

    private:
        unsigned char _Month;
    };

    _NODISCARD constexpr bool operator==(const month& _Left, const month& _Right) noexcept {
        return static_cast<unsigned int>(_Left) == static_cast<unsigned int>(_Right);
    }
    _NODISCARD constexpr strong_ordering operator<=>(const month& _Left, const month& _Right) noexcept {
        return static_cast<unsigned int>(_Left) <=> static_cast<unsigned int>(_Right);
    }

    _NODISCARD constexpr month operator+(const month& _Left, const months& _Right) noexcept {
        const auto _Mo  = static_cast<long long>(static_cast<unsigned int>(_Left)) + (_Right.count() - 1);
        const auto _Div = (_Mo >= 0 ? _Mo : _Mo - 11) / 12;
        return month{static_cast<unsigned int>(_Mo - _Div * 12 + 1)};
    }
    _NODISCARD constexpr month operator+(const months& _Left, const month& _Right) noexcept {
        return _Right + _Left;
    }
    _NODISCARD constexpr month operator-(const month& _Left, const months& _Right) noexcept {
        return _Left + -_Right;
    }
    _NODISCARD constexpr months operator-(const month& _Left, const month& _Right) noexcept {
        const auto _Mo = static_cast<unsigned int>(_Left) - static_cast<unsigned int>(_Right);
        return months{_Mo <= 11 ? _Mo : _Mo + 12};
    }

    constexpr month& month::operator+=(const months& _Months) noexcept {
        *this = *this + _Months;
        return *this;
    }
    constexpr month& month::operator-=(const months& _Months) noexcept {
        *this = *this - _Months;
        return *this;
    }

    class year {
    public:
        year() = default;
        constexpr explicit year(int _Val) noexcept : _Year{static_cast<short>(_Val)} {}

        constexpr year& operator++() noexcept {
            ++_Year;
            return *this;
        }
        constexpr year operator++(int) noexcept {
            return year{_Year++};
        }
        constexpr year& operator--() noexcept {
            --_Year;
            return *this;
        }
        constexpr year operator--(int) noexcept {
            return year{_Year--};
        }

        constexpr year& operator+=(const years& _Years) noexcept {
#ifdef __EDG__ // TRANSITION, VSO-1271098
            _Year = static_cast<short>(_Year + _Years.count());
#else // ^^^ workaround / no workaround vvv
            _Year += static_cast<short>(_Years.count());
#endif // ^^^ no workaround ^^^
            return *this;
        }
        constexpr year& operator-=(const years& _Years) noexcept {
#ifdef __EDG__ // TRANSITION, VSO-1271098
            _Year = static_cast<short>(_Year - _Years.count());
#else // ^^^ workaround / no workaround vvv
            _Year -= static_cast<short>(_Years.count());
#endif // ^^^ no workaround ^^^
            return *this;
        }

        _NODISCARD constexpr year operator+() const noexcept {
            return *this;
        }
        _NODISCARD constexpr year operator-() const noexcept {
            return year{-_Year};
        }

        _NODISCARD constexpr bool is_leap() const noexcept {
            return _Year % 4 == 0 && (_Year % 100 != 0 || _Year % 400 == 0);
        }

        _NODISCARD constexpr explicit operator int() const noexcept {
            return _Year;
        }

        _NODISCARD constexpr bool ok() const noexcept {
            return _Year_min <= _Year && _Year <= _Year_max;
        }

        _NODISCARD static constexpr year(min)() noexcept {
            return year{_Year_min};
        }
        _NODISCARD static constexpr year(max)() noexcept {
            return year{_Year_max};
        }

    private:
        short _Year;
        static constexpr int _Year_min = -32767;
        static constexpr int _Year_max = 32767;
    };

    _NODISCARD constexpr bool operator==(const year& _Left, const year& _Right) noexcept {
        return static_cast<int>(_Left) == static_cast<int>(_Right);
    }
    _NODISCARD constexpr strong_ordering operator<=>(const year& _Left, const year& _Right) noexcept {
        return static_cast<int>(_Left) <=> static_cast<int>(_Right);
    }

    _NODISCARD constexpr year operator+(const year& _Left, const years& _Right) noexcept {
        return year{static_cast<int>(_Left) + _Right.count()};
    }
    _NODISCARD constexpr year operator+(const years& _Left, const year& _Right) noexcept {
        return _Right + _Left;
    }
    _NODISCARD constexpr year operator-(const year& _Left, const years& _Right) noexcept {
        return _Left + -_Right;
    }
    _NODISCARD constexpr years operator-(const year& _Left, const year& _Right) noexcept {
        return years{static_cast<int>(_Left) - static_cast<int>(_Right)};
    }

    class weekday_indexed;
    class weekday_last;

    class weekday {
    public:
        weekday() = default;
        constexpr explicit weekday(unsigned int _Val) noexcept
            : _Weekday{static_cast<unsigned char>(_Val == 7 ? 0 : _Val)} {}
        constexpr weekday(const sys_days& _Sys_day) noexcept
            : _Weekday{static_cast<unsigned char>(_Weekday_from_days(_Sys_day.time_since_epoch().count()))} {}
        constexpr explicit weekday(const local_days& _Local_day) noexcept
            : _Weekday{static_cast<unsigned char>(_Weekday_from_days(_Local_day.time_since_epoch().count()))} {}

        constexpr weekday& operator++() noexcept {
            return *this += days{1};
        }
        constexpr weekday operator++(int) noexcept {
            weekday _Temp{*this};
            ++*this;
            return _Temp;
        }
        constexpr weekday& operator--() noexcept {
            return *this -= days{1};
        }
        constexpr weekday operator--(int) noexcept {
            weekday _Temp{*this};
            --*this;
            return _Temp;
        }

        constexpr weekday& operator+=(const days& _Days) noexcept;
        constexpr weekday& operator-=(const days& _Days) noexcept;

        _NODISCARD constexpr unsigned int c_encoding() const noexcept {
            return _Weekday;
        }
        _NODISCARD constexpr unsigned int iso_encoding() const noexcept {
            return _Weekday == 0u ? 7u : _Weekday;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Weekday <= 6;
        }

        _NODISCARD constexpr weekday_indexed operator[](unsigned int _Index) const noexcept;
        _NODISCARD constexpr weekday_last operator[](last_spec) const noexcept;

    private:
        unsigned char _Weekday;

        // courtesy of Howard Hinnant
        // https://howardhinnant.github.io/date_algorithms.html#weekday_from_days
        _NODISCARD static constexpr unsigned int _Weekday_from_days(int _Tp) noexcept {
            return static_cast<unsigned int>(_Tp >= -4 ? (_Tp + 4) % 7 : (_Tp + 5) % 7 + 6);
        }
    };

    _NODISCARD constexpr bool operator==(const weekday& _Left, const weekday& _Right) noexcept {
        return _Left.c_encoding() == _Right.c_encoding();
    }

    _NODISCARD constexpr weekday operator+(const weekday& _Left, const days& _Right) noexcept {
        const auto _Wd  = static_cast<long long>(_Left.c_encoding()) + _Right.count();
        const auto _Div = (_Wd >= 0 ? _Wd : _Wd - 6) / 7;
        return weekday{static_cast<unsigned int>(_Wd - _Div * 7)};
    }
    _NODISCARD constexpr weekday operator+(const days& _Left, const weekday& _Right) noexcept {
        return _Right + _Left;
    }
    _NODISCARD constexpr weekday operator-(const weekday& _Left, const days& _Right) noexcept {
        return _Left + -_Right;
    }
    _NODISCARD constexpr days operator-(const weekday& _Left, const weekday& _Right) noexcept {
        const auto _Wd = _Left.c_encoding() - _Right.c_encoding();
        const auto _Wk = _Wd <= 6 ? _Wd : _Wd + 7;
        return days{_Wk};
    }

    constexpr weekday& weekday::operator+=(const days& _Days) noexcept {
        *this = *this + _Days;
        return *this;
    }
    constexpr weekday& weekday::operator-=(const days& _Days) noexcept {
        *this = *this - _Days;
        return *this;
    }

    class weekday_indexed {
    public:
        weekday_indexed() = default;
        constexpr weekday_indexed(const weekday& _Wd, unsigned int _Idx) noexcept
            : _Weekday{_Wd}, _Index{static_cast<unsigned char>(_Idx)} {}

        _NODISCARD constexpr weekday weekday() const noexcept {
            return _Weekday;
        }
        _NODISCARD constexpr unsigned int index() const noexcept {
            return _Index;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Weekday.ok() && _Index >= 1 && _Index <= 5;
        }

    private:
        _CHRONO weekday _Weekday;
        unsigned char _Index;
    };

    _NODISCARD constexpr bool operator==(const weekday_indexed& _Left, const weekday_indexed& _Right) noexcept {
        return _Left.weekday() == _Right.weekday() && _Left.index() == _Right.index();
    }

    class weekday_last {
    public:
        constexpr explicit weekday_last(const weekday& _Wd) noexcept : _Weekday{_Wd} {}

        _NODISCARD constexpr weekday weekday() const noexcept {
            return _Weekday;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Weekday.ok();
        }

    private:
        _CHRONO weekday _Weekday;
    };

    _NODISCARD constexpr bool operator==(const weekday_last& _Left, const weekday_last& _Right) noexcept {
        return _Left.weekday() == _Right.weekday();
    }

    _NODISCARD constexpr weekday_indexed weekday::operator[](unsigned int _Index) const noexcept {
        return {*this, _Index};
    }
    _NODISCARD constexpr weekday_last weekday::operator[](last_spec) const noexcept {
        return weekday_last{*this};
    }

    class month_day {
    public:
        month_day() = default;
        constexpr month_day(const month& _Month_, const day& _Day_) noexcept : _Month{_Month_}, _Day{_Day_} {}

        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr day day() const noexcept {
            return _Day;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            if (!_Month.ok() || !_Day.ok()) {
                return false;
            }

            const auto _Da = static_cast<unsigned int>(_Day);
            const auto _Mo = static_cast<unsigned int>(_Month);
            if (_Mo == 2) {
                return _Da <= 29;
            }

            if (_Mo == 4 || _Mo == 6 || _Mo == 9 || _Mo == 11) {
                return _Da <= 30;
            }
            return true;
        }

    private:
        _CHRONO month _Month;
        _CHRONO day _Day;
    };

    _NODISCARD constexpr bool operator==(const month_day& _Left, const month_day& _Right) noexcept {
        return _Left.month() == _Right.month() && _Left.day() == _Right.day();
    }
    _NODISCARD constexpr strong_ordering operator<=>(const month_day& _Left, const month_day& _Right) noexcept {
        const auto _Comp = _Left.month() <=> _Right.month();
        if (_Comp != 0) {
            return _Comp;
        }

        return _Left.day() <=> _Right.day();
    }

    class month_day_last {
    public:
        constexpr explicit month_day_last(const month& _Month_) noexcept : _Month{_Month_} {}

        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Month.ok();
        }

    private:
        _CHRONO month _Month;
    };

    _NODISCARD constexpr bool operator==(const month_day_last& _Left, const month_day_last& _Right) noexcept {
        return _Left.month() == _Right.month();
    }
    _NODISCARD constexpr strong_ordering operator<=>(
        const month_day_last& _Left, const month_day_last& _Right) noexcept {
        return _Left.month() <=> _Right.month();
    }

    class month_weekday {
    public:
        constexpr month_weekday(const month& _Month_, const weekday_indexed& _Wdi) noexcept
            : _Month{_Month_}, _Weekday_index{_Wdi} {}

        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr weekday_indexed weekday_indexed() const noexcept {
            return _Weekday_index;
        }

        _NODISCARD constexpr bool ok() const noexcept {
            return _Month.ok() && _Weekday_index.ok();
        }

    private:
        _CHRONO month _Month;
        _CHRONO weekday_indexed _Weekday_index;
    };

    _NODISCARD constexpr bool operator==(const month_weekday& _Left, const month_weekday& _Right) noexcept {
        return _Left.month() == _Right.month() && _Left.weekday_indexed() == _Right.weekday_indexed();
    }

    class month_weekday_last {
    public:
        constexpr month_weekday_last(const month& _Month_, const weekday_last& _Wdl) noexcept
            : _Month{_Month_}, _Weekday_last{_Wdl} {}

        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr weekday_last weekday_last() const noexcept {
            return _Weekday_last;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Month.ok() && _Weekday_last.ok();
        }

    private:
        _CHRONO month _Month;
        _CHRONO weekday_last _Weekday_last;
    };

    _NODISCARD constexpr bool operator==(const month_weekday_last& _Left, const month_weekday_last& _Right) noexcept {
        return _Left.month() == _Right.month() && _Left.weekday_last() == _Right.weekday_last();
    }

    class year_month {
    public:
        year_month() = default;
        constexpr year_month(const year& _Year_, const month& _Month_) noexcept : _Year{_Year_}, _Month{_Month_} {}

        _NODISCARD constexpr year year() const noexcept {
            return _Year;
        }
        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }

        template <int = 0>
        constexpr year_month& operator+=(const months& _Months) noexcept;
        template <int = 0>
        constexpr year_month& operator-=(const months& _Months) noexcept;
        constexpr year_month& operator+=(const years& _Years) noexcept;
        constexpr year_month& operator-=(const years& _Years) noexcept;

        _NODISCARD constexpr bool ok() const noexcept {
            return _Year.ok() && _Month.ok();
        }

    private:
        _CHRONO year _Year;
        _CHRONO month _Month;
    };

    _NODISCARD constexpr bool operator==(const year_month& _Left, const year_month& _Right) noexcept {
        return _Left.year() == _Right.year() && _Left.month() == _Right.month();
    }
    _NODISCARD constexpr strong_ordering operator<=>(const year_month& _Left, const year_month& _Right) noexcept {
        const auto _Comp = _Left.year() <=> _Right.year();
        if (_Comp != 0) {
            return _Comp;
        }

        return _Left.month() <=> _Right.month();
    }

    template <int = 0>
    _NODISCARD constexpr year_month operator+(const year_month& _Left, const months& _Right) noexcept {
        const auto _Mo  = static_cast<long long>(static_cast<unsigned int>(_Left.month())) + (_Right.count() - 1);
        const auto _Div = (_Mo >= 0 ? _Mo : _Mo - 11) / 12;
        return year_month{_Left.year() + years{_Div}, month{static_cast<unsigned int>(_Mo - _Div * 12 + 1)}};
    }
    template <int = 0>
    _NODISCARD constexpr year_month operator+(const months& _Left, const year_month& _Right) noexcept {
        return _Right + _Left;
    }

    template <int = 0>
    _NODISCARD constexpr year_month operator-(const year_month& _Left, const months& _Right) noexcept {
        return _Left + -_Right;
    }

    _NODISCARD constexpr months operator-(const year_month& _Left, const year_month& _Right) noexcept {
        return _Left.year() - _Right.year()
             + months{static_cast<int>(static_cast<unsigned int>(_Left.month()))
                      - static_cast<int>(static_cast<unsigned int>(_Right.month()))};
    }

    _NODISCARD constexpr year_month operator+(const year_month& _Left, const years& _Right) noexcept {
        return {year{_Left.year() + _Right}, _Left.month()};
    }

    _NODISCARD constexpr year_month operator+(const years& _Left, const year_month& _Right) noexcept {
        return _Right + _Left;
    }

    _NODISCARD constexpr year_month operator-(const year_month& _Left, const years& _Right) noexcept {
        return _Left + -_Right;
    }

    template <int>
    constexpr year_month& year_month::operator+=(const months& _Months) noexcept {
        *this = *this + _Months;
        return *this;
    }
    template <int>
    constexpr year_month& year_month::operator-=(const months& _Months) noexcept {
        *this = *this - _Months;
        return *this;
    }
    constexpr year_month& year_month::operator+=(const years& _Years) noexcept {
        *this = *this + _Years;
        return *this;
    }
    constexpr year_month& year_month::operator-=(const years& _Years) noexcept {
        *this = *this - _Years;
        return *this;
    }

    // To prevent UB by going out of bounds, four extra days with an invalid day are added.
    inline constexpr day _Last_day_table[] = {day{31}, day{28}, day{31}, day{30}, day{31}, day{30}, day{31}, day{31},
        day{30}, day{31}, day{30}, day{31}, day{255}, day{255}, day{255}, day{255}};

    _NODISCARD constexpr day _Last_day(const year& _Year, const month& _Month) {
        if (_Month == month{2} && _Year.is_leap()) {
            return day{29};
        }

        return _Last_day_table[(static_cast<unsigned int>(_Month) - 1) & 0xF];
    }

    class year_month_day_last;

    class year_month_day {
    public:
        year_month_day() = default;
        constexpr year_month_day(const year& _Year_, const month& _Month_, const day& _Day_) noexcept
            : _Year{_Year_}, _Month{_Month_}, _Day{_Day_} {}
        constexpr year_month_day(const year_month_day_last& _Ymdl) noexcept;
        constexpr year_month_day(const sys_days& _Sys_days) noexcept
            : year_month_day{_Civil_from_days(_Sys_days.time_since_epoch().count())} {}
        constexpr explicit year_month_day(const local_days& _Local_days) noexcept
            : year_month_day{_Civil_from_days(_Local_days.time_since_epoch().count())} {}

        template <int = 0>
        constexpr year_month_day& operator+=(const months& _Months) noexcept;
        template <int = 0>
        constexpr year_month_day& operator-=(const months& _Months) noexcept;
        constexpr year_month_day& operator+=(const years& _Years) noexcept;
        constexpr year_month_day& operator-=(const years& _Years) noexcept;

        _NODISCARD constexpr year year() const noexcept {
            return _Year;
        }
        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr day day() const noexcept {
            return _Day;
        }

        _NODISCARD constexpr operator sys_days() const noexcept {
            return sys_days{_Days_from_civil()};
        }
        _NODISCARD constexpr explicit operator local_days() const noexcept {
            return local_days{static_cast<sys_days>(*this).time_since_epoch()};
        }
        _NODISCARD constexpr bool ok() const noexcept {
            if (!_Year.ok() || !_Month.ok()) {
                return false;
            }

            return _Day >= _CHRONO day{1} && _Day <= _Last_day(_Year, _Month);
        }

    private:
        _CHRONO year _Year;
        _CHRONO month _Month;
        _CHRONO day _Day;

        // _Civil_from_days and _Days_from_civil perform conversions between the dates in the (proleptic) Gregorian
        // calendar and the continuous count of days since 1970-01-01.

        // To simplify the handling of leap days (February 29th), the algorithm below uses a modified calendar
        // internally, in which each year begins on March 1st, while January and February belong to the previous year.
        // We denote the modified year and month number as _Yp and _Mp. We also define modified centuries that begin on
        // each modified year whose _Yp is a multiple of 100.

        // _Mp | Month     | Day of Year
        // --- | --------- | -----------
        //  0  | March     | [  0,  30]
        //  1  | April     | [ 31,  60]
        //  2  | May       | [ 61,  91]
        //  3  | June      | [ 92, 121]
        //  4  | July      | [122, 152]
        //  5  | August    | [153, 183]
        //  6  | September | [184, 213]
        //  7  | October   | [214, 244]
        //  8  | November  | [245, 274]
        //  9  | December  | [275, 305]
        // 10  | January   | [306, 336]
        // 11  | February  | [337, 365] on leap years, [337, 364] on regular years

        // _Yp |  First Day  | Last Day (inclusive) | Leap Year?
        // --- | ----------- | -------------------- | ----------
        //  -4 | -0004-03-01 |     -0003-02-28      |     No
        //  -3 | -0003-03-01 |     -0002-02-28      |     No
        //  -2 | -0002-03-01 |     -0001-02-28      |     No
        //  -1 | -0001-03-01 |      0000-02-29      |     Yes
        //   0 |  0000-03-01 |      0001-02-28      |     No
        //   1 |  0001-03-01 |      0002-02-28      |     No
        //   2 |  0002-03-01 |      0003-02-28      |     No
        //   3 |  0003-03-01 |      0004-02-29      |     Yes

        // _Century |  First Day  | Last Day (inclusive) | Long Century?
        // -------- | ----------- | -------------------- | -------------
        //    -4    | -0400-03-01 |     -0300-02-28      |      No
        //    -3    | -0300-03-01 |     -0200-02-28      |      No
        //    -2    | -0200-03-01 |     -0100-02-28      |      No
        //    -1    | -0100-03-01 |      0000-02-29      |      Yes
        //     0    |  0000-03-01 |      0100-02-28      |      No
        //     1    |  0100-03-01 |      0200-02-28      |      No
        //     2    |  0200-03-01 |      0300-02-28      |      No
        //     3    |  0300-03-01 |      0400-02-29      |      Yes

        // The structure of the modified calendar:
        // 1 ) It has a period of 4 centuries.
        // 2 ) Each calendar period (146097 days) contains 3 regular centuries followed by a long century (36525 days).
        // 3 ) Each regular century (36524 days) contains 24 regular 4-year spans followed by a short 4-year span.
        // 3') Each long century (36525 days) contains 25 regular 4-year spans.
        // 4 ) Each regular 4-year span (1461 days) contains 3 regular years followed by a leap year.
        // 4') Each short 4-year span (1460 days) contains 4 regular years.

        // Formula 1: Compute _Day_of_year of the first day of month _Mp
        //
        //   _Day_of_year = (979 * _Mp + 19) >> 5
        //
        // A more well-known formula is 30 * _Mp + floor((3 * _Mp + 2) / 5) or floor((153 * _Mp + 2) / 5), which is used
        // in Howard Hinnant's paper.
        //
        // The formula above returns the same result for all _Mp in [0, 11].
        // Note that 979 / 2^5 = 30.59375 ~= 30.6 = 153 / 5.

        // Formula 1': Compute _Mp from _Day_of_year
        //
        //   _Mp = (535 * _Day_of_year + 333) >> 14
        //
        // Howard Hinnant's paper uses floor((5 * _Day_of_year + 2) / 153), the inverse of floor((153 * _Mp + 2) / 5) or
        // ceil((153 * _Mp - 2) / 5).
        //
        // The formula above returns the same result for all _Day_of_year in [0, 365].
        // Note that 2^14 / 535 = 30.624... ~= 30.6 = 153 / 5.

        // Formula 2: Compute _Zx of the first day of year _Yp, where _Zx is the continuous count of days since
        // 0000-03-01.
        //
        //   _Zx = ((1461 * _Yp) >> 2) - _Century + (_Century >> 2)
        //
        // Start with multiplying by the number of days in regular years (365), add one day for the leap year in each
        // 4-year span, subtract one day for the short 4-year span in each century, and finally add one day for the long
        // century in each calendar period. This gives us 365 * _Yp + floor(_Yp / 4) - _Century + floor(_Century / 4).

        // Formula 2-1: Compute _Day_of_century of the first day of year _Year_of_century
        //
        //   _Day_of_century = (1461 * _Year_of_century) >> 2
        //
        // Start with multiplying by the number of days in regular years (365), add one day for the leap year in each
        // 4-year span. This gives us 365 * _Year_of_century + floor(_Year_of_century / 4)
        // == floor(1461 * _Year_of_century / 4).

        // Formula 2-1': Compute _Year_of_century from _Day_of_century
        //
        //   _Year_of_century = (91867 * (_Day_of_century + 1)) >> 25
        //
        // The inverse of floor(1461 * _Year_of_century / 4) or ceil((1461 * _Year_of_century - 3) / 4) is
        // floor((4 * _Day_of_century + 3) / 1461).
        //
        // The formula above returns the same result for all _Day_of_century in [0, 36524].
        // Note that 2^25 / 91867 = 365.2501... ~= 365.25 = 1461 / 4.

        // Formula 2-2: Compute _Zx of the first day of century _Century, where _Zx is the continuous count of days
        // since 0000-03-01.
        //
        //   _Zx = (146097 * _Century) >> 2
        //
        // Start with multiplying by the number of days in regular centuries (36524), add one day for the long century
        // in each calendar period. This gives us 36524 * _Century + floor(_Century / 4) = floor(146097 * _Century / 4).

        // Formula 2-2': Compute _Century from _Zx, where _Zx is the continuous count of days since 0000-03-01.
        //
        //   _Century = floor((4 * _Zx + 3) / 146097)
        //
        // This is the inverse of floor(146097 * _Year_of_century / 4) or ceil((146097 * _Year_of_century - 3) / 4)

        // courtesy of Howard Hinnant
        // https://howardhinnant.github.io/date_algorithms.html#civil_from_days
        _NODISCARD static constexpr year_month_day _Civil_from_days(int _Tp) noexcept {
            static_assert(numeric_limits<unsigned int>::digits >= 32);
            static_assert(numeric_limits<int>::digits >= 26);
            const int _Zx = _Tp + 719468; // Shift epoch to 0000-03-01
            // Formula 2-2'
            const int _Century = (_Zx >= 0 ? 4 * _Zx + 3 : 4 * _Zx - 146093) / 146097;
            // Formula 2-2
            const unsigned int _Day_of_century =
                static_cast<unsigned int>(_Zx - ((146097 * _Century) >> 2)); // [0, 36524]
            // Formula 2-1'
            const unsigned int _Year_of_century = (91867 * (_Day_of_century + 1)) >> 25; // [0, 99]
            const int _Yp = static_cast<int>(_Year_of_century) + _Century * 100; // Where March is the first month
            // Formula 2-1
            const unsigned int _Day_of_year = _Day_of_century - ((1461 * _Year_of_century) >> 2); // [0, 365]
            // Formula 1'
            const unsigned int _Mp = (535 * _Day_of_year + 333) >> 14; // [0, 11]
            // Formula 1
            const unsigned int _Day   = _Day_of_year - ((979 * _Mp + 19) >> 5) + 1; // [1, 31]
            const unsigned int _Month = _Mp + (_Mp < 10 ? 3 : static_cast<unsigned int>(-9)); // [1, 12]
            return year_month_day{_CHRONO year{_Yp + (_Month <= 2)}, _CHRONO month{_Month}, _CHRONO day{_Day}};
        }
        // courtesy of Howard Hinnant
        // https://howardhinnant.github.io/date_algorithms.html#days_from_civil
        _NODISCARD constexpr days _Days_from_civil() const noexcept {
            static_assert(numeric_limits<unsigned int>::digits >= 18);
            static_assert(numeric_limits<int>::digits >= 26);
            const unsigned int _Mo = static_cast<unsigned int>(_Month); // [1, 12]
            const int _Yp          = static_cast<int>(_Year) - (_Mo <= 2);
            const int _Century     = (_Yp >= 0 ? _Yp : _Yp - 99) / 100;
            const unsigned int _Mp = _Mo + (_Mo > 2 ? static_cast<unsigned int>(-3) : 9); // [0, 11]
            // Formula 1
            const int _Day_of_year = static_cast<int>(((979 * _Mp + 19) >> 5) + static_cast<unsigned int>(_Day)) - 1;
            // Formula 2
            return days{((1461 * _Yp) >> 2) - _Century + (_Century >> 2) + _Day_of_year - 719468};
        }
    };

    _NODISCARD constexpr bool operator==(const year_month_day& _Left, const year_month_day& _Right) noexcept {
        return _Left.year() == _Right.year() && _Left.month() == _Right.month() && _Left.day() == _Right.day();
    }
    _NODISCARD constexpr strong_ordering operator<=>(
        const year_month_day& _Left, const year_month_day& _Right) noexcept {
        auto _Comp = _Left.year() <=> _Right.year();
        if (_Comp != 0) {
            return _Comp;
        }

        _Comp = _Left.month() <=> _Right.month();
        if (_Comp != 0) {
            return _Comp;
        }

        return _Left.day() <=> _Right.day();
    }

    template <int = 0>
    _NODISCARD constexpr year_month_day operator+(const year_month_day& _Left, const months& _Right) noexcept {
        const auto _Ym = year_month{_Left.year(), _Left.month()} + _Right;
        return {_Ym.year(), _Ym.month(), _Left.day()};
    }

    template <int = 0>
    _NODISCARD constexpr year_month_day operator+(const months& _Left, const year_month_day& _Right) noexcept {
        return _Right + _Left;
    }

    template <int = 0>
    _NODISCARD constexpr year_month_day operator-(const year_month_day& _Left, const months& _Right) noexcept {
        return _Left + -_Right;
    }

    _NODISCARD constexpr year_month_day operator+(const year_month_day& _Left, const years& _Right) noexcept {
        return {_Left.year() + _Right, _Left.month(), _Left.day()};
    }

    _NODISCARD constexpr year_month_day operator+(const years& _Left, const year_month_day& _Right) noexcept {
        return _Right + _Left;
    }

    _NODISCARD constexpr year_month_day operator-(const year_month_day& _Left, const years& _Right) noexcept {
        return _Left + -_Right;
    }

    template <int>
    constexpr year_month_day& year_month_day::operator+=(const months& _Months) noexcept {
        *this = *this + _Months;
        return *this;
    }
    template <int>
    constexpr year_month_day& year_month_day::operator-=(const months& _Months) noexcept {
        *this = *this - _Months;
        return *this;
    }
    constexpr year_month_day& year_month_day::operator+=(const years& _Years) noexcept {
        *this = *this + _Years;
        return *this;
    }
    constexpr year_month_day& year_month_day::operator-=(const years& _Years) noexcept {
        *this = *this - _Years;
        return *this;
    }

    class year_month_day_last {
    public:
        constexpr year_month_day_last(const year& _Year_, const month_day_last& _Mdl) noexcept
            : _Year{_Year_}, _Month_day_last{_Mdl} {}

        template <int = 0>
        constexpr year_month_day_last& operator+=(const months& _Months) noexcept;
        template <int = 0>
        constexpr year_month_day_last& operator-=(const months& _Months) noexcept;
        constexpr year_month_day_last& operator+=(const years& _Years) noexcept;
        constexpr year_month_day_last& operator-=(const years& _Years) noexcept;

        _NODISCARD constexpr year year() const noexcept {
            return _Year;
        }
        _NODISCARD constexpr month month() const noexcept {
            return _Month_day_last.month();
        }
        _NODISCARD constexpr month_day_last month_day_last() const noexcept {
            return _Month_day_last;
        }
        _NODISCARD constexpr day day() const noexcept {
            return _Last_day(year(), month());
        }

        _NODISCARD constexpr operator sys_days() const noexcept {
            return sys_days{year_month_day{year(), month(), day()}};
        }
        _NODISCARD constexpr explicit operator local_days() const noexcept {
            return local_days{static_cast<sys_days>(*this).time_since_epoch()};
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Year.ok() && _Month_day_last.ok();
        }

    private:
        _CHRONO year _Year;
        _CHRONO month_day_last _Month_day_last;
    };

    _NODISCARD constexpr bool operator==(const year_month_day_last& _Left, const year_month_day_last& _Right) noexcept {
        return _Left.year() == _Right.year() && _Left.month_day_last() == _Right.month_day_last();
    }
    _NODISCARD constexpr strong_ordering operator<=>(
        const year_month_day_last& _Left, const year_month_day_last& _Right) noexcept {
        const auto _Comp = _Left.year() <=> _Right.year();
        if (_Comp != 0) {
            return _Comp;
        }

        return _Left.month_day_last() <=> _Right.month_day_last();
    }

    template <int = 0>
    _NODISCARD constexpr year_month_day_last operator+(
        const year_month_day_last& _Left, const months& _Right) noexcept {
        const auto _Ym = year_month{_Left.year(), _Left.month()} + _Right;
        return {_Ym.year(), month_day_last{_Ym.month()}};
    }
    template <int = 0>
    _NODISCARD constexpr year_month_day_last operator+(
        const months& _Left, const year_month_day_last& _Right) noexcept {
        return _Right + _Left;
    }

    template <int = 0>
    _NODISCARD constexpr year_month_day_last operator-(
        const year_month_day_last& _Left, const months& _Right) noexcept {
        return _Left + -_Right;
    }

    _NODISCARD constexpr year_month_day_last operator+(const year_month_day_last& _Left, const years& _Right) noexcept {
        return {_Left.year() + _Right, _Left.month_day_last()};
    }
    _NODISCARD constexpr year_month_day_last operator+(const years& _Left, const year_month_day_last& _Right) noexcept {
        return _Right + _Left;
    }
    _NODISCARD constexpr year_month_day_last operator-(const year_month_day_last& _Left, const years& _Right) noexcept {
        return _Left + -_Right;
    }

    template <int>
    constexpr year_month_day_last& year_month_day_last::operator+=(const months& _Months) noexcept {
        *this = *this + _Months;
        return *this;
    }
    template <int>
    constexpr year_month_day_last& year_month_day_last::operator-=(const months& _Months) noexcept {
        *this = *this - _Months;
        return *this;
    }
    constexpr year_month_day_last& year_month_day_last::operator+=(const years& _Years) noexcept {
        *this = *this + _Years;
        return *this;
    }
    constexpr year_month_day_last& year_month_day_last::operator-=(const years& _Years) noexcept {
        *this = *this - _Years;
        return *this;
    }

    constexpr year_month_day::year_month_day(const year_month_day_last& _Ymdl) noexcept
        : _Year{_Ymdl.year()}, _Month{_Ymdl.month()}, _Day{_Ymdl.day()} {}

    class year_month_weekday {
    public:
        year_month_weekday() = default;
        constexpr year_month_weekday(const year& _Year_, const month& _Month_, const weekday_indexed& _Wdi) noexcept
            : _Year{_Year_}, _Month{_Month_}, _Weekday_index{_Wdi} {}
        constexpr year_month_weekday(const sys_days& _Sys_days) noexcept
            : year_month_weekday{_Ymwd_from_days(_Sys_days.time_since_epoch())} {}
        constexpr explicit year_month_weekday(const local_days& _Local_days) noexcept
            : year_month_weekday{_Ymwd_from_days(_Local_days.time_since_epoch())} {}

        template <int = 0>
        constexpr year_month_weekday& operator+=(const months& _Months) noexcept;
        template <int = 0>
        constexpr year_month_weekday& operator-=(const months& _Months) noexcept;
        constexpr year_month_weekday& operator+=(const years& _Years) noexcept;
        constexpr year_month_weekday& operator-=(const years& _Years) noexcept;

        _NODISCARD constexpr year year() const noexcept {
            return _Year;
        }
        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr weekday weekday() const noexcept {
            return _Weekday_index.weekday();
        }
        _NODISCARD constexpr unsigned int index() const noexcept {
            return _Weekday_index.index();
        }
        _NODISCARD constexpr weekday_indexed weekday_indexed() const noexcept {
            return _Weekday_index;
        }

        _NODISCARD constexpr operator sys_days() const noexcept {
            const sys_days _First = year_month_day{_Year, _Month, day{1}};
            const days _Diff      = weekday() - _CHRONO weekday{_First};
            const days _Days      = _Diff + days{(static_cast<int>(index()) - 1) * 7};
            return _First + _Days;
        }
        _NODISCARD constexpr explicit operator local_days() const noexcept {
            return local_days{static_cast<sys_days>(*this).time_since_epoch()};
        }
        _NODISCARD constexpr bool ok() const noexcept {
            if (!_Year.ok() || !_Month.ok() || !_Weekday_index.ok()) {
                return false;
            }

            if (_Weekday_index.index() <= 4) {
                return true;
            }

            // As index() == 5 is not always valid
            // Determine the date of the first weekday and check if + days{28} is <= last day of the month
            const sys_days _First_of_month = year_month_day{_Year, _Month, day{1}};
            const days _First_weekday      = weekday() - _CHRONO weekday{_First_of_month} + days{1};
            const days _Last               = _First_weekday + days{28};
            return static_cast<unsigned int>(_Last.count()) <= static_cast<unsigned int>(_Last_day(_Year, _Month));
        }

    private:
        _CHRONO year _Year;
        _CHRONO month _Month;
        _CHRONO weekday_indexed _Weekday_index;

        _NODISCARD static constexpr year_month_weekday _Ymwd_from_days(days _Dp) noexcept {
            const _CHRONO year_month_day _Ymd = sys_days{_Dp};
            const _CHRONO weekday _Wd         = sys_days{_Dp};
            const auto _Idx                   = ((static_cast<unsigned int>(_Ymd.day()) - 1) / 7) + 1;
            return {_Ymd.year(), _Ymd.month(), _Wd[_Idx]};
        }
    };

    _NODISCARD constexpr bool operator==(const year_month_weekday& _Left, const year_month_weekday& _Right) noexcept {
        return _Left.year() == _Right.year() && _Left.month() == _Right.month()
            && _Left.weekday_indexed() == _Right.weekday_indexed();
    }

    template <int = 0>
    _NODISCARD constexpr year_month_weekday operator+(const year_month_weekday& _Left, const months& _Right) noexcept {
        const auto _Ym = year_month{_Left.year(), _Left.month()} + _Right;
        return {_Ym.year(), _Ym.month(), _Left.weekday_indexed()};
    }
    template <int = 0>
    _NODISCARD constexpr year_month_weekday operator+(const months& _Left, const year_month_weekday& _Right) noexcept {
        return _Right + _Left;
    }

    template <int = 0>
    _NODISCARD constexpr year_month_weekday operator-(const year_month_weekday& _Left, const months& _Right) noexcept {
        return _Left + -_Right;
    }

    _NODISCARD constexpr year_month_weekday operator+(const year_month_weekday& _Left, const years& _Right) noexcept {
        return year_month_weekday{_Left.year() + _Right, _Left.month(), _Left.weekday_indexed()};
    }
    _NODISCARD constexpr year_month_weekday operator+(const years& _Left, const year_month_weekday& _Right) noexcept {
        return _Right + _Left;
    }

    _NODISCARD constexpr year_month_weekday operator-(const year_month_weekday& _Left, const years& _Right) noexcept {
        return _Left + -_Right;
    }

    template <int>
    constexpr year_month_weekday& year_month_weekday::operator+=(const months& _Months) noexcept {
        *this = *this + _Months;
        return *this;
    }
    template <int>
    constexpr year_month_weekday& year_month_weekday::operator-=(const months& _Months) noexcept {
        *this = *this - _Months;
        return *this;
    }
    constexpr year_month_weekday& year_month_weekday::operator+=(const years& _Years) noexcept {
        *this = *this + _Years;
        return *this;
    }
    constexpr year_month_weekday& year_month_weekday::operator-=(const years& _Years) noexcept {
        *this = *this - _Years;
        return *this;
    }

    class year_month_weekday_last {
    public:
        constexpr year_month_weekday_last(const year& _Year_, const month& _Month_, const weekday_last& _Wdl) noexcept
            : _Year{_Year_}, _Month{_Month_}, _Weekday_last{_Wdl} {}

        template <int = 0>
        constexpr year_month_weekday_last& operator+=(const months& _Months) noexcept;
        template <int = 0>
        constexpr year_month_weekday_last& operator-=(const months& _Months) noexcept;
        constexpr year_month_weekday_last& operator+=(const years& _Years) noexcept;
        constexpr year_month_weekday_last& operator-=(const years& _Years) noexcept;

        _NODISCARD constexpr year year() const noexcept {
            return _Year;
        }
        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr weekday weekday() const noexcept {
            return _Weekday_last.weekday();
        }

        _NODISCARD constexpr weekday_last weekday_last() const noexcept {
            return _Weekday_last;
        }

        _NODISCARD constexpr operator sys_days() const noexcept {
            const sys_days _Last = year_month_day_last{_Year, month_day_last{_Month}};
            const auto _Diff     = _CHRONO weekday{_Last} - weekday();
            return _Last - _Diff;
        }
        _NODISCARD constexpr explicit operator local_days() const noexcept {
            return local_days{static_cast<sys_days>(*this).time_since_epoch()};
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Year.ok() && _Month.ok() && _Weekday_last.ok();
        }

    private:
        _CHRONO year _Year;
        _CHRONO month _Month;
        _CHRONO weekday_last _Weekday_last;
    };

    _NODISCARD constexpr bool operator==(
        const year_month_weekday_last& _Left, const year_month_weekday_last& _Right) noexcept {
        return _Left.year() == _Right.year() && _Left.month() == _Right.month()
            && _Left.weekday_last() == _Right.weekday_last();
    }

    template <int = 0>
    _NODISCARD constexpr year_month_weekday_last operator+(
        const year_month_weekday_last& _Left, const months& _Right) noexcept {
        const auto _Ym = year_month{_Left.year(), _Left.month()} + _Right;
        return {_Ym.year(), _Ym.month(), _Left.weekday_last()};
    }
    template <int = 0>
    _NODISCARD constexpr year_month_weekday_last operator+(
        const months& _Left, const year_month_weekday_last& _Right) noexcept {
        return _Right + _Left;
    }

    template <int = 0>
    _NODISCARD constexpr year_month_weekday_last operator-(
        const year_month_weekday_last& _Left, const months& _Right) noexcept {
        return _Left + -_Right;
    }

    _NODISCARD constexpr year_month_weekday_last operator+(
        const year_month_weekday_last& _Left, const years& _Right) noexcept {
        return {_Left.year() + _Right, _Left.month(), _Left.weekday_last()};
    }
    _NODISCARD constexpr year_month_weekday_last operator+(
        const years& _Left, const year_month_weekday_last& _Right) noexcept {
        return _Right + _Left;
    }

    _NODISCARD constexpr year_month_weekday_last operator-(
        const year_month_weekday_last& _Left, const years& _Right) noexcept {
        return _Left + -_Right;
    }

    template <int>
    constexpr year_month_weekday_last& year_month_weekday_last::operator+=(const months& _Months) noexcept {
        *this = *this + _Months;
        return *this;
    }
    template <int>
    constexpr year_month_weekday_last& year_month_weekday_last::operator-=(const months& _Months) noexcept {
        *this = *this - _Months;
        return *this;
    }
    constexpr year_month_weekday_last& year_month_weekday_last::operator+=(const years& _Years) noexcept {
        *this = *this + _Years;
        return *this;
    }
    constexpr year_month_weekday_last& year_month_weekday_last::operator-=(const years& _Years) noexcept {
        *this = *this - _Years;
        return *this;
    }

    // Civil calendar conventional syntax operators
    _NODISCARD constexpr year_month operator/(const year& _Year, const month& _Month) noexcept {
        return {_Year, _Month};
    }
    _NODISCARD constexpr year_month operator/(const year& _Year, int _Month) noexcept {
        return _Year / month{static_cast<unsigned int>(_Month)};
    }
    _NODISCARD constexpr month_day operator/(const month& _Month, const day& _Day) noexcept {
        return {_Month, _Day};
    }
    _NODISCARD constexpr month_day operator/(const month& _Month, int _Day) noexcept {
        return _Month / day{static_cast<unsigned int>(_Day)};
    }
    _NODISCARD constexpr month_day operator/(int _Month, const day& _Day) noexcept {
        return month{static_cast<unsigned int>(_Month)} / _Day;
    }
    _NODISCARD constexpr month_day operator/(const day& _Day, const month& _Month) noexcept {
        return _Month / _Day;
    }
    _NODISCARD constexpr month_day operator/(const day& _Day, int _Month) noexcept {
        return month{static_cast<unsigned int>(_Month)} / _Day;
    }
    _NODISCARD constexpr month_day_last operator/(const month& _Month, last_spec) noexcept {
        return month_day_last{_Month};
    }
    _NODISCARD constexpr month_day_last operator/(int _Month, last_spec) noexcept {
        return month{static_cast<unsigned int>(_Month)} / last;
    }
    _NODISCARD constexpr month_day_last operator/(last_spec, const month& _Month) noexcept {
        return _Month / last;
    }
    _NODISCARD constexpr month_day_last operator/(last_spec, int _Month) noexcept {
        return month{static_cast<unsigned int>(_Month)} / last;
    }
    _NODISCARD constexpr month_weekday operator/(const month& _Month, const weekday_indexed& _Wdi) noexcept {
        return {_Month, _Wdi};
    }
    _NODISCARD constexpr month_weekday operator/(int _Month, const weekday_indexed& _Wdi) noexcept {
        return month{static_cast<unsigned int>(_Month)} / _Wdi;
    }
    _NODISCARD constexpr month_weekday operator/(const weekday_indexed& _Wdi, const month& _Month) noexcept {
        return _Month / _Wdi;
    }
    _NODISCARD constexpr month_weekday operator/(const weekday_indexed& _Wdi, int _Month) noexcept {
        return month{static_cast<unsigned int>(_Month)} / _Wdi;
    }
    _NODISCARD constexpr month_weekday_last operator/(const month& _Month, const weekday_last& _Wdl) noexcept {
        return {_Month, _Wdl};
    }
    _NODISCARD constexpr month_weekday_last operator/(int _Month, const weekday_last& _Wdl) noexcept {
        return month{static_cast<unsigned int>(_Month)} / _Wdl;
    }
    _NODISCARD constexpr month_weekday_last operator/(const weekday_last& _Wdl, const month& _Month) noexcept {
        return _Month / _Wdl;
    }
    _NODISCARD constexpr month_weekday_last operator/(const weekday_last& _Wdl, int _Month) noexcept {
        return month{static_cast<unsigned int>(_Month)} / _Wdl;
    }
    _NODISCARD constexpr year_month_day operator/(const year_month& _Ym, const day& _Day) noexcept {
        return {_Ym.year(), _Ym.month(), _Day};
    }
    _NODISCARD constexpr year_month_day operator/(const year_month& _Ym, int _Day) noexcept {
        return _Ym / day{static_cast<unsigned int>(_Day)};
    }
    _NODISCARD constexpr year_month_day operator/(const year& _Year, const month_day& _Md) noexcept {
        return _Year / _Md.month() / _Md.day();
    }
    _NODISCARD constexpr year_month_day operator/(int _Year, const month_day& _Md) noexcept {
        return year{_Year} / _Md.month() / _Md.day();
    }
    _NODISCARD constexpr year_month_day operator/(const month_day& _Md, const year& _Year) noexcept {
        return _Year / _Md.month() / _Md.day();
    }
    _NODISCARD constexpr year_month_day operator/(const month_day& _Md, int _Year) noexcept {
        return year{_Year} / _Md.month() / _Md.day();
    }
    _NODISCARD constexpr year_month_day_last operator/(const year_month& _Ym, last_spec) noexcept {
        return {_Ym.year(), month_day_last{_Ym.month()}};
    }
    _NODISCARD constexpr year_month_day_last operator/(const year& _Year, const month_day_last& _Mdl) noexcept {
        return {_Year, _Mdl};
    }
    _NODISCARD constexpr year_month_day_last operator/(int _Year, const month_day_last& _Mdl) noexcept {
        return year{_Year} / _Mdl;
    }
    _NODISCARD constexpr year_month_day_last operator/(const month_day_last& _Mdl, const year& _Year) noexcept {
        return _Year / _Mdl;
    }
    _NODISCARD constexpr year_month_day_last operator/(const month_day_last& _Mdl, int _Year) noexcept {
        return year{_Year} / _Mdl;
    }
    _NODISCARD constexpr year_month_weekday operator/(const year_month& _Ym, const weekday_indexed& _Wdi) noexcept {
        return year_month_weekday{_Ym.year(), _Ym.month(), _Wdi};
    }
    _NODISCARD constexpr year_month_weekday operator/(const year& _Year, const month_weekday& _Mwd) noexcept {
        return year_month_weekday{_Year, _Mwd.month(), _Mwd.weekday_indexed()};
    }
    _NODISCARD constexpr year_month_weekday operator/(int _Year, const month_weekday& _Mwd) noexcept {
        return year{_Year} / _Mwd;
    }
    _NODISCARD constexpr year_month_weekday operator/(const month_weekday& _Mwd, const year& _Year) noexcept {
        return _Year / _Mwd;
    }
    _NODISCARD constexpr year_month_weekday operator/(const month_weekday& _Mwd, int _Year) noexcept {
        return year{_Year} / _Mwd;
    }
    _NODISCARD constexpr year_month_weekday_last operator/(const year_month& _Ym, const weekday_last& _Wdl) noexcept {
        return {_Ym.year(), _Ym.month(), _Wdl};
    }
    _NODISCARD constexpr year_month_weekday_last operator/(
        const year& _Year, const month_weekday_last& _Mwdl) noexcept {
        return {_Year, _Mwdl.month(), _Mwdl.weekday_last()};
    }
    _NODISCARD constexpr year_month_weekday_last operator/(int _Year, const month_weekday_last& _Mwdl) noexcept {
        return year{_Year} / _Mwdl;
    }
    _NODISCARD constexpr year_month_weekday_last operator/(
        const month_weekday_last& _Mwdl, const year& _Year) noexcept {
        return _Year / _Mwdl;
    }
    _NODISCARD constexpr year_month_weekday_last operator/(const month_weekday_last& _Mwdl, int _Year) noexcept {
        return year{_Year} / _Mwdl;
    }

    // Calendrical constants
    inline constexpr weekday Sunday{0};
    inline constexpr weekday Monday{1};
    inline constexpr weekday Tuesday{2};
    inline constexpr weekday Wednesday{3};
    inline constexpr weekday Thursday{4};
    inline constexpr weekday Friday{5};
    inline constexpr weekday Saturday{6};

    inline constexpr month January{1};
    inline constexpr month February{2};
    inline constexpr month March{3};
    inline constexpr month April{4};
    inline constexpr month May{5};
    inline constexpr month June{6};
    inline constexpr month July{7};
    inline constexpr month August{8};
    inline constexpr month September{9};
    inline constexpr month October{10};
    inline constexpr month November{11};
    inline constexpr month December{12};

    _NODISCARD constexpr intmax_t _Pow10(const unsigned int _Exp) {
        intmax_t _Result = 1;
        for (unsigned int _Ix = 0; _Ix < _Exp; ++_Ix) {
            _Result *= 10;
        }
        return _Result;
    }

    template <class _Duration>
    requires _Is_duration_v<_Duration> class hh_mm_ss {
    public:
        static constexpr unsigned int fractional_width = [] {
            auto _Num           = _Duration::period::num;
            constexpr auto _Den = _Duration::period::den;
            // Returns the number of fractional digits of _Num / _Den in the range [0, 18].
            // If it can't be represented, 6 is returned.
            // Example: _Fractional_width(1, 8) would return 3 for 0.125.
            _STL_ASSERT(_Num > 0 && _Den > 0, "Numerator and denominator can't be less than 1.");
            unsigned int _Result = 0;
            for (; _Num % _Den != 0 && _Result < 19; _Num = _Num % _Den * 10, ++_Result) {
            }
            return _Result == 19 ? 6 : _Result;
        }();
        using precision =
            duration<common_type_t<typename _Duration::rep, seconds::rep>, ratio<1, _Pow10(fractional_width)>>;

        constexpr hh_mm_ss() noexcept : hh_mm_ss{_Duration::zero()} {}
        // clang-format off
        constexpr explicit hh_mm_ss(_Duration _Dur)
            : _Is_neg{_Dur < _Duration::zero()},
              _Hours{_CHRONO duration_cast<_CHRONO hours>(_CHRONO abs(_Dur))},
              _Mins{_CHRONO duration_cast<_CHRONO minutes>(_CHRONO abs(_Dur) - hours())},
              _Secs{_CHRONO duration_cast<_CHRONO seconds>(_CHRONO abs(_Dur) - hours() - minutes())} {
            // clang-format on
            if constexpr (treat_as_floating_point_v<typename precision::rep>) {
                _Sub_secs = _CHRONO abs(_Dur) - hours() - minutes() - seconds();
            } else {
                _Sub_secs = _CHRONO duration_cast<precision>(_CHRONO abs(_Dur) - hours() - minutes() - seconds());
            }
        }

        _NODISCARD constexpr bool is_negative() const noexcept {
            return _Is_neg;
        }
        _NODISCARD constexpr hours hours() const noexcept {
            return _Hours;
        }
        _NODISCARD constexpr minutes minutes() const noexcept {
            return _Mins;
        }
        _NODISCARD constexpr seconds seconds() const noexcept {
            return _Secs;
        }
        _NODISCARD constexpr precision subseconds() const noexcept {
            return _Sub_secs;
        }

        _NODISCARD constexpr explicit operator precision() const noexcept {
            return to_duration();
        }
        _NODISCARD constexpr precision to_duration() const noexcept {
            const auto _Dur = _Hours + _Mins + _Secs + _Sub_secs;
            return _Is_neg ? -_Dur : _Dur;
        }

    private:
        bool _Is_neg;
        _CHRONO hours _Hours;
        _CHRONO minutes _Mins;
        _CHRONO seconds _Secs;
        precision _Sub_secs;
    };

    _NODISCARD constexpr bool is_am(const hours& _Hours) noexcept {
        return _Hours >= hours{0} && _Hours <= hours{11};
    }
    _NODISCARD constexpr bool is_pm(const hours& _Hours) noexcept {
        return _Hours >= hours{12} && _Hours <= hours{23};
    }

    _NODISCARD constexpr hours make12(const hours& _Hours) noexcept {
        const auto _H_count{_Hours.count()};
        auto _Ret{_H_count == 0 ? 12 : _H_count};
        if (_Ret > 12) {
            _Ret -= 12;
        }

        return hours{_Ret};
    }
    _NODISCARD constexpr hours make24(const hours& _Hours, bool _Is_pm) noexcept {
        const auto _H_count{_Hours.count()};
        auto _Ret{_H_count == 12 ? 0 : _H_count};
        if (_Is_pm) {
            _Ret += 12;
        }

        return hours{_Ret};
    }
#endif // _HAS_CXX20
} // namespace chrono

// HELPERS
template <class _Rep, class _Period>
_NODISCARD bool _To_xtime_10_day_clamped(_CSTD xtime& _Xt, const _CHRONO duration<_Rep, _Period>& _Rel_time) noexcept(
    is_arithmetic_v<_Rep>) {
    // Convert duration to xtime, maximum 10 days from now, returns whether clamping occurred.
    // If clamped, timeouts will be transformed into spurious non-timeout wakes, due to ABI restrictions where
    // the other side of the DLL boundary overflows int32_t milliseconds.
    // Every function calling this one is TRANSITION, ABI
    constexpr _CHRONO nanoseconds _Ten_days{_CHRONO hours{24} * 10};
    constexpr _CHRONO duration<double> _Ten_days_d{_Ten_days};
    _CHRONO nanoseconds _Tx0 = _CHRONO system_clock::now().time_since_epoch();
    const bool _Clamped      = _Ten_days_d < _Rel_time;
    if (_Clamped) {
        _Tx0 += _Ten_days;
    } else {
        _Tx0 += _CHRONO duration_cast<_CHRONO nanoseconds>(_Rel_time);
    }

    const auto _Whole_seconds = _CHRONO duration_cast<_CHRONO seconds>(_Tx0);
    _Xt.sec                   = _Whole_seconds.count();
    _Tx0 -= _Whole_seconds;
    _Xt.nsec = static_cast<long>(_Tx0.count());
    return _Clamped;
}

// duration LITERALS
inline namespace literals {
    inline namespace chrono_literals {
        _NODISCARD constexpr _CHRONO hours operator"" h(unsigned long long _Val) noexcept /* strengthened */ {
            return _CHRONO hours(_Val);
        }

        _NODISCARD constexpr _CHRONO duration<double, ratio<3600>> operator"" h(long double _Val) noexcept
        /* strengthened */ {
            return _CHRONO duration<double, ratio<3600>>(_Val);
        }

        _NODISCARD constexpr _CHRONO minutes(operator"" min)(unsigned long long _Val) noexcept /* strengthened */ {
            return _CHRONO minutes(_Val);
        }

        _NODISCARD constexpr _CHRONO duration<double, ratio<60>>(operator"" min)(long double _Val) noexcept
        /* strengthened */ {
            return _CHRONO duration<double, ratio<60>>(_Val);
        }

        _NODISCARD constexpr _CHRONO seconds operator"" s(unsigned long long _Val) noexcept /* strengthened */ {
            return _CHRONO seconds(_Val);
        }

        _NODISCARD constexpr _CHRONO duration<double> operator"" s(long double _Val) noexcept /* strengthened */ {
            return _CHRONO duration<double>(_Val);
        }

        _NODISCARD constexpr _CHRONO milliseconds operator"" ms(unsigned long long _Val) noexcept /* strengthened */ {
            return _CHRONO milliseconds(_Val);
        }

        _NODISCARD constexpr _CHRONO duration<double, milli> operator"" ms(long double _Val) noexcept
        /* strengthened */ {
            return _CHRONO duration<double, milli>(_Val);
        }

        _NODISCARD constexpr _CHRONO microseconds operator"" us(unsigned long long _Val) noexcept /* strengthened */ {
            return _CHRONO microseconds(_Val);
        }

        _NODISCARD constexpr _CHRONO duration<double, micro> operator"" us(long double _Val) noexcept
        /* strengthened */ {
            return _CHRONO duration<double, micro>(_Val);
        }

        _NODISCARD constexpr _CHRONO nanoseconds operator"" ns(unsigned long long _Val) noexcept /* strengthened */ {
            return _CHRONO nanoseconds(_Val);
        }

        _NODISCARD constexpr _CHRONO duration<double, nano> operator"" ns(long double _Val) noexcept
        /* strengthened */ {
            return _CHRONO duration<double, nano>(_Val);
        }
#if _HAS_CXX20
        _NODISCARD constexpr _CHRONO day operator"" d(unsigned long long _Day) noexcept {
            return _CHRONO day{static_cast<unsigned int>(_Day)};
        }
        _NODISCARD constexpr _CHRONO year operator"" y(unsigned long long _Year) noexcept {
            return _CHRONO year{static_cast<int>(_Year)};
        }
#endif // _HAS_CXX20
    } // namespace chrono_literals
} // namespace literals

namespace chrono {
    using namespace literals::chrono_literals;
} // namespace chrono

_STD_END
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _CHRONO_
