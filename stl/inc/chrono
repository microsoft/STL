// chrono standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _CHRONO_
#define _CHRONO_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR
#include <ctime>
#include <limits>
#include <ratio>
#include <sstream>
#include <utility>
#include <xtimec.h>

#if _HAS_CXX20
#include <algorithm>
#include <atomic>
#include <cmath>
#include <compare>
#include <forward_list>
#include <memory>
#include <vector>
#include <xthreads.h>
#include <xtzdb.h>
#endif // _HAS_CXX20

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
namespace chrono {
    // STRUCT TEMPLATE treat_as_floating_point
    template <class _Rep>
    struct treat_as_floating_point : is_floating_point<_Rep> {}; // tests for floating-point type

    template <class _Rep>
    _INLINE_VAR constexpr bool treat_as_floating_point_v = treat_as_floating_point<_Rep>::value;

    // STRUCT TEMPLATE duration_values
    template <class _Rep>
    struct duration_values { // gets arithmetic properties of a type
        _NODISCARD static constexpr _Rep zero() noexcept {
            // get zero value
            return _Rep(0);
        }

        _NODISCARD static constexpr _Rep(min)() noexcept {
            // get smallest value
            return numeric_limits<_Rep>::lowest();
        }

        _NODISCARD static constexpr _Rep(max)() noexcept {
            // get largest value
            return (numeric_limits<_Rep>::max)();
        }
    };

#if _HAS_CXX20
    template <class _Clock>
    concept _Is_clock = requires {
        typename _Clock::rep;
        typename _Clock::period;
        typename _Clock::duration;
        typename _Clock::time_point;
        _Clock::is_steady;
        _Clock::now();
    };

    template <class _Clock>
    struct is_clock : bool_constant<_Is_clock<_Clock>> {};
    template <class _Clock>
    inline constexpr bool is_clock_v = _Is_clock<_Clock>;
#endif // _HAS_CXX20

    // CLASS TEMPLATE duration
    template <class _Rep, class _Period = ratio<1>>
    class duration;

    // VARIABLE TEMPLATE _Is_duration_v
    template <class _Ty>
    _INLINE_VAR constexpr bool _Is_duration_v = _Is_specialization_v<_Ty, duration>;

    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> = 0>
    constexpr _To duration_cast(const duration<_Rep, _Period>&) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>); // strengthened

    template <class _Rep, class _Period>
    class duration { // represents a time duration
    public:
        using rep    = _Rep;
        using period = typename _Period::type;

        static_assert(!_Is_duration_v<_Rep>, "duration can't have duration as first template argument");
        static_assert(_Is_ratio_v<_Period>, "period not an instance of std::ratio");
        static_assert(0 < _Period::num, "period negative or zero");

        constexpr duration() = default;

        template <class _Rep2,
            enable_if_t<is_convertible_v<const _Rep2&,
                            _Rep> && (treat_as_floating_point_v<_Rep> || !treat_as_floating_point_v<_Rep2>),
                int> = 0>
        constexpr explicit duration(const _Rep2& _Val) noexcept(
            is_arithmetic_v<_Rep>&& is_arithmetic_v<_Rep2>) // strengthened
            : _MyRep(static_cast<_Rep>(_Val)) {}

        template <class _Rep2, class _Period2,
            enable_if_t<
                treat_as_floating_point_v<
                    _Rep> || (_Ratio_divide_sfinae<_Period2, _Period>::den == 1 && !treat_as_floating_point_v<_Rep2>),
                int> = 0>
        constexpr duration(const duration<_Rep2, _Period2>& _Dur) noexcept(
            is_arithmetic_v<_Rep>&& is_arithmetic_v<_Rep2>) // strengthened
            : _MyRep(_CHRONO duration_cast<duration>(_Dur).count()) {}

        _NODISCARD constexpr _Rep count() const noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            return _MyRep;
        }

        _NODISCARD constexpr common_type_t<duration> operator+() const
            noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            return common_type_t<duration>(*this);
        }

        _NODISCARD constexpr common_type_t<duration> operator-() const
            noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            return common_type_t<duration>(-_MyRep);
        }

        _CONSTEXPR17 duration& operator++() noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            ++_MyRep;
            return *this;
        }

        _CONSTEXPR17 duration operator++(int) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            return duration(_MyRep++);
        }

        _CONSTEXPR17 duration& operator--() noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            --_MyRep;
            return *this;
        }

        _CONSTEXPR17 duration operator--(int) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            return duration(_MyRep--);
        }

        _CONSTEXPR17 duration& operator+=(const duration& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            _MyRep += _Right._MyRep;
            return *this;
        }

        _CONSTEXPR17 duration& operator-=(const duration& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            _MyRep -= _Right._MyRep;
            return *this;
        }

        _CONSTEXPR17 duration& operator*=(const _Rep& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            _MyRep *= _Right;
            return *this;
        }

        _CONSTEXPR17 duration& operator/=(const _Rep& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            _MyRep /= _Right;
            return *this;
        }

        _CONSTEXPR17 duration& operator%=(const _Rep& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            _MyRep %= _Right;
            return *this;
        }

        _CONSTEXPR17 duration& operator%=(const duration& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            _MyRep %= _Right.count();
            return *this;
        }

        _NODISCARD static constexpr duration zero() noexcept {
            // get zero value
            return duration(duration_values<_Rep>::zero());
        }

        _NODISCARD static constexpr duration(min)() noexcept {
            // get minimum value
            return duration((duration_values<_Rep>::min)());
        }

        _NODISCARD static constexpr duration(max)() noexcept {
            // get maximum value
            return duration((duration_values<_Rep>::max)());
        }

    private:
        _Rep _MyRep; // the stored rep
    };

    template <class _Clock, class _Duration = typename _Clock::duration>
    class time_point { // represents a point in time
    public:
        using clock    = _Clock;
        using duration = _Duration;
        using rep      = typename _Duration::rep;
        using period   = typename _Duration::period;

        static_assert(_Is_duration_v<_Duration>, "duration must be an instance of std::duration");

        constexpr time_point() = default;

        constexpr explicit time_point(const _Duration& _Other) noexcept(is_arithmetic_v<rep>) // strengthened
            : _MyDur(_Other) {}

        template <class _Duration2, enable_if_t<is_convertible_v<_Duration2, _Duration>, int> = 0>
        constexpr time_point(const time_point<_Clock, _Duration2>& _Tp) noexcept(
            is_arithmetic_v<rep>&& is_arithmetic_v<typename _Duration2::rep>) // strengthened
            : _MyDur(_Tp.time_since_epoch()) {}

        _NODISCARD constexpr _Duration time_since_epoch() const noexcept(is_arithmetic_v<rep>) /* strengthened */ {
            return _MyDur;
        }

#if _HAS_CXX20
        constexpr time_point& operator++() noexcept(is_arithmetic_v<rep>) /* strengthened */ {
            ++_MyDur;
            return *this;
        }
        constexpr time_point operator++(int) noexcept(is_arithmetic_v<rep>) /* strengthened */ {
            return time_point{_MyDur++};
        }
        constexpr time_point& operator--() noexcept(is_arithmetic_v<rep>) /* strengthened */ {
            --_MyDur;
            return *this;
        }
        constexpr time_point operator--(int) noexcept(is_arithmetic_v<rep>) /* strengthened */ {
            return time_point{_MyDur--};
        }
#endif // _HAS_CXX20

        _CONSTEXPR17 time_point& operator+=(const _Duration& _Dur) noexcept(is_arithmetic_v<rep>) /* strengthened */ {
            _MyDur += _Dur;
            return *this;
        }

        _CONSTEXPR17 time_point& operator-=(const _Duration& _Dur) noexcept(is_arithmetic_v<rep>) /* strengthened */ {
            _MyDur -= _Dur;
            return *this;
        }

        _NODISCARD static constexpr time_point(min)() noexcept {
            return time_point((_Duration::min)());
        }

        _NODISCARD static constexpr time_point(max)() noexcept {
            return time_point((_Duration::max)());
        }

    private:
        _Duration _MyDur{duration::zero()}; // duration since the epoch
    };
} // namespace chrono

// STRUCT TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
template <intmax_t _Ax, intmax_t _Bx>
struct _Lcm : integral_constant<intmax_t, (_Ax / _Gcd<_Ax, _Bx>::value) * _Bx> {}; // compute LCM of _Ax and _Bx

// STRUCT TEMPLATE common_type SPECIALIZATIONS
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct common_type<_CHRONO duration<_Rep1, _Period1>,
    _CHRONO duration<_Rep2, _Period2>> { // common type of two durations
    using type = _CHRONO duration<common_type_t<_Rep1, _Rep2>,
        ratio<_Gcd<_Period1::num, _Period2::num>::value, _Lcm<_Period1::den, _Period2::den>::value>>;
};

template <class _Clock, class _Duration1, class _Duration2>
struct common_type<_CHRONO time_point<_Clock, _Duration1>,
    _CHRONO time_point<_Clock, _Duration2>> { // common type of two time points
    using type = _CHRONO time_point<_Clock, common_type_t<_Duration1, _Duration2>>;
};

namespace chrono {
    // duration ARITHMETIC
    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>
        operator+(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_CD(_Left).count() + _CD(_Right).count());
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>
        operator-(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_CD(_Left).count() - _CD(_Right).count());
    }

    template <class _Rep1, class _Period1, class _Rep2,
        enable_if_t<is_convertible_v<const _Rep2&, common_type_t<_Rep1, _Rep2>>, int> = 0>
    _NODISCARD constexpr duration<common_type_t<_Rep1, _Rep2>, _Period1> operator*(
        const duration<_Rep1, _Period1>& _Left,
        const _Rep2& _Right) noexcept(is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CR = common_type_t<_Rep1, _Rep2>;
        using _CD = duration<_CR, _Period1>;
        return _CD(_CD(_Left).count() * _Right);
    }

    template <class _Rep1, class _Rep2, class _Period2,
        enable_if_t<is_convertible_v<const _Rep1&, common_type_t<_Rep1, _Rep2>>, int> = 0>
    _NODISCARD constexpr duration<common_type_t<_Rep1, _Rep2>, _Period2>
        operator*(const _Rep1& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        return _Right * _Left;
    }

    template <class _CR, class _Period1, class _Rep2, bool = is_convertible_v<const _Rep2&, _CR>>
    struct _Duration_div_mod1 { // return type for duration / rep and duration % rep
        using type = duration<_CR, _Period1>;
    };

    template <class _CR, class _Period1, class _Rep2>
    struct _Duration_div_mod1<_CR, _Period1, _Rep2, false> {}; // no return type

    template <class _CR, class _Period1, class _Rep2, bool = _Is_duration_v<_Rep2>>
    struct _Duration_div_mod {}; // no return type

    template <class _CR, class _Period1, class _Rep2>
    struct _Duration_div_mod<_CR, _Period1, _Rep2, false> : _Duration_div_mod1<_CR, _Period1, _Rep2> {
        // return type for duration / rep and duration % rep
    };

    template <class _Rep1, class _Period1, class _Rep2>
    _NODISCARD constexpr typename _Duration_div_mod<common_type_t<_Rep1, _Rep2>, _Period1, _Rep2>::type operator/(
        const duration<_Rep1, _Period1>& _Left,
        const _Rep2& _Right) noexcept(is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CR = common_type_t<_Rep1, _Rep2>;
        using _CD = duration<_CR, _Period1>;
        return _CD(_CD(_Left).count() / _Right);
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr common_type_t<_Rep1, _Rep2>
        operator/(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_Left).count() / _CD(_Right).count();
    }

    template <class _Rep1, class _Period1, class _Rep2>
    _NODISCARD constexpr typename _Duration_div_mod<common_type_t<_Rep1, _Rep2>, _Period1, _Rep2>::type operator%(
        const duration<_Rep1, _Period1>& _Left,
        const _Rep2& _Right) noexcept(is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CR = common_type_t<_Rep1, _Rep2>;
        using _CD = duration<_CR, _Period1>;
        return _CD(_CD(_Left).count() % _Right);
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>
        operator%(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_CD(_Left).count() % _CD(_Right).count());
    }

    // duration COMPARISONS
    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr bool
        operator==(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CT(_Left).count() == _CT(_Right).count();
    }

#if !_HAS_CXX20
    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr bool
        operator!=(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        return !(_Left == _Right);
    }
#endif // !_HAS_CXX20

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr bool
        operator<(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CT(_Left).count() < _CT(_Right).count();
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr bool
        operator<=(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        return !(_Right < _Left);
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr bool
        operator>(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        return _Right < _Left;
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr bool
        operator>=(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        return !(_Left < _Right);
    }

#ifdef __cpp_lib_concepts
    // clang-format off
    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
        requires three_way_comparable<typename common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>::rep>
    _NODISCARD constexpr auto
        operator<=>(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        // clang-format on
        using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CT(_Left).count() <=> _CT(_Right).count();
    }
#endif // defined(__cpp_lib_concepts)

    // FUNCTION TEMPLATE duration_cast
    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> _Enabled>
    _NODISCARD constexpr _To duration_cast(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // convert duration to another duration; truncate
        using _CF = ratio_divide<_Period, typename _To::period>;

        using _ToRep = typename _To::rep;
        using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;

        constexpr bool _Num_is_one = _CF::num == 1;
        constexpr bool _Den_is_one = _CF::den == 1;

        if (_Den_is_one) {
            if (_Num_is_one) {
                return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));
            } else {
                return static_cast<_To>(
                    static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
            }
        } else {
            if (_Num_is_one) {
                return static_cast<_To>(
                    static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
            } else {
                return static_cast<_To>(static_cast<_ToRep>(
                    static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
            }
        }
    }

    // FUNCTION TEMPLATE floor
    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> = 0>
    _NODISCARD constexpr _To floor(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // convert duration to another duration; round towards negative infinity
        // i.e. the greatest integral result such that the result <= _Dur
        const _To _Casted{_CHRONO duration_cast<_To>(_Dur)};
        if (_Casted > _Dur) {
            return _To{_Casted.count() - static_cast<typename _To::rep>(1)};
        }

        return _Casted;
    }

    // FUNCTION TEMPLATE ceil
    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> = 0>
    _NODISCARD constexpr _To ceil(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // convert duration to another duration; round towards positive infinity
        // i.e. the least integral result such that _Dur <= the result
        const _To _Casted{_CHRONO duration_cast<_To>(_Dur)};
        if (_Casted < _Dur) {
            return _To{_Casted.count() + static_cast<typename _To::rep>(1)};
        }

        return _Casted;
    }

    // FUNCTION TEMPLATE round
    template <class _Rep>
    constexpr bool _Is_even(_Rep _Val) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
        // Tests whether _Val is even
        return _Val % 2 == 0;
    }

    template <class _To, class _Rep, class _Period,
        enable_if_t<_Is_duration_v<_To> && !treat_as_floating_point_v<typename _To::rep>, int> = 0>
    _NODISCARD constexpr _To round(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // convert duration to another duration, round to nearest, ties to even
        const _To _Floored{_CHRONO floor<_To>(_Dur)};
        const _To _Ceiled{_Floored + _To{1}};
        const auto _Floor_adjustment = _Dur - _Floored;
        const auto _Ceil_adjustment  = _Ceiled - _Dur;
        if (_Floor_adjustment < _Ceil_adjustment
            || (_Floor_adjustment == _Ceil_adjustment && _Is_even(_Floored.count()))) {
            return _Floored;
        }

        return _Ceiled;
    }

    // FUNCTION TEMPLATE abs
    template <class _Rep, class _Period, enable_if_t<numeric_limits<_Rep>::is_signed, int> = 0>
    _NODISCARD constexpr duration<_Rep, _Period> abs(const duration<_Rep, _Period> _Dur) noexcept(
        is_arithmetic_v<_Rep>) /* strengthened */ {
        // create a duration with count() the absolute value of _Dur.count()
        return _Dur < duration<_Rep, _Period>::zero() ? duration<_Rep, _Period>::zero() - _Dur : _Dur;
    }

    // duration TYPES
    using nanoseconds  = duration<long long, nano>;
    using microseconds = duration<long long, micro>;
    using milliseconds = duration<long long, milli>;
    using seconds      = duration<long long>;
    using minutes      = duration<int, ratio<60>>;
    using hours        = duration<int, ratio<3600>>;
#if _HAS_CXX20
    using days   = duration<int, ratio_multiply<ratio<24>, hours::period>>;
    using weeks  = duration<int, ratio_multiply<ratio<7>, days::period>>;
    using years  = duration<int, ratio_multiply<ratio<146097, 400>, days::period>>;
    using months = duration<int, ratio_divide<years::period, ratio<12>>>;
#endif // _HAS_CXX20

    // time_point ARITHMETIC
    template <class _Clock, class _Duration, class _Rep, class _Period>
    _NODISCARD constexpr time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>
        operator+(const time_point<_Clock, _Duration>& _Left, const duration<_Rep, _Period>& _Right) noexcept(
            is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<_Rep>) /* strengthened */ {
        using _RT = time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>;
        return _RT(_Left.time_since_epoch() + _Right);
    }

    template <class _Rep, class _Period, class _Clock, class _Duration>
    _NODISCARD constexpr time_point<_Clock, common_type_t<duration<_Rep, _Period>, _Duration>>
        operator+(const duration<_Rep, _Period>& _Left, const time_point<_Clock, _Duration>& _Right) noexcept(
            is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _Duration::rep>) /* strengthened */ {
        return _Right + _Left;
    }

    template <class _Clock, class _Duration, class _Rep, class _Period>
    _NODISCARD constexpr time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>
        operator-(const time_point<_Clock, _Duration>& _Left, const duration<_Rep, _Period>& _Right) noexcept(
            is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<_Rep>) /* strengthened */ {
        using _RT = time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>;
        return _RT(_Left.time_since_epoch() - _Right);
    }

    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr common_type_t<_Duration1, _Duration2>
        operator-(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return _Left.time_since_epoch() - _Right.time_since_epoch();
    }

    // time_point COMPARISONS
    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr bool
        operator==(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return _Left.time_since_epoch() == _Right.time_since_epoch();
    }

#if !_HAS_CXX20
    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr bool
        operator!=(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return !(_Left == _Right);
    }
#endif // !_HAS_CXX20

    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr bool
        operator<(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return _Left.time_since_epoch() < _Right.time_since_epoch();
    }

    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr bool
        operator<=(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return !(_Right < _Left);
    }

    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr bool
        operator>(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return _Right < _Left;
    }

    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr bool
        operator>=(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return !(_Left < _Right);
    }

#ifdef __cpp_lib_concepts
    template <class _Clock, class _Duration1, three_way_comparable_with<_Duration1> _Duration2>
    _NODISCARD constexpr auto
        operator<=>(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return _Left.time_since_epoch() <=> _Right.time_since_epoch();
    }
#endif // defined(__cpp_lib_concepts)

    // FUNCTION TEMPLATE time_point_cast
    template <class _To, class _Clock, class _Duration, enable_if_t<_Is_duration_v<_To>, int> = 0>
    _NODISCARD constexpr time_point<_Clock, _To> time_point_cast(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // change the duration type of a time_point; truncate
        return time_point<_Clock, _To>(_CHRONO duration_cast<_To>(_Time.time_since_epoch()));
    }

    // FUNCTION TEMPLATE floor (for time_point instances)
    template <class _To, class _Clock, class _Duration, enable_if_t<_Is_duration_v<_To>, int> = 0>
    _NODISCARD constexpr time_point<_Clock, _To> floor(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // change the duration type of a time_point; round towards negative infinity
        return time_point<_Clock, _To>(_CHRONO floor<_To>(_Time.time_since_epoch()));
    }

    // FUNCTION TEMPLATE ceil (for time_point instances)
    template <class _To, class _Clock, class _Duration, enable_if_t<_Is_duration_v<_To>, int> = 0>
    _NODISCARD constexpr time_point<_Clock, _To> ceil(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // change the duration type of a time_point; round towards positive infinity
        return time_point<_Clock, _To>(_CHRONO ceil<_To>(_Time.time_since_epoch()));
    }

    // FUNCTION TEMPLATE round (for time_point instances)
    template <class _To, class _Clock, class _Duration,
        enable_if_t<_Is_duration_v<_To> && !treat_as_floating_point_v<typename _To::rep>, int> = 0>
    _NODISCARD constexpr time_point<_Clock, _To> round(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // change the duration type of a time_point; round to nearest, ties to even
        return time_point<_Clock, _To>(_CHRONO round<_To>(_Time.time_since_epoch()));
    }

    // CLOCKS
    struct system_clock { // wraps GetSystemTimePreciseAsFileTime/GetSystemTimeAsFileTime
        using rep                       = long long;
        using period                    = ratio<1, 10'000'000>; // 100 nanoseconds
        using duration                  = _CHRONO duration<rep, period>;
        using time_point                = _CHRONO time_point<system_clock>;
        static constexpr bool is_steady = false;

        _NODISCARD static time_point now() noexcept { // get current time
            return time_point(duration(_Xtime_get_ticks()));
        }

        _NODISCARD static __time64_t to_time_t(const time_point& _Time) noexcept { // convert to __time64_t
            return duration_cast<seconds>(_Time.time_since_epoch()).count();
        }

        _NODISCARD static time_point from_time_t(__time64_t _Tm) noexcept { // convert from __time64_t
            return time_point{seconds{_Tm}};
        }
    };

#if _HAS_CXX20
    // sys_time ALIASES
    template <class _Duration>
    using sys_time    = time_point<system_clock, _Duration>;
    using sys_seconds = sys_time<seconds>;
    using sys_days    = sys_time<days>;
#endif // _HAS_CXX20

    struct steady_clock { // wraps QueryPerformanceCounter
        using rep                       = long long;
        using period                    = nano;
        using duration                  = nanoseconds;
        using time_point                = _CHRONO time_point<steady_clock>;
        static constexpr bool is_steady = true;

        _NODISCARD static time_point now() noexcept { // get current time
            const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot
            const long long _Ctr  = _Query_perf_counter();
            static_assert(period::num == 1, "This assumes period::num == 1.");
            // Instead of just having "(_Ctr * period::den) / _Freq",
            // the algorithm below prevents overflow when _Ctr is sufficiently large.
            // It assumes that _Freq * period::den does not overflow, which is currently true for nano period.
            // It is not realistic for _Ctr to accumulate to large values from zero with this assumption,
            // but the initial value of _Ctr could be large.
            const long long _Whole = (_Ctr / _Freq) * period::den;
            const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;
            return time_point(duration(_Whole + _Part));
        }
    };

    using high_resolution_clock = steady_clock;

#if _HAS_CXX20
    // [time.duration.io]

#define _IF_PERIOD_RETURN_SUFFIX_ELSE(_TYPE, _SUFFIX) \
    if constexpr (is_same_v<_Period, _TYPE>) {        \
        if constexpr (is_same_v<_CharT, char>) {      \
            return _SUFFIX;                           \
        } else {                                      \
            return L##_SUFFIX;                        \
        }                                             \
    } else

    template <class _CharT, class _Period>
    _NODISCARD constexpr const _CharT* _Get_literal_unit_suffix() {
        _IF_PERIOD_RETURN_SUFFIX_ELSE(atto, "as")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(femto, "fs")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(pico, "ps")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(nano, "ns")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(micro, "us")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(milli, "ms")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(centi, "cs")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(deci, "ds")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(seconds::period, "s")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(deca, "das")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(hecto, "hs")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(kilo, "ks")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(mega, "Ms")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(giga, "Gs")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(tera, "Ts")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(peta, "Ps")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(exa, "Es")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(minutes::period, "min")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(hours::period, "h")
        _IF_PERIOD_RETURN_SUFFIX_ELSE(ratio<86400>, "d")

        {
            return nullptr;
        }
    }

#undef _IF_PERIOD_RETURN_SUFFIX_ELSE

    template <class _CharT>
    _NODISCARD _CharT* _Get_general_unit_suffix(_CharT* _Rnext, const intmax_t _Num, const intmax_t _Den) {
        // Returns the head pointer of the string, built in reverse.
        _STL_INTERNAL_CHECK(_Num > 0 && _Den > 0);
        *--_Rnext = '\0';
        *--_Rnext = 's';
        *--_Rnext = ']';
        if (_Den != 1) {
            _Rnext    = _UIntegral_to_buff(_Rnext, static_cast<uintmax_t>(_Den));
            *--_Rnext = '/';
        }

        _Rnext    = _UIntegral_to_buff(_Rnext, static_cast<uintmax_t>(_Num));
        *--_Rnext = '[';
        return _Rnext;
    }

    template <class _CharT, class _Traits, class _Rep, class _Period>
    basic_ostream<_CharT, _Traits>& operator<<(
        basic_ostream<_CharT, _Traits>& _Os, const duration<_Rep, _Period>& _Dur) {
        basic_ostringstream<_CharT, _Traits> _Sstr;
        _Sstr.flags(_Os.flags());
        _Sstr.imbue(_Os.getloc());
        _Sstr.precision(_Os.precision());
        _Sstr << _Dur.count();

        constexpr auto _Suffix = _Get_literal_unit_suffix<_CharT, _Period>();
        if constexpr (_Suffix == nullptr) {
            _CharT _Buffer[2 * (numeric_limits<intmax_t>::digits10 + 1) + 5] = {}; // 2 numbers + "[/]s\0"
            const _CharT* const _Begin =
                _Get_general_unit_suffix<_CharT>(_STD end(_Buffer), _Period::num, _Period::den);
            _Sstr << _Begin;
        } else {
            _Sstr << _Suffix;
        }

        return _Os << _Sstr.str();
    }

    struct local_t {};

    template <class _Duration>
    using local_time    = time_point<local_t, _Duration>;
    using local_seconds = local_time<seconds>;
    using local_days    = local_time<days>;

    struct last_spec {
        explicit last_spec() = default;
    };
    inline constexpr last_spec last{};

    class day {
    public:
        day() = default;
        constexpr explicit day(unsigned int _Val) noexcept : _Day{static_cast<unsigned char>(_Val)} {}

        constexpr day& operator++() noexcept {
            ++_Day;
            return *this;
        }
        constexpr day operator++(int) noexcept {
            return day{_Day++};
        }
        constexpr day& operator--() noexcept {
            --_Day;
            return *this;
        }
        constexpr day operator--(int) noexcept {
            return day{_Day--};
        }

        constexpr day& operator+=(const days& _Days) noexcept {
            _Day += static_cast<unsigned char>(_Days.count());
            return *this;
        }
        constexpr day& operator-=(const days& _Days) noexcept {
            _Day -= static_cast<unsigned char>(_Days.count());
            return *this;
        }

        _NODISCARD constexpr explicit operator unsigned int() const noexcept {
            return _Day;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Day >= 1 && _Day <= 31;
        }

    private:
        unsigned char _Day;
    };

    _NODISCARD constexpr bool operator==(const day& _Left, const day& _Right) noexcept {
        return static_cast<unsigned int>(_Left) == static_cast<unsigned int>(_Right);
    }
    _NODISCARD constexpr strong_ordering operator<=>(const day& _Left, const day& _Right) noexcept {
        return static_cast<unsigned int>(_Left) <=> static_cast<unsigned int>(_Right);
    }

    _NODISCARD constexpr day operator+(const day& _Left, const days& _Right) noexcept {
        return day{static_cast<unsigned int>(_Left) + _Right.count()};
    }
    _NODISCARD constexpr day operator+(const days& _Left, const day& _Right) noexcept {
        return _Right + _Left;
    }
    _NODISCARD constexpr day operator-(const day& _Left, const days& _Right) noexcept {
        return day{static_cast<unsigned int>(_Left) - _Right.count()};
    }
    _NODISCARD constexpr days operator-(const day& _Left, const day& _Right) noexcept {
        return days{
            static_cast<int>(static_cast<unsigned int>(_Left)) - static_cast<int>(static_cast<unsigned int>(_Right))};
    }

    class month {
    public:
        month() = default;
        constexpr explicit month(unsigned int _Val) noexcept : _Month{static_cast<unsigned char>(_Val)} {}

        constexpr month& operator++() noexcept {
            *this += months{1};
            return *this;
        }
        constexpr month operator++(int) noexcept {
            month _Temp{*this};
            ++*this;
            return _Temp;
        }
        constexpr month& operator--() noexcept {
            *this -= months{1};
            return *this;
        }
        constexpr month operator--(int) noexcept {
            month _Temp{*this};
            --*this;
            return _Temp;
        }

        constexpr month& operator+=(const months& _Months) noexcept;
        constexpr month& operator-=(const months& _Months) noexcept;

        _NODISCARD constexpr explicit operator unsigned int() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Month >= 1 && _Month <= 12;
        }

    private:
        unsigned char _Month;
    };

    _NODISCARD constexpr bool operator==(const month& _Left, const month& _Right) noexcept {
        return static_cast<unsigned int>(_Left) == static_cast<unsigned int>(_Right);
    }
    _NODISCARD constexpr strong_ordering operator<=>(const month& _Left, const month& _Right) noexcept {
        return static_cast<unsigned int>(_Left) <=> static_cast<unsigned int>(_Right);
    }

    _NODISCARD constexpr month operator+(const month& _Left, const months& _Right) noexcept {
        const auto _Mo  = static_cast<long long>(static_cast<unsigned int>(_Left)) + (_Right.count() - 1);
        const auto _Div = (_Mo >= 0 ? _Mo : _Mo - 11) / 12;
        return month{static_cast<unsigned int>(_Mo - _Div * 12 + 1)};
    }
    _NODISCARD constexpr month operator+(const months& _Left, const month& _Right) noexcept {
        return _Right + _Left;
    }
    _NODISCARD constexpr month operator-(const month& _Left, const months& _Right) noexcept {
        return _Left + -_Right;
    }
    _NODISCARD constexpr months operator-(const month& _Left, const month& _Right) noexcept {
        const auto _Mo = static_cast<unsigned int>(_Left) - static_cast<unsigned int>(_Right);
        return months{_Mo <= 11 ? _Mo : _Mo + 12};
    }

    constexpr month& month::operator+=(const months& _Months) noexcept {
        *this = *this + _Months;
        return *this;
    }
    constexpr month& month::operator-=(const months& _Months) noexcept {
        *this = *this - _Months;
        return *this;
    }

    class year {
    public:
        year() = default;
        constexpr explicit year(int _Val) noexcept : _Year{static_cast<short>(_Val)} {}

        constexpr year& operator++() noexcept {
            ++_Year;
            return *this;
        }
        constexpr year operator++(int) noexcept {
            return year{_Year++};
        }
        constexpr year& operator--() noexcept {
            --_Year;
            return *this;
        }
        constexpr year operator--(int) noexcept {
            return year{_Year--};
        }

        constexpr year& operator+=(const years& _Years) noexcept {
#ifdef __EDG__ // TRANSITION, VSO-1271098
            _Year = static_cast<short>(_Year + _Years.count());
#else // ^^^ workaround / no workaround vvv
            _Year += static_cast<short>(_Years.count());
#endif // ^^^ no workaround ^^^
            return *this;
        }
        constexpr year& operator-=(const years& _Years) noexcept {
#ifdef __EDG__ // TRANSITION, VSO-1271098
            _Year = static_cast<short>(_Year - _Years.count());
#else // ^^^ workaround / no workaround vvv
            _Year -= static_cast<short>(_Years.count());
#endif // ^^^ no workaround ^^^
            return *this;
        }

        _NODISCARD constexpr year operator+() const noexcept {
            return *this;
        }
        _NODISCARD constexpr year operator-() const noexcept {
            return year{-_Year};
        }

        _NODISCARD constexpr bool is_leap() const noexcept {
            return _Year % 4 == 0 && (_Year % 100 != 0 || _Year % 400 == 0);
        }

        _NODISCARD constexpr explicit operator int() const noexcept {
            return _Year;
        }

        _NODISCARD constexpr bool ok() const noexcept {
            return _Year_min <= _Year && _Year <= _Year_max;
        }

        _NODISCARD static constexpr year(min)() noexcept {
            return year{_Year_min};
        }
        _NODISCARD static constexpr year(max)() noexcept {
            return year{_Year_max};
        }

    private:
        short _Year;
        static constexpr int _Year_min = -32767;
        static constexpr int _Year_max = 32767;
    };

    _NODISCARD constexpr bool operator==(const year& _Left, const year& _Right) noexcept {
        return static_cast<int>(_Left) == static_cast<int>(_Right);
    }
    _NODISCARD constexpr strong_ordering operator<=>(const year& _Left, const year& _Right) noexcept {
        return static_cast<int>(_Left) <=> static_cast<int>(_Right);
    }

    _NODISCARD constexpr year operator+(const year& _Left, const years& _Right) noexcept {
        return year{static_cast<int>(_Left) + _Right.count()};
    }
    _NODISCARD constexpr year operator+(const years& _Left, const year& _Right) noexcept {
        return _Right + _Left;
    }
    _NODISCARD constexpr year operator-(const year& _Left, const years& _Right) noexcept {
        return _Left + -_Right;
    }
    _NODISCARD constexpr years operator-(const year& _Left, const year& _Right) noexcept {
        return years{static_cast<int>(_Left) - static_cast<int>(_Right)};
    }

    class weekday_indexed;
    class weekday_last;

    class weekday {
    public:
        weekday() = default;
        constexpr explicit weekday(unsigned int _Val) noexcept
            : _Weekday{static_cast<unsigned char>(_Val == 7 ? 0 : _Val)} {}
        constexpr weekday(const sys_days& _Sys_day) noexcept
            : _Weekday{static_cast<unsigned char>(_Weekday_from_days(_Sys_day.time_since_epoch().count()))} {}
        constexpr explicit weekday(const local_days& _Local_day) noexcept
            : _Weekday{static_cast<unsigned char>(_Weekday_from_days(_Local_day.time_since_epoch().count()))} {}

        constexpr weekday& operator++() noexcept {
            return *this += days{1};
        }
        constexpr weekday operator++(int) noexcept {
            weekday _Temp{*this};
            ++*this;
            return _Temp;
        }
        constexpr weekday& operator--() noexcept {
            return *this -= days{1};
        }
        constexpr weekday operator--(int) noexcept {
            weekday _Temp{*this};
            --*this;
            return _Temp;
        }

        constexpr weekday& operator+=(const days& _Days) noexcept;
        constexpr weekday& operator-=(const days& _Days) noexcept;

        _NODISCARD constexpr unsigned int c_encoding() const noexcept {
            return _Weekday;
        }
        _NODISCARD constexpr unsigned int iso_encoding() const noexcept {
            return _Weekday == 0u ? 7u : _Weekday;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Weekday <= 6;
        }

        _NODISCARD constexpr weekday_indexed operator[](unsigned int _Index) const noexcept;
        _NODISCARD constexpr weekday_last operator[](last_spec) const noexcept;

    private:
        unsigned char _Weekday;

        // courtesy of Howard Hinnant
        // https://howardhinnant.github.io/date_algorithms.html#weekday_from_days
        _NODISCARD static constexpr unsigned int _Weekday_from_days(int _Tp) noexcept {
            return static_cast<unsigned int>(_Tp >= -4 ? (_Tp + 4) % 7 : (_Tp + 5) % 7 + 6);
        }
    };

    _NODISCARD constexpr bool operator==(const weekday& _Left, const weekday& _Right) noexcept {
        return _Left.c_encoding() == _Right.c_encoding();
    }

    _NODISCARD constexpr weekday operator+(const weekday& _Left, const days& _Right) noexcept {
        const auto _Wd  = static_cast<long long>(_Left.c_encoding()) + _Right.count();
        const auto _Div = (_Wd >= 0 ? _Wd : _Wd - 6) / 7;
        return weekday{static_cast<unsigned int>(_Wd - _Div * 7)};
    }
    _NODISCARD constexpr weekday operator+(const days& _Left, const weekday& _Right) noexcept {
        return _Right + _Left;
    }
    _NODISCARD constexpr weekday operator-(const weekday& _Left, const days& _Right) noexcept {
        return _Left + -_Right;
    }
    _NODISCARD constexpr days operator-(const weekday& _Left, const weekday& _Right) noexcept {
        const auto _Wd = _Left.c_encoding() - _Right.c_encoding();
        const auto _Wk = _Wd <= 6 ? _Wd : _Wd + 7;
        return days{_Wk};
    }

    constexpr weekday& weekday::operator+=(const days& _Days) noexcept {
        *this = *this + _Days;
        return *this;
    }
    constexpr weekday& weekday::operator-=(const days& _Days) noexcept {
        *this = *this - _Days;
        return *this;
    }

    class weekday_indexed {
    public:
        weekday_indexed() = default;
        constexpr weekday_indexed(const weekday& _Wd, unsigned int _Idx) noexcept
            : _Weekday{_Wd}, _Index{static_cast<unsigned char>(_Idx)} {}

        _NODISCARD constexpr weekday weekday() const noexcept {
            return _Weekday;
        }
        _NODISCARD constexpr unsigned int index() const noexcept {
            return _Index;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Weekday.ok() && _Index >= 1 && _Index <= 5;
        }

    private:
        _CHRONO weekday _Weekday;
        unsigned char _Index;
    };

    _NODISCARD constexpr bool operator==(const weekday_indexed& _Left, const weekday_indexed& _Right) noexcept {
        return _Left.weekday() == _Right.weekday() && _Left.index() == _Right.index();
    }

    class weekday_last {
    public:
        constexpr explicit weekday_last(const weekday& _Wd) noexcept : _Weekday{_Wd} {}

        _NODISCARD constexpr weekday weekday() const noexcept {
            return _Weekday;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Weekday.ok();
        }

    private:
        _CHRONO weekday _Weekday;
    };

    _NODISCARD constexpr bool operator==(const weekday_last& _Left, const weekday_last& _Right) noexcept {
        return _Left.weekday() == _Right.weekday();
    }

    _NODISCARD constexpr weekday_indexed weekday::operator[](unsigned int _Index) const noexcept {
        return {*this, _Index};
    }
    _NODISCARD constexpr weekday_last weekday::operator[](last_spec) const noexcept {
        return weekday_last{*this};
    }

    class month_day {
    public:
        month_day() = default;
        constexpr month_day(const month& _Month_, const day& _Day_) noexcept : _Month{_Month_}, _Day{_Day_} {}

        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr day day() const noexcept {
            return _Day;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            if (!_Month.ok() || !_Day.ok()) {
                return false;
            }

            const auto _Da = static_cast<unsigned int>(_Day);
            const auto _Mo = static_cast<unsigned int>(_Month);
            if (_Mo == 2) {
                return _Da <= 29;
            }

            if (_Mo == 4 || _Mo == 6 || _Mo == 9 || _Mo == 11) {
                return _Da <= 30;
            }
            return true;
        }

    private:
        _CHRONO month _Month;
        _CHRONO day _Day;
    };

    _NODISCARD constexpr bool operator==(const month_day& _Left, const month_day& _Right) noexcept {
        return _Left.month() == _Right.month() && _Left.day() == _Right.day();
    }
    _NODISCARD constexpr strong_ordering operator<=>(const month_day& _Left, const month_day& _Right) noexcept {
        const auto _Comp = _Left.month() <=> _Right.month();
        if (_Comp != 0) {
            return _Comp;
        }

        return _Left.day() <=> _Right.day();
    }

    class month_day_last {
    public:
        constexpr explicit month_day_last(const month& _Month_) noexcept : _Month{_Month_} {}

        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Month.ok();
        }

    private:
        _CHRONO month _Month;
    };

    _NODISCARD constexpr bool operator==(const month_day_last& _Left, const month_day_last& _Right) noexcept {
        return _Left.month() == _Right.month();
    }
    _NODISCARD constexpr strong_ordering operator<=>(
        const month_day_last& _Left, const month_day_last& _Right) noexcept {
        return _Left.month() <=> _Right.month();
    }

    class month_weekday {
    public:
        constexpr month_weekday(const month& _Month_, const weekday_indexed& _Wdi) noexcept
            : _Month{_Month_}, _Weekday_index{_Wdi} {}

        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr weekday_indexed weekday_indexed() const noexcept {
            return _Weekday_index;
        }

        _NODISCARD constexpr bool ok() const noexcept {
            return _Month.ok() && _Weekday_index.ok();
        }

    private:
        _CHRONO month _Month;
        _CHRONO weekday_indexed _Weekday_index;
    };

    _NODISCARD constexpr bool operator==(const month_weekday& _Left, const month_weekday& _Right) noexcept {
        return _Left.month() == _Right.month() && _Left.weekday_indexed() == _Right.weekday_indexed();
    }

    class month_weekday_last {
    public:
        constexpr month_weekday_last(const month& _Month_, const weekday_last& _Wdl) noexcept
            : _Month{_Month_}, _Weekday_last{_Wdl} {}

        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr weekday_last weekday_last() const noexcept {
            return _Weekday_last;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Month.ok() && _Weekday_last.ok();
        }

    private:
        _CHRONO month _Month;
        _CHRONO weekday_last _Weekday_last;
    };

    _NODISCARD constexpr bool operator==(const month_weekday_last& _Left, const month_weekday_last& _Right) noexcept {
        return _Left.month() == _Right.month() && _Left.weekday_last() == _Right.weekday_last();
    }

    class year_month {
    public:
        year_month() = default;
        constexpr year_month(const year& _Year_, const month& _Month_) noexcept : _Year{_Year_}, _Month{_Month_} {}

        _NODISCARD constexpr year year() const noexcept {
            return _Year;
        }
        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }

        template <int = 0>
        constexpr year_month& operator+=(const months& _Months) noexcept;
        template <int = 0>
        constexpr year_month& operator-=(const months& _Months) noexcept;
        constexpr year_month& operator+=(const years& _Years) noexcept;
        constexpr year_month& operator-=(const years& _Years) noexcept;

        _NODISCARD constexpr bool ok() const noexcept {
            return _Year.ok() && _Month.ok();
        }

    private:
        _CHRONO year _Year;
        _CHRONO month _Month;
    };

    _NODISCARD constexpr bool operator==(const year_month& _Left, const year_month& _Right) noexcept {
        return _Left.year() == _Right.year() && _Left.month() == _Right.month();
    }
    _NODISCARD constexpr strong_ordering operator<=>(const year_month& _Left, const year_month& _Right) noexcept {
        const auto _Comp = _Left.year() <=> _Right.year();
        if (_Comp != 0) {
            return _Comp;
        }

        return _Left.month() <=> _Right.month();
    }

    template <int = 0>
    _NODISCARD constexpr year_month operator+(const year_month& _Left, const months& _Right) noexcept {
        const auto _Mo  = static_cast<long long>(static_cast<unsigned int>(_Left.month())) + (_Right.count() - 1);
        const auto _Div = (_Mo >= 0 ? _Mo : _Mo - 11) / 12;
        return year_month{_Left.year() + years{_Div}, month{static_cast<unsigned int>(_Mo - _Div * 12 + 1)}};
    }
    template <int = 0>
    _NODISCARD constexpr year_month operator+(const months& _Left, const year_month& _Right) noexcept {
        return _Right + _Left;
    }

    template <int = 0>
    _NODISCARD constexpr year_month operator-(const year_month& _Left, const months& _Right) noexcept {
        return _Left + -_Right;
    }

    _NODISCARD constexpr months operator-(const year_month& _Left, const year_month& _Right) noexcept {
        return _Left.year() - _Right.year()
             + months{static_cast<int>(static_cast<unsigned int>(_Left.month()))
                      - static_cast<int>(static_cast<unsigned int>(_Right.month()))};
    }

    _NODISCARD constexpr year_month operator+(const year_month& _Left, const years& _Right) noexcept {
        return {year{_Left.year() + _Right}, _Left.month()};
    }

    _NODISCARD constexpr year_month operator+(const years& _Left, const year_month& _Right) noexcept {
        return _Right + _Left;
    }

    _NODISCARD constexpr year_month operator-(const year_month& _Left, const years& _Right) noexcept {
        return _Left + -_Right;
    }

    template <int>
    constexpr year_month& year_month::operator+=(const months& _Months) noexcept {
        *this = *this + _Months;
        return *this;
    }
    template <int>
    constexpr year_month& year_month::operator-=(const months& _Months) noexcept {
        *this = *this - _Months;
        return *this;
    }
    constexpr year_month& year_month::operator+=(const years& _Years) noexcept {
        *this = *this + _Years;
        return *this;
    }
    constexpr year_month& year_month::operator-=(const years& _Years) noexcept {
        *this = *this - _Years;
        return *this;
    }

    // To prevent UB by going out of bounds, four extra days with an invalid day are added.
    inline constexpr day _Last_day_table[] = {day{31}, day{28}, day{31}, day{30}, day{31}, day{30}, day{31}, day{31},
        day{30}, day{31}, day{30}, day{31}, day{255}, day{255}, day{255}, day{255}};

    _NODISCARD constexpr day _Last_day(const year& _Year, const month& _Month) {
        if (_Month == month{2} && _Year.is_leap()) {
            return day{29};
        }

        return _Last_day_table[(static_cast<unsigned int>(_Month) - 1) & 0xF];
    }

    class year_month_day_last;

    class year_month_day {
    public:
        year_month_day() = default;
        constexpr year_month_day(const year& _Year_, const month& _Month_, const day& _Day_) noexcept
            : _Year{_Year_}, _Month{_Month_}, _Day{_Day_} {}
        constexpr year_month_day(const year_month_day_last& _Ymdl) noexcept;
        constexpr year_month_day(const sys_days& _Sys_days) noexcept
            : year_month_day{_Civil_from_days(_Sys_days.time_since_epoch().count())} {}
        constexpr explicit year_month_day(const local_days& _Local_days) noexcept
            : year_month_day{_Civil_from_days(_Local_days.time_since_epoch().count())} {}

        template <int = 0>
        constexpr year_month_day& operator+=(const months& _Months) noexcept;
        template <int = 0>
        constexpr year_month_day& operator-=(const months& _Months) noexcept;
        constexpr year_month_day& operator+=(const years& _Years) noexcept;
        constexpr year_month_day& operator-=(const years& _Years) noexcept;

        _NODISCARD constexpr year year() const noexcept {
            return _Year;
        }
        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr day day() const noexcept {
            return _Day;
        }

        _NODISCARD constexpr operator sys_days() const noexcept {
            return sys_days{_Days_from_civil()};
        }
        _NODISCARD constexpr explicit operator local_days() const noexcept {
            return local_days{static_cast<sys_days>(*this).time_since_epoch()};
        }
        _NODISCARD constexpr bool ok() const noexcept {
            if (!_Year.ok() || !_Month.ok()) {
                return false;
            }

            return _Day >= _CHRONO day{1} && _Day <= _Last_day(_Year, _Month);
        }

    private:
        _CHRONO year _Year;
        _CHRONO month _Month;
        _CHRONO day _Day;

        // _Civil_from_days and _Days_from_civil perform conversions between the dates in the (proleptic) Gregorian
        // calendar and the continuous count of days since 1970-01-01.

        // To simplify the handling of leap days (February 29th), the algorithm below uses a modified calendar
        // internally, in which each year begins on March 1st, while January and February belong to the previous year.
        // We denote the modified year and month number as _Yp and _Mp. We also define modified centuries that begin on
        // each modified year whose _Yp is a multiple of 100.

        // _Mp | Month     | Day of Year
        // --- | --------- | -----------
        //  0  | March     | [  0,  30]
        //  1  | April     | [ 31,  60]
        //  2  | May       | [ 61,  91]
        //  3  | June      | [ 92, 121]
        //  4  | July      | [122, 152]
        //  5  | August    | [153, 183]
        //  6  | September | [184, 213]
        //  7  | October   | [214, 244]
        //  8  | November  | [245, 274]
        //  9  | December  | [275, 305]
        // 10  | January   | [306, 336]
        // 11  | February  | [337, 365] on leap years, [337, 364] on regular years

        // _Yp |  First Day  | Last Day (inclusive) | Leap Year?
        // --- | ----------- | -------------------- | ----------
        //  -4 | -0004-03-01 |     -0003-02-28      |     No
        //  -3 | -0003-03-01 |     -0002-02-28      |     No
        //  -2 | -0002-03-01 |     -0001-02-28      |     No
        //  -1 | -0001-03-01 |      0000-02-29      |     Yes
        //   0 |  0000-03-01 |      0001-02-28      |     No
        //   1 |  0001-03-01 |      0002-02-28      |     No
        //   2 |  0002-03-01 |      0003-02-28      |     No
        //   3 |  0003-03-01 |      0004-02-29      |     Yes

        // _Century |  First Day  | Last Day (inclusive) | Long Century?
        // -------- | ----------- | -------------------- | -------------
        //    -4    | -0400-03-01 |     -0300-02-28      |      No
        //    -3    | -0300-03-01 |     -0200-02-28      |      No
        //    -2    | -0200-03-01 |     -0100-02-28      |      No
        //    -1    | -0100-03-01 |      0000-02-29      |      Yes
        //     0    |  0000-03-01 |      0100-02-28      |      No
        //     1    |  0100-03-01 |      0200-02-28      |      No
        //     2    |  0200-03-01 |      0300-02-28      |      No
        //     3    |  0300-03-01 |      0400-02-29      |      Yes

        // The structure of the modified calendar:
        // 1 ) It has a period of 4 centuries.
        // 2 ) Each calendar period (146097 days) contains 3 regular centuries followed by a long century (36525 days).
        // 3 ) Each regular century (36524 days) contains 24 regular 4-year spans followed by a short 4-year span.
        // 3') Each long century (36525 days) contains 25 regular 4-year spans.
        // 4 ) Each regular 4-year span (1461 days) contains 3 regular years followed by a leap year.
        // 4') Each short 4-year span (1460 days) contains 4 regular years.

        // Formula 1: Compute _Day_of_year of the first day of month _Mp
        //
        //   _Day_of_year = (979 * _Mp + 19) >> 5
        //
        // A more well-known formula is 30 * _Mp + floor((3 * _Mp + 2) / 5) or floor((153 * _Mp + 2) / 5), which is used
        // in Howard Hinnant's paper.
        //
        // The formula above returns the same result for all _Mp in [0, 11].
        // Note that 979 / 2^5 = 30.59375 ~= 30.6 = 153 / 5.

        // Formula 1': Compute _Mp from _Day_of_year
        //
        //   _Mp = (535 * _Day_of_year + 333) >> 14
        //
        // Howard Hinnant's paper uses floor((5 * _Day_of_year + 2) / 153), the inverse of floor((153 * _Mp + 2) / 5) or
        // ceil((153 * _Mp - 2) / 5).
        //
        // The formula above returns the same result for all _Day_of_year in [0, 365].
        // Note that 2^14 / 535 = 30.624... ~= 30.6 = 153 / 5.

        // Formula 2: Compute _Zx of the first day of year _Yp, where _Zx is the continuous count of days since
        // 0000-03-01.
        //
        //   _Zx = ((1461 * _Yp) >> 2) - _Century + (_Century >> 2)
        //
        // Start with multiplying by the number of days in regular years (365), add one day for the leap year in each
        // 4-year span, subtract one day for the short 4-year span in each century, and finally add one day for the long
        // century in each calendar period. This gives us 365 * _Yp + floor(_Yp / 4) - _Century + floor(_Century / 4).

        // Formula 2-1: Compute _Day_of_century of the first day of year _Year_of_century
        //
        //   _Day_of_century = (1461 * _Year_of_century) >> 2
        //
        // Start with multiplying by the number of days in regular years (365), add one day for the leap year in each
        // 4-year span. This gives us 365 * _Year_of_century + floor(_Year_of_century / 4)
        // == floor(1461 * _Year_of_century / 4).

        // Formula 2-1': Compute _Year_of_century from _Day_of_century
        //
        //   _Year_of_century = (91867 * (_Day_of_century + 1)) >> 25
        //
        // The inverse of floor(1461 * _Year_of_century / 4) or ceil((1461 * _Year_of_century - 3) / 4) is
        // floor((4 * _Day_of_century + 3) / 1461).
        //
        // The formula above returns the same result for all _Day_of_century in [0, 36524].
        // Note that 2^25 / 91867 = 365.2501... ~= 365.25 = 1461 / 4.

        // Formula 2-2: Compute _Zx of the first day of century _Century, where _Zx is the continuous count of days
        // since 0000-03-01.
        //
        //   _Zx = (146097 * _Century) >> 2
        //
        // Start with multiplying by the number of days in regular centuries (36524), add one day for the long century
        // in each calendar period. This gives us 36524 * _Century + floor(_Century / 4) = floor(146097 * _Century / 4).

        // Formula 2-2': Compute _Century from _Zx, where _Zx is the continuous count of days since 0000-03-01.
        //
        //   _Century = floor((4 * _Zx + 3) / 146097)
        //
        // This is the inverse of floor(146097 * _Year_of_century / 4) or ceil((146097 * _Year_of_century - 3) / 4)

        // courtesy of Howard Hinnant
        // https://howardhinnant.github.io/date_algorithms.html#civil_from_days
        _NODISCARD static constexpr year_month_day _Civil_from_days(int _Tp) noexcept {
            static_assert(numeric_limits<unsigned int>::digits >= 32);
            static_assert(numeric_limits<int>::digits >= 26);
            const int _Zx = _Tp + 719468; // Shift epoch to 0000-03-01
            // Formula 2-2'
            const int _Century = (_Zx >= 0 ? 4 * _Zx + 3 : 4 * _Zx - 146093) / 146097;
            // Formula 2-2
            const unsigned int _Day_of_century =
                static_cast<unsigned int>(_Zx - ((146097 * _Century) >> 2)); // [0, 36524]
            // Formula 2-1'
            const unsigned int _Year_of_century = (91867 * (_Day_of_century + 1)) >> 25; // [0, 99]
            const int _Yp = static_cast<int>(_Year_of_century) + _Century * 100; // Where March is the first month
            // Formula 2-1
            const unsigned int _Day_of_year = _Day_of_century - ((1461 * _Year_of_century) >> 2); // [0, 365]
            // Formula 1'
            const unsigned int _Mp = (535 * _Day_of_year + 333) >> 14; // [0, 11]
            // Formula 1
            const unsigned int _Day   = _Day_of_year - ((979 * _Mp + 19) >> 5) + 1; // [1, 31]
            const unsigned int _Month = _Mp + (_Mp < 10 ? 3 : static_cast<unsigned int>(-9)); // [1, 12]
            return year_month_day{_CHRONO year{_Yp + (_Month <= 2)}, _CHRONO month{_Month}, _CHRONO day{_Day}};
        }
        // courtesy of Howard Hinnant
        // https://howardhinnant.github.io/date_algorithms.html#days_from_civil
        _NODISCARD constexpr days _Days_from_civil() const noexcept {
            static_assert(numeric_limits<unsigned int>::digits >= 18);
            static_assert(numeric_limits<int>::digits >= 26);
            const unsigned int _Mo = static_cast<unsigned int>(_Month); // [1, 12]
            const int _Yp          = static_cast<int>(_Year) - (_Mo <= 2);
            const int _Century     = (_Yp >= 0 ? _Yp : _Yp - 99) / 100;
            const unsigned int _Mp = _Mo + (_Mo > 2 ? static_cast<unsigned int>(-3) : 9); // [0, 11]
            // Formula 1
            const int _Day_of_year = static_cast<int>(((979 * _Mp + 19) >> 5) + static_cast<unsigned int>(_Day)) - 1;
            // Formula 2
            return days{((1461 * _Yp) >> 2) - _Century + (_Century >> 2) + _Day_of_year - 719468};
        }
    };

    _NODISCARD constexpr bool operator==(const year_month_day& _Left, const year_month_day& _Right) noexcept {
        return _Left.year() == _Right.year() && _Left.month() == _Right.month() && _Left.day() == _Right.day();
    }
    _NODISCARD constexpr strong_ordering operator<=>(
        const year_month_day& _Left, const year_month_day& _Right) noexcept {
        auto _Comp = _Left.year() <=> _Right.year();
        if (_Comp != 0) {
            return _Comp;
        }

        _Comp = _Left.month() <=> _Right.month();
        if (_Comp != 0) {
            return _Comp;
        }

        return _Left.day() <=> _Right.day();
    }

    template <int = 0>
    _NODISCARD constexpr year_month_day operator+(const year_month_day& _Left, const months& _Right) noexcept {
        const auto _Ym = year_month{_Left.year(), _Left.month()} + _Right;
        return {_Ym.year(), _Ym.month(), _Left.day()};
    }

    template <int = 0>
    _NODISCARD constexpr year_month_day operator+(const months& _Left, const year_month_day& _Right) noexcept {
        return _Right + _Left;
    }

    template <int = 0>
    _NODISCARD constexpr year_month_day operator-(const year_month_day& _Left, const months& _Right) noexcept {
        return _Left + -_Right;
    }

    _NODISCARD constexpr year_month_day operator+(const year_month_day& _Left, const years& _Right) noexcept {
        return {_Left.year() + _Right, _Left.month(), _Left.day()};
    }

    _NODISCARD constexpr year_month_day operator+(const years& _Left, const year_month_day& _Right) noexcept {
        return _Right + _Left;
    }

    _NODISCARD constexpr year_month_day operator-(const year_month_day& _Left, const years& _Right) noexcept {
        return _Left + -_Right;
    }

    template <int>
    constexpr year_month_day& year_month_day::operator+=(const months& _Months) noexcept {
        *this = *this + _Months;
        return *this;
    }
    template <int>
    constexpr year_month_day& year_month_day::operator-=(const months& _Months) noexcept {
        *this = *this - _Months;
        return *this;
    }
    constexpr year_month_day& year_month_day::operator+=(const years& _Years) noexcept {
        *this = *this + _Years;
        return *this;
    }
    constexpr year_month_day& year_month_day::operator-=(const years& _Years) noexcept {
        *this = *this - _Years;
        return *this;
    }

    class year_month_day_last {
    public:
        constexpr year_month_day_last(const year& _Year_, const month_day_last& _Mdl) noexcept
            : _Year{_Year_}, _Month_day_last{_Mdl} {}

        template <int = 0>
        constexpr year_month_day_last& operator+=(const months& _Months) noexcept;
        template <int = 0>
        constexpr year_month_day_last& operator-=(const months& _Months) noexcept;
        constexpr year_month_day_last& operator+=(const years& _Years) noexcept;
        constexpr year_month_day_last& operator-=(const years& _Years) noexcept;

        _NODISCARD constexpr year year() const noexcept {
            return _Year;
        }
        _NODISCARD constexpr month month() const noexcept {
            return _Month_day_last.month();
        }
        _NODISCARD constexpr month_day_last month_day_last() const noexcept {
            return _Month_day_last;
        }
        _NODISCARD constexpr day day() const noexcept {
            return _Last_day(year(), month());
        }

        _NODISCARD constexpr operator sys_days() const noexcept {
            return sys_days{year_month_day{year(), month(), day()}};
        }
        _NODISCARD constexpr explicit operator local_days() const noexcept {
            return local_days{static_cast<sys_days>(*this).time_since_epoch()};
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Year.ok() && _Month_day_last.ok();
        }

    private:
        _CHRONO year _Year;
        _CHRONO month_day_last _Month_day_last;
    };

    _NODISCARD constexpr bool operator==(const year_month_day_last& _Left, const year_month_day_last& _Right) noexcept {
        return _Left.year() == _Right.year() && _Left.month_day_last() == _Right.month_day_last();
    }
    _NODISCARD constexpr strong_ordering operator<=>(
        const year_month_day_last& _Left, const year_month_day_last& _Right) noexcept {
        const auto _Comp = _Left.year() <=> _Right.year();
        if (_Comp != 0) {
            return _Comp;
        }

        return _Left.month_day_last() <=> _Right.month_day_last();
    }

    template <int = 0>
    _NODISCARD constexpr year_month_day_last operator+(
        const year_month_day_last& _Left, const months& _Right) noexcept {
        const auto _Ym = year_month{_Left.year(), _Left.month()} + _Right;
        return {_Ym.year(), month_day_last{_Ym.month()}};
    }
    template <int = 0>
    _NODISCARD constexpr year_month_day_last operator+(
        const months& _Left, const year_month_day_last& _Right) noexcept {
        return _Right + _Left;
    }

    template <int = 0>
    _NODISCARD constexpr year_month_day_last operator-(
        const year_month_day_last& _Left, const months& _Right) noexcept {
        return _Left + -_Right;
    }

    _NODISCARD constexpr year_month_day_last operator+(const year_month_day_last& _Left, const years& _Right) noexcept {
        return {_Left.year() + _Right, _Left.month_day_last()};
    }
    _NODISCARD constexpr year_month_day_last operator+(const years& _Left, const year_month_day_last& _Right) noexcept {
        return _Right + _Left;
    }
    _NODISCARD constexpr year_month_day_last operator-(const year_month_day_last& _Left, const years& _Right) noexcept {
        return _Left + -_Right;
    }

    template <int>
    constexpr year_month_day_last& year_month_day_last::operator+=(const months& _Months) noexcept {
        *this = *this + _Months;
        return *this;
    }
    template <int>
    constexpr year_month_day_last& year_month_day_last::operator-=(const months& _Months) noexcept {
        *this = *this - _Months;
        return *this;
    }
    constexpr year_month_day_last& year_month_day_last::operator+=(const years& _Years) noexcept {
        *this = *this + _Years;
        return *this;
    }
    constexpr year_month_day_last& year_month_day_last::operator-=(const years& _Years) noexcept {
        *this = *this - _Years;
        return *this;
    }

    constexpr year_month_day::year_month_day(const year_month_day_last& _Ymdl) noexcept
        : _Year{_Ymdl.year()}, _Month{_Ymdl.month()}, _Day{_Ymdl.day()} {}

    class year_month_weekday {
    public:
        year_month_weekday() = default;
        constexpr year_month_weekday(const year& _Year_, const month& _Month_, const weekday_indexed& _Wdi) noexcept
            : _Year{_Year_}, _Month{_Month_}, _Weekday_index{_Wdi} {}
        constexpr year_month_weekday(const sys_days& _Sys_days) noexcept
            : year_month_weekday{_Ymwd_from_days(_Sys_days.time_since_epoch())} {}
        constexpr explicit year_month_weekday(const local_days& _Local_days) noexcept
            : year_month_weekday{_Ymwd_from_days(_Local_days.time_since_epoch())} {}

        template <int = 0>
        constexpr year_month_weekday& operator+=(const months& _Months) noexcept;
        template <int = 0>
        constexpr year_month_weekday& operator-=(const months& _Months) noexcept;
        constexpr year_month_weekday& operator+=(const years& _Years) noexcept;
        constexpr year_month_weekday& operator-=(const years& _Years) noexcept;

        _NODISCARD constexpr year year() const noexcept {
            return _Year;
        }
        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr weekday weekday() const noexcept {
            return _Weekday_index.weekday();
        }
        _NODISCARD constexpr unsigned int index() const noexcept {
            return _Weekday_index.index();
        }
        _NODISCARD constexpr weekday_indexed weekday_indexed() const noexcept {
            return _Weekday_index;
        }

        _NODISCARD constexpr operator sys_days() const noexcept {
            const sys_days _First = year_month_day{_Year, _Month, day{1}};
            const days _Diff      = weekday() - _CHRONO weekday{_First};
            const days _Days      = _Diff + days{(static_cast<int>(index()) - 1) * 7};
            return _First + _Days;
        }
        _NODISCARD constexpr explicit operator local_days() const noexcept {
            return local_days{static_cast<sys_days>(*this).time_since_epoch()};
        }
        _NODISCARD constexpr bool ok() const noexcept {
            if (!_Year.ok() || !_Month.ok() || !_Weekday_index.ok()) {
                return false;
            }

            if (_Weekday_index.index() <= 4) {
                return true;
            }

            // As index() == 5 is not always valid
            // Determine the date of the first weekday and check if + days{28} is <= last day of the month
            const sys_days _First_of_month = year_month_day{_Year, _Month, day{1}};
            const days _First_weekday      = weekday() - _CHRONO weekday{_First_of_month} + days{1};
            const days _Last               = _First_weekday + days{28};
            return static_cast<unsigned int>(_Last.count()) <= static_cast<unsigned int>(_Last_day(_Year, _Month));
        }

    private:
        _CHRONO year _Year;
        _CHRONO month _Month;
        _CHRONO weekday_indexed _Weekday_index;

        _NODISCARD static constexpr year_month_weekday _Ymwd_from_days(days _Dp) noexcept {
            const _CHRONO year_month_day _Ymd = sys_days{_Dp};
            const _CHRONO weekday _Wd         = sys_days{_Dp};
            const auto _Idx                   = ((static_cast<unsigned int>(_Ymd.day()) - 1) / 7) + 1;
            return {_Ymd.year(), _Ymd.month(), _Wd[_Idx]};
        }
    };

    _NODISCARD constexpr bool operator==(const year_month_weekday& _Left, const year_month_weekday& _Right) noexcept {
        return _Left.year() == _Right.year() && _Left.month() == _Right.month()
            && _Left.weekday_indexed() == _Right.weekday_indexed();
    }

    template <int = 0>
    _NODISCARD constexpr year_month_weekday operator+(const year_month_weekday& _Left, const months& _Right) noexcept {
        const auto _Ym = year_month{_Left.year(), _Left.month()} + _Right;
        return {_Ym.year(), _Ym.month(), _Left.weekday_indexed()};
    }
    template <int = 0>
    _NODISCARD constexpr year_month_weekday operator+(const months& _Left, const year_month_weekday& _Right) noexcept {
        return _Right + _Left;
    }

    template <int = 0>
    _NODISCARD constexpr year_month_weekday operator-(const year_month_weekday& _Left, const months& _Right) noexcept {
        return _Left + -_Right;
    }

    _NODISCARD constexpr year_month_weekday operator+(const year_month_weekday& _Left, const years& _Right) noexcept {
        return year_month_weekday{_Left.year() + _Right, _Left.month(), _Left.weekday_indexed()};
    }
    _NODISCARD constexpr year_month_weekday operator+(const years& _Left, const year_month_weekday& _Right) noexcept {
        return _Right + _Left;
    }

    _NODISCARD constexpr year_month_weekday operator-(const year_month_weekday& _Left, const years& _Right) noexcept {
        return _Left + -_Right;
    }

    template <int>
    constexpr year_month_weekday& year_month_weekday::operator+=(const months& _Months) noexcept {
        *this = *this + _Months;
        return *this;
    }
    template <int>
    constexpr year_month_weekday& year_month_weekday::operator-=(const months& _Months) noexcept {
        *this = *this - _Months;
        return *this;
    }
    constexpr year_month_weekday& year_month_weekday::operator+=(const years& _Years) noexcept {
        *this = *this + _Years;
        return *this;
    }
    constexpr year_month_weekday& year_month_weekday::operator-=(const years& _Years) noexcept {
        *this = *this - _Years;
        return *this;
    }

    class year_month_weekday_last {
    public:
        constexpr year_month_weekday_last(const year& _Year_, const month& _Month_, const weekday_last& _Wdl) noexcept
            : _Year{_Year_}, _Month{_Month_}, _Weekday_last{_Wdl} {}

        template <int = 0>
        constexpr year_month_weekday_last& operator+=(const months& _Months) noexcept;
        template <int = 0>
        constexpr year_month_weekday_last& operator-=(const months& _Months) noexcept;
        constexpr year_month_weekday_last& operator+=(const years& _Years) noexcept;
        constexpr year_month_weekday_last& operator-=(const years& _Years) noexcept;

        _NODISCARD constexpr year year() const noexcept {
            return _Year;
        }
        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr weekday weekday() const noexcept {
            return _Weekday_last.weekday();
        }

        _NODISCARD constexpr weekday_last weekday_last() const noexcept {
            return _Weekday_last;
        }

        _NODISCARD constexpr operator sys_days() const noexcept {
            const sys_days _Last = year_month_day_last{_Year, month_day_last{_Month}};
            const auto _Diff     = _CHRONO weekday{_Last} - weekday();
            return _Last - _Diff;
        }
        _NODISCARD constexpr explicit operator local_days() const noexcept {
            return local_days{static_cast<sys_days>(*this).time_since_epoch()};
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Year.ok() && _Month.ok() && _Weekday_last.ok();
        }

    private:
        _CHRONO year _Year;
        _CHRONO month _Month;
        _CHRONO weekday_last _Weekday_last;
    };

    _NODISCARD constexpr bool operator==(
        const year_month_weekday_last& _Left, const year_month_weekday_last& _Right) noexcept {
        return _Left.year() == _Right.year() && _Left.month() == _Right.month()
            && _Left.weekday_last() == _Right.weekday_last();
    }

    template <int = 0>
    _NODISCARD constexpr year_month_weekday_last operator+(
        const year_month_weekday_last& _Left, const months& _Right) noexcept {
        const auto _Ym = year_month{_Left.year(), _Left.month()} + _Right;
        return {_Ym.year(), _Ym.month(), _Left.weekday_last()};
    }
    template <int = 0>
    _NODISCARD constexpr year_month_weekday_last operator+(
        const months& _Left, const year_month_weekday_last& _Right) noexcept {
        return _Right + _Left;
    }

    template <int = 0>
    _NODISCARD constexpr year_month_weekday_last operator-(
        const year_month_weekday_last& _Left, const months& _Right) noexcept {
        return _Left + -_Right;
    }

    _NODISCARD constexpr year_month_weekday_last operator+(
        const year_month_weekday_last& _Left, const years& _Right) noexcept {
        return {_Left.year() + _Right, _Left.month(), _Left.weekday_last()};
    }
    _NODISCARD constexpr year_month_weekday_last operator+(
        const years& _Left, const year_month_weekday_last& _Right) noexcept {
        return _Right + _Left;
    }

    _NODISCARD constexpr year_month_weekday_last operator-(
        const year_month_weekday_last& _Left, const years& _Right) noexcept {
        return _Left + -_Right;
    }

    template <int>
    constexpr year_month_weekday_last& year_month_weekday_last::operator+=(const months& _Months) noexcept {
        *this = *this + _Months;
        return *this;
    }
    template <int>
    constexpr year_month_weekday_last& year_month_weekday_last::operator-=(const months& _Months) noexcept {
        *this = *this - _Months;
        return *this;
    }
    constexpr year_month_weekday_last& year_month_weekday_last::operator+=(const years& _Years) noexcept {
        *this = *this + _Years;
        return *this;
    }
    constexpr year_month_weekday_last& year_month_weekday_last::operator-=(const years& _Years) noexcept {
        *this = *this - _Years;
        return *this;
    }

    // Civil calendar conventional syntax operators
    _NODISCARD constexpr year_month operator/(const year& _Year, const month& _Month) noexcept {
        return {_Year, _Month};
    }
    _NODISCARD constexpr year_month operator/(const year& _Year, int _Month) noexcept {
        return _Year / month{static_cast<unsigned int>(_Month)};
    }
    _NODISCARD constexpr month_day operator/(const month& _Month, const day& _Day) noexcept {
        return {_Month, _Day};
    }
    _NODISCARD constexpr month_day operator/(const month& _Month, int _Day) noexcept {
        return _Month / day{static_cast<unsigned int>(_Day)};
    }
    _NODISCARD constexpr month_day operator/(int _Month, const day& _Day) noexcept {
        return month{static_cast<unsigned int>(_Month)} / _Day;
    }
    _NODISCARD constexpr month_day operator/(const day& _Day, const month& _Month) noexcept {
        return _Month / _Day;
    }
    _NODISCARD constexpr month_day operator/(const day& _Day, int _Month) noexcept {
        return month{static_cast<unsigned int>(_Month)} / _Day;
    }
    _NODISCARD constexpr month_day_last operator/(const month& _Month, last_spec) noexcept {
        return month_day_last{_Month};
    }
    _NODISCARD constexpr month_day_last operator/(int _Month, last_spec) noexcept {
        return month{static_cast<unsigned int>(_Month)} / last;
    }
    _NODISCARD constexpr month_day_last operator/(last_spec, const month& _Month) noexcept {
        return _Month / last;
    }
    _NODISCARD constexpr month_day_last operator/(last_spec, int _Month) noexcept {
        return month{static_cast<unsigned int>(_Month)} / last;
    }
    _NODISCARD constexpr month_weekday operator/(const month& _Month, const weekday_indexed& _Wdi) noexcept {
        return {_Month, _Wdi};
    }
    _NODISCARD constexpr month_weekday operator/(int _Month, const weekday_indexed& _Wdi) noexcept {
        return month{static_cast<unsigned int>(_Month)} / _Wdi;
    }
    _NODISCARD constexpr month_weekday operator/(const weekday_indexed& _Wdi, const month& _Month) noexcept {
        return _Month / _Wdi;
    }
    _NODISCARD constexpr month_weekday operator/(const weekday_indexed& _Wdi, int _Month) noexcept {
        return month{static_cast<unsigned int>(_Month)} / _Wdi;
    }
    _NODISCARD constexpr month_weekday_last operator/(const month& _Month, const weekday_last& _Wdl) noexcept {
        return {_Month, _Wdl};
    }
    _NODISCARD constexpr month_weekday_last operator/(int _Month, const weekday_last& _Wdl) noexcept {
        return month{static_cast<unsigned int>(_Month)} / _Wdl;
    }
    _NODISCARD constexpr month_weekday_last operator/(const weekday_last& _Wdl, const month& _Month) noexcept {
        return _Month / _Wdl;
    }
    _NODISCARD constexpr month_weekday_last operator/(const weekday_last& _Wdl, int _Month) noexcept {
        return month{static_cast<unsigned int>(_Month)} / _Wdl;
    }
    _NODISCARD constexpr year_month_day operator/(const year_month& _Ym, const day& _Day) noexcept {
        return {_Ym.year(), _Ym.month(), _Day};
    }
    _NODISCARD constexpr year_month_day operator/(const year_month& _Ym, int _Day) noexcept {
        return _Ym / day{static_cast<unsigned int>(_Day)};
    }
    _NODISCARD constexpr year_month_day operator/(const year& _Year, const month_day& _Md) noexcept {
        return _Year / _Md.month() / _Md.day();
    }
    _NODISCARD constexpr year_month_day operator/(int _Year, const month_day& _Md) noexcept {
        return year{_Year} / _Md.month() / _Md.day();
    }
    _NODISCARD constexpr year_month_day operator/(const month_day& _Md, const year& _Year) noexcept {
        return _Year / _Md.month() / _Md.day();
    }
    _NODISCARD constexpr year_month_day operator/(const month_day& _Md, int _Year) noexcept {
        return year{_Year} / _Md.month() / _Md.day();
    }
    _NODISCARD constexpr year_month_day_last operator/(const year_month& _Ym, last_spec) noexcept {
        return {_Ym.year(), month_day_last{_Ym.month()}};
    }
    _NODISCARD constexpr year_month_day_last operator/(const year& _Year, const month_day_last& _Mdl) noexcept {
        return {_Year, _Mdl};
    }
    _NODISCARD constexpr year_month_day_last operator/(int _Year, const month_day_last& _Mdl) noexcept {
        return year{_Year} / _Mdl;
    }
    _NODISCARD constexpr year_month_day_last operator/(const month_day_last& _Mdl, const year& _Year) noexcept {
        return _Year / _Mdl;
    }
    _NODISCARD constexpr year_month_day_last operator/(const month_day_last& _Mdl, int _Year) noexcept {
        return year{_Year} / _Mdl;
    }
    _NODISCARD constexpr year_month_weekday operator/(const year_month& _Ym, const weekday_indexed& _Wdi) noexcept {
        return year_month_weekday{_Ym.year(), _Ym.month(), _Wdi};
    }
    _NODISCARD constexpr year_month_weekday operator/(const year& _Year, const month_weekday& _Mwd) noexcept {
        return year_month_weekday{_Year, _Mwd.month(), _Mwd.weekday_indexed()};
    }
    _NODISCARD constexpr year_month_weekday operator/(int _Year, const month_weekday& _Mwd) noexcept {
        return year{_Year} / _Mwd;
    }
    _NODISCARD constexpr year_month_weekday operator/(const month_weekday& _Mwd, const year& _Year) noexcept {
        return _Year / _Mwd;
    }
    _NODISCARD constexpr year_month_weekday operator/(const month_weekday& _Mwd, int _Year) noexcept {
        return year{_Year} / _Mwd;
    }
    _NODISCARD constexpr year_month_weekday_last operator/(const year_month& _Ym, const weekday_last& _Wdl) noexcept {
        return {_Ym.year(), _Ym.month(), _Wdl};
    }
    _NODISCARD constexpr year_month_weekday_last operator/(
        const year& _Year, const month_weekday_last& _Mwdl) noexcept {
        return {_Year, _Mwdl.month(), _Mwdl.weekday_last()};
    }
    _NODISCARD constexpr year_month_weekday_last operator/(int _Year, const month_weekday_last& _Mwdl) noexcept {
        return year{_Year} / _Mwdl;
    }
    _NODISCARD constexpr year_month_weekday_last operator/(
        const month_weekday_last& _Mwdl, const year& _Year) noexcept {
        return _Year / _Mwdl;
    }
    _NODISCARD constexpr year_month_weekday_last operator/(const month_weekday_last& _Mwdl, int _Year) noexcept {
        return year{_Year} / _Mwdl;
    }

    // Calendrical constants
    inline constexpr weekday Sunday{0};
    inline constexpr weekday Monday{1};
    inline constexpr weekday Tuesday{2};
    inline constexpr weekday Wednesday{3};
    inline constexpr weekday Thursday{4};
    inline constexpr weekday Friday{5};
    inline constexpr weekday Saturday{6};

    inline constexpr month January{1};
    inline constexpr month February{2};
    inline constexpr month March{3};
    inline constexpr month April{4};
    inline constexpr month May{5};
    inline constexpr month June{6};
    inline constexpr month July{7};
    inline constexpr month August{8};
    inline constexpr month September{9};
    inline constexpr month October{10};
    inline constexpr month November{11};
    inline constexpr month December{12};

    _NODISCARD constexpr intmax_t _Pow10(const unsigned int _Exp) {
        intmax_t _Result = 1;
        for (unsigned int _Ix = 0; _Ix < _Exp; ++_Ix) {
            _Result *= 10;
        }
        return _Result;
    }

    template <class _Duration>
    requires _Is_duration_v<_Duration> class hh_mm_ss {
    public:
        static constexpr unsigned int fractional_width = [] {
            auto _Num           = _Duration::period::num;
            constexpr auto _Den = _Duration::period::den;
            // Returns the number of fractional digits of _Num / _Den in the range [0, 18].
            // If it can't be represented, 6 is returned.
            // Example: _Fractional_width(1, 8) would return 3 for 0.125.
            _STL_ASSERT(_Num > 0 && _Den > 0, "Numerator and denominator can't be less than 1.");
            unsigned int _Result = 0;
            for (; _Num % _Den != 0 && _Result < 19; _Num = _Num % _Den * 10, ++_Result) {
            }
            return _Result == 19 ? 6 : _Result;
        }();
        using precision =
            duration<common_type_t<typename _Duration::rep, seconds::rep>, ratio<1, _Pow10(fractional_width)>>;

        constexpr hh_mm_ss() noexcept : hh_mm_ss{_Duration::zero()} {}
        // clang-format off
        constexpr explicit hh_mm_ss(_Duration _Dur)
            : _Is_neg{_Dur < _Duration::zero()},
              _Hours{_CHRONO duration_cast<_CHRONO hours>(_CHRONO abs(_Dur))},
              _Mins{_CHRONO duration_cast<_CHRONO minutes>(_CHRONO abs(_Dur) - hours())},
              _Secs{_CHRONO duration_cast<_CHRONO seconds>(_CHRONO abs(_Dur) - hours() - minutes())} {
            // clang-format on
            if constexpr (treat_as_floating_point_v<typename precision::rep>) {
                _Sub_secs = _CHRONO abs(_Dur) - hours() - minutes() - seconds();
            } else {
                _Sub_secs = _CHRONO duration_cast<precision>(_CHRONO abs(_Dur) - hours() - minutes() - seconds());
            }
        }

        _NODISCARD constexpr bool is_negative() const noexcept {
            return _Is_neg;
        }
        _NODISCARD constexpr hours hours() const noexcept {
            return _Hours;
        }
        _NODISCARD constexpr minutes minutes() const noexcept {
            return _Mins;
        }
        _NODISCARD constexpr seconds seconds() const noexcept {
            return _Secs;
        }
        _NODISCARD constexpr precision subseconds() const noexcept {
            return _Sub_secs;
        }

        _NODISCARD constexpr explicit operator precision() const noexcept {
            return to_duration();
        }
        _NODISCARD constexpr precision to_duration() const noexcept {
            const auto _Dur = _Hours + _Mins + _Secs + _Sub_secs;
            return _Is_neg ? -_Dur : _Dur;
        }

    private:
        bool _Is_neg;
        _CHRONO hours _Hours;
        _CHRONO minutes _Mins;
        _CHRONO seconds _Secs;
        precision _Sub_secs;
    };

    _NODISCARD constexpr bool is_am(const hours& _Hours) noexcept {
        return _Hours >= hours{0} && _Hours <= hours{11};
    }
    _NODISCARD constexpr bool is_pm(const hours& _Hours) noexcept {
        return _Hours >= hours{12} && _Hours <= hours{23};
    }

    _NODISCARD constexpr hours make12(const hours& _Hours) noexcept {
        const auto _H_count{_Hours.count()};
        auto _Ret{_H_count == 0 ? 12 : _H_count};
        if (_Ret > 12) {
            _Ret -= 12;
        }

        return hours{_Ret};
    }
    _NODISCARD constexpr hours make24(const hours& _Hours, bool _Is_pm) noexcept {
        const auto _H_count{_Hours.count()};
        auto _Ret{_H_count == 12 ? 0 : _H_count};
        if (_Is_pm) {
            _Ret += 12;
        }

        return hours{_Ret};
    }

    // [time.zone.info]

    // STRUCT sys_info
    struct sys_info {
        sys_seconds begin;
        sys_seconds end;
        seconds offset;
        minutes save;
        string abbrev;
    };

    // STRUCT local_info
    struct local_info {
        static constexpr int unique      = 0;
        static constexpr int nonexistent = 1;
        static constexpr int ambiguous   = 2;

        int result;
        sys_info first;
        sys_info second;
    };

    // CLASS nonexistent_local_time
    class nonexistent_local_time : public runtime_error {
    public:
        template <class Duration>
        explicit nonexistent_local_time(const local_time<Duration>&, const local_info&)
            : runtime_error("TRANSITION: work in progress") {}
    };

    // CLASS ambiguous_local_time
    class ambiguous_local_time : public runtime_error {
    public:
        template <class Duration>
        explicit ambiguous_local_time(const local_time<Duration>&, const local_info&)
            : runtime_error("TRANSITION: work in progress") {}
    };

    // [time.zone.timezone]

    // ENUM CLASS choose
    enum class choose { earliest, latest };

    // CLASS time_zone
    class time_zone {
    public:
        explicit time_zone(string_view _Name_) : _Name(_Name_) {}

        time_zone(time_zone&&) = default;
        time_zone& operator=(time_zone&&) = default;

        _NODISCARD string_view name() const noexcept {
            return _Name;
        }

        template <class _Duration>
        _NODISCARD sys_info get_info(const sys_time<_Duration>& _Sys) const {
            return _Get_info(_Sys.time_since_epoch());
        }

        template <class _Duration>
        _NODISCARD local_info get_info(const local_time<_Duration>& _Local) const {
            local_info _Info{};
            _Info.first = _Get_info(_Local.time_since_epoch());

            const sys_seconds _Local_sys{duration_cast<sys_seconds::duration>(_Local.time_since_epoch())};
            const auto _Curr_sys = _Local_sys - _Info.first.offset;
            if (_Info.first.begin != _Min_seconds && _Curr_sys < _Info.first.begin + days{1}) {
                // get previous transition information
                _Info.second = get_info(_Info.first.begin - seconds{1});

                const auto _Transition = _Info.first.begin;
                const auto _Prev_sys   = _Local_sys - _Info.second.offset;
                if (_Curr_sys >= _Transition) {
                    if (_Prev_sys < _Transition) {
                        _Info.result = local_info::ambiguous;
                        std::swap(_Info.first, _Info.second);
                    } else {
                        _Info.result = local_info::unique;
                        _Info.second = {};
                    }
                } else {
                    if (_Prev_sys >= _Transition) {
                        _Info.result = local_info::nonexistent;
                        std::swap(_Info.first, _Info.second);
                    } else {
                        _Info.result = local_info::unique;
                        _Info.first  = std::move(_Info.second);
                        _Info.second = {};
                    }
                }
            } else if (_Info.first.end != _Max_seconds && _Curr_sys > _Info.first.end - days{1}) {
                // get next transition information
                _Info.second = get_info(_Info.first.end + seconds{1});

                const auto _Transition = _Info.first.end;
                const auto _Next_sys   = _Local_sys - _Info.second.offset;
                if (_Curr_sys < _Transition) {
                    if (_Next_sys >= _Transition) {
                        _Info.result = local_info::ambiguous;
                    } else {
                        _Info.result = local_info::unique;
                        _Info.second = {};
                    }
                } else {
                    if (_Next_sys < _Transition) {
                        _Info.result = local_info::nonexistent;
                    } else {
                        _Info.result = local_info::unique;
                        _Info.first  = std::move(_Info.second);
                        _Info.second = {};
                    }
                }
            } else {
                // local time is contained inside of first transition boundaries by at least 1 day
                _Info.result = local_info::unique;
                _Info.second = {};
            }

            return _Info;
        }

        template <class _Duration>
        _NODISCARD sys_time<common_type_t<_Duration, seconds>> to_sys(const local_time<_Duration>& _Local) const {
            auto _Info = get_info(_Local);
            if (_Info.result == local_info::nonexistent) {
                throw nonexistent_local_time(_Local, _Info);
            } else if (_Info.result == local_info::ambiguous) {
                throw ambiguous_local_time(_Local, _Info);
            }

            return sys_time<common_type_t<_Duration, seconds>>{_Local.time_since_epoch()} - _Info.first.offset;
        }

        template <class _Duration>
        _NODISCARD sys_time<common_type_t<_Duration, seconds>> to_sys(
            const local_time<_Duration>& _Local, choose _Choose) const {
            auto _Info   = get_info(_Local);
            auto _Result = sys_time<_Duration>{_Local.time_since_epoch()};
            if (_Info.result == local_info::nonexistent) {
                return _Info.first.end;
            }

            auto _Offset = (_Info.result == local_info::unique || _Choose == choose::earliest) ? _Info.first.offset
                                                                                               : _Info.second.offset;
            return sys_time<common_type_t<_Duration, seconds>>{_Local.time_since_epoch()} - _Offset;
        }

        template <class _Duration>
        _NODISCARD local_time<common_type_t<_Duration, seconds>> to_local(const sys_time<_Duration>& _Sys) const {
            auto _Info = get_info(_Sys);
            return local_time<common_type_t<_Duration, seconds>>{(_Sys + _Info.offset).time_since_epoch()};
        }

        // FIXME: year::max() + year::min()
        static constexpr sys_seconds _Min_seconds{sys_days{year{-32767} / January / 1}};
        static constexpr sys_seconds _Max_seconds{sys_days{year{32767} / December / 31}};

    private:
        template <class _Duration>
        _NODISCARD sys_info _Get_info(const _Duration& _Dur) const {
            using _Internal_duration = duration<__std_tzdb_epoch_milli, std::milli>;
            auto _Internal_dur       = duration_cast<_Internal_duration>(_Dur);
            std::unique_ptr<__std_tzdb_sys_info, decltype(&__std_tzdb_delete_sys_info)> _Info(
                __std_tzdb_get_sys_info(_Name.c_str(), _Name.length(), _Internal_dur.count()),
                &__std_tzdb_delete_sys_info);
            if (_Info == nullptr) {
                _Xbad_alloc();
            } else if (_Info->_Err == __std_tzdb_error::_Win_error) {
                _XGetLastError();
            } else if (_Info->_Err == __std_tzdb_error::_Icu_error) {
                _Xruntime_error("Internal error loading IANA database information");
            }

            static constexpr auto _Min_internal =
                duration_cast<_Internal_duration>(_Min_seconds.time_since_epoch()).count();
            static constexpr auto _Max_internal =
                duration_cast<_Internal_duration>(_Max_seconds.time_since_epoch()).count();
            return {.begin = _Info->_Begin <= _Min_internal
                               ? _Min_seconds
                               : sys_seconds{duration_cast<sys_seconds::duration>(_Internal_duration{_Info->_Begin})},
                .end       = _Info->_End >= _Max_internal
                               ? _Max_seconds
                               : sys_seconds{duration_cast<sys_seconds::duration>(_Internal_duration{_Info->_End})},
                .offset    = duration_cast<seconds>(_Internal_duration{_Info->_Offset}),
                .save      = duration_cast<minutes>(_Internal_duration{_Info->_Save}),
                .abbrev    = std::string{_Info->_Abbrev}};
        }

        string _Name;
    };

    _NODISCARD inline bool operator==(const time_zone& _Left, const time_zone& _Right) noexcept {
        return _Left.name() == _Right.name();
    }

#ifdef __cpp_lib_concepts
    _NODISCARD inline strong_ordering operator<=>(const time_zone& _Left, const time_zone& _Right) noexcept {
        return _Left.name() <=> _Right.name();
    }
#endif // __cpp_lib_concepts

    // [time.zone.leap]

    // CLASS leap_second
    class leap_second {
    public:
        leap_second(const leap_second&) = default;
        leap_second& operator=(const leap_second&) = default;

        constexpr leap_second(
            const sys_seconds& _Date_, const bool _Is_positive_, const seconds& _Prev_elapsed) noexcept
            : _Date{_Date_}, _Is_positive{_Is_positive_} {
            _Elapsed_offset = _Prev_elapsed + value();
        }

        _NODISCARD constexpr sys_seconds date() const noexcept {
            return _Date;
        }

        _NODISCARD constexpr seconds value() const noexcept {
            return _Is_positive ? seconds{1} : seconds{-1};
        }

        _NODISCARD constexpr bool _Positive() const noexcept {
            return _Is_positive;
        }

        _NODISCARD constexpr seconds _Elapsed() const noexcept {
            return _Elapsed_offset;
        }

    private:
        sys_seconds _Date;
        bool _Is_positive;
        seconds _Elapsed_offset;
    };

    _NODISCARD constexpr bool operator==(const leap_second& _Left, const leap_second& _Right) noexcept {
        return _Left.date() == _Right.date();
    }
    template <class _Duration>
    _NODISCARD constexpr bool operator==(const leap_second& _Left, const sys_time<_Duration>& _Right) noexcept {
        return _Left.date() == _Right;
    }

    template <class _Duration>
    _NODISCARD constexpr bool operator<(const leap_second& _Left, const sys_time<_Duration>& _Right) noexcept {
        return _Left.date() < _Right;
    }
    template <class _Duration>
    _NODISCARD constexpr bool operator<(const sys_time<_Duration>& _Left, const leap_second& _Right) noexcept {
        return _Left < _Right.date();
    }

    template <class _Duration>
    _NODISCARD constexpr bool operator>(const leap_second& _Left, const sys_time<_Duration>& _Right) noexcept {
        return _Right < _Left.date();
    }
    template <class _Duration>
    _NODISCARD constexpr bool operator>(const sys_time<_Duration>& _Left, const leap_second& _Right) noexcept {
        return _Right.date() < _Left;
    }

    template <class _Duration>
    _NODISCARD constexpr bool operator<=(const leap_second& _Left, const sys_time<_Duration>& _Right) noexcept {
        return !(_Right < _Left.date());
    }
    template <class _Duration>
    _NODISCARD constexpr bool operator<=(const sys_time<_Duration>& _Left, const leap_second& _Right) noexcept {
        return !(_Right.date() < _Left);
    }

    template <class _Duration>
    _NODISCARD constexpr bool operator>=(const leap_second& _Left, const sys_time<_Duration>& _Right) noexcept {
        return !(_Left.date() < _Right);
    }
    template <class _Duration>
    _NODISCARD constexpr bool operator>=(const sys_time<_Duration>& _Left, const leap_second& _Right) noexcept {
        return !(_Left < _Right.date());
    }

#ifdef __cpp_lib_concepts
    // clang-format off
    template <class _Duration>
        requires three_way_comparable_with<sys_seconds, sys_time<_Duration>>
    _NODISCARD constexpr auto operator<=>(
        const leap_second& _Left, const sys_time<_Duration>& _Right) noexcept {
        // clang-format on
        return _Left.date() <=> _Right;
    }
    _NODISCARD constexpr strong_ordering operator<=>(const leap_second& _Left, const leap_second& _Right) noexcept {
        return _Left.date() <=> _Right.date();
    }
#endif // __cpp_lib_concepts

    // [time.zone.link]

    // CLASS time_zone_link
    class time_zone_link {
    public:
        explicit time_zone_link(string_view _Name_, string_view _Target_) : _Name(_Name_), _Target(_Target_) {}

        time_zone_link(time_zone_link&&) = default;
        time_zone_link& operator=(time_zone_link&&) = default;

        _NODISCARD string_view name() const noexcept {
            return _Name;
        }

        _NODISCARD string_view target() const noexcept {
            return _Target;
        }

    private:
        string _Name;
        string _Target;
    };

    _NODISCARD inline bool operator==(const time_zone_link& _Left, const time_zone_link& _Right) noexcept {
        return _Left.name() == _Right.name();
    }

#ifdef __cpp_lib_concepts
    _NODISCARD inline strong_ordering operator<=>(const time_zone_link& _Left, const time_zone_link& _Right) noexcept {
        return _Left.name() <=> _Right.name();
    }
#endif // __cpp_lib_concepts

    // [time.zone.db]

    _NODISCARD inline string _Xtzdb_generate_current_zone() {
        unique_ptr<__std_tzdb_current_zone_info, decltype(&__std_tzdb_delete_current_zone)> _Info{
            __std_tzdb_get_current_zone(), &__std_tzdb_delete_current_zone};
        if (_Info == nullptr) {
            _Xbad_alloc();
        } else if (_Info->_Err == __std_tzdb_error::_Win_error) {
            _XGetLastError();
        } else if (_Info->_Err == __std_tzdb_error::_Icu_error) {
            _Xruntime_error("Internal error loading IANA database information");
        }

        return {_Info->_Tz_name};
    }

    template <class _Ty>
    _NODISCARD const _Ty* _Locate_zone_impl(const vector<_Ty>& _Vec, string_view _Name) {
        const auto _Result = _STD find_if(_Vec.begin(), _Vec.end(), [&](auto& _Tz) { return _Tz.name() == _Name; });
        return _Result == _Vec.end() ? nullptr : &*_Result;
    }

    // STRUCT  tzdb
    struct tzdb {
        string version;
        vector<time_zone> zones;
        vector<time_zone_link> links;
        vector<leap_second> leap_seconds;
        bool _All_ls_positive;

        _NODISCARD const time_zone* locate_zone(string_view _Tz_name) const {
            auto _Tz = _Locate_zone_impl(zones, _Tz_name);
            if (_Tz == nullptr) {
                const auto _Link = _Locate_zone_impl(links, _Tz_name);
                if (_Link != nullptr) {
                    _Tz = _Locate_zone_impl(zones, _Link->target());
                }
            }

            if (_Tz == nullptr) {
                _Xruntime_error("unable to locate time_zone with given name");
            }

            return _Tz;
        }

        _NODISCARD const time_zone* current_zone() const {
            return locate_zone(_Xtzdb_generate_current_zone());
        }
    };

    _NODISCARD inline tuple<string, decltype(tzdb::zones), decltype(tzdb::links)> _Xtzdb_generate_time_zones() {
        unique_ptr<__std_tzdb_time_zones_info, decltype(&__std_tzdb_delete_time_zones)> _Info{
            __std_tzdb_get_time_zones(), &__std_tzdb_delete_time_zones};
        if (_Info == nullptr) {
            _Xbad_alloc();
        } else if (_Info->_Err == __std_tzdb_error::_Win_error) {
            _XGetLastError();
        } else if (_Info->_Err == __std_tzdb_error::_Icu_error) {
            _Xruntime_error("Internal error loading IANA database information");
        }

        decltype(tzdb::zones) _Time_zones;
        decltype(tzdb::links) _Time_zone_links;
        for (size_t _Idx = 0; _Idx < _Info->_Num_time_zones; ++_Idx) {
            const string_view _Name{_Info->_Names[_Idx]};
            if (_Info->_Links[_Idx] == nullptr) {
                _Time_zones.emplace_back(_Name);
            } else {
                const string_view _Target{_Info->_Links[_Idx]};
                _Time_zone_links.emplace_back(_Name, _Target);
            }
        }

        return {_Info->_Version, _STD move(_Time_zones), _STD move(_Time_zone_links)};
    }

    _NODISCARD inline pair<decltype(tzdb::leap_seconds), bool> _Xtzdb_generate_leap_seconds(
        const size_t _Current_size) {
        // Returns empty vector if no new leap seconds are found.
        static constexpr leap_second _Known_leap_seconds[]{
            {sys_seconds{seconds{78796800}}, true, seconds{0}},
            {sys_seconds{seconds{94694400}}, true, seconds{1}},
            {sys_seconds{seconds{126230400}}, true, seconds{2}},
            {sys_seconds{seconds{157766400}}, true, seconds{3}},
            {sys_seconds{seconds{189302400}}, true, seconds{4}},
            {sys_seconds{seconds{220924800}}, true, seconds{5}},
            {sys_seconds{seconds{252460800}}, true, seconds{6}},
            {sys_seconds{seconds{283996800}}, true, seconds{7}},
            {sys_seconds{seconds{315532800}}, true, seconds{8}},
            {sys_seconds{seconds{362793600}}, true, seconds{9}},
            {sys_seconds{seconds{394329600}}, true, seconds{10}},
            {sys_seconds{seconds{425865600}}, true, seconds{11}},
            {sys_seconds{seconds{489024000}}, true, seconds{12}},
            {sys_seconds{seconds{567993600}}, true, seconds{13}},
            {sys_seconds{seconds{631152000}}, true, seconds{14}},
            {sys_seconds{seconds{662688000}}, true, seconds{15}},
            {sys_seconds{seconds{709948800}}, true, seconds{16}},
            {sys_seconds{seconds{741484800}}, true, seconds{17}},
            {sys_seconds{seconds{773020800}}, true, seconds{18}},
            {sys_seconds{seconds{820454400}}, true, seconds{19}},
            {sys_seconds{seconds{867715200}}, true, seconds{20}},
            {sys_seconds{seconds{915148800}}, true, seconds{21}},
            {sys_seconds{seconds{1136073600}}, true, seconds{22}},
            {sys_seconds{seconds{1230768000}}, true, seconds{23}},
            {sys_seconds{seconds{1341100800}}, true, seconds{24}},
            {sys_seconds{seconds{1435708800}}, true, seconds{25}},
            {sys_seconds{seconds{1483228800}}, true, seconds{26}},
        };

        // __std_tzdb_get_reg_leap_seconds gets leap second (LS) data from the registry, but only if it contains more
        // LSs than we already know about. The registry only contains LSs after 2018, so we need to tell it how many of
        // *those* we already know about. The *total* number of LSs known at this point is a combination of what the
        // caller knows (_Current_size, 0 on first call) and the _Known_leap_seconds entries.
        constexpr size_t _Pre_2018_count = 27;
        const size_t _Known_post_2018_ls_size =
            (_STD max)(_Current_size, _STD size(_Known_leap_seconds)) - _Pre_2018_count;

        size_t _Reg_post_2018_ls_size; // number of post-2018 LSs found in the registry
        unique_ptr<__std_tzdb_registry_leap_info[], decltype(&__std_tzdb_delete_reg_leap_seconds)> _Reg_ls_data{
            __std_tzdb_get_reg_leap_seconds(_Known_post_2018_ls_size, &_Reg_post_2018_ls_size),
            &__std_tzdb_delete_reg_leap_seconds};

        if (_Reg_post_2018_ls_size > _Known_post_2018_ls_size && !_Reg_ls_data) {
            _Xbad_alloc(); // registry has new data, but failed to allocate storage
        } else if (_Reg_post_2018_ls_size == 0 && _Reg_ls_data) {
            _XGetLastError(); // allocated storage for registry data, but failed to read
        }

        const size_t _New_size = _Pre_2018_count + _Reg_post_2018_ls_size; // total size with registry data
        decltype(tzdb::leap_seconds) _Leap_sec_info;
        bool _All_ls_positive = true;

        if (_New_size > _Current_size) {
            _Leap_sec_info.reserve(_New_size);
            _Leap_sec_info.insert(
                _Leap_sec_info.begin(), _STD cbegin(_Known_leap_seconds), _STD cend(_Known_leap_seconds));

            for (size_t _Idx = 0; _Idx < _Reg_post_2018_ls_size; ++_Idx) {
                // Leap seconds occur at _Ls._Hour:59:59. We store the next second after, so we need to add an entire
                // hour.
                const auto& _Ls = _Reg_ls_data[_Idx];
                const auto _Date =
                    static_cast<sys_days>(year_month_day{year{_Ls._Year}, month{_Ls._Month}, day{_Ls._Day}})
                    + hours{_Ls._Hour + 1};
                _Leap_sec_info.emplace_back(_Date, !_Ls._Negative, _Leap_sec_info.back()._Elapsed());
                _All_ls_positive = _All_ls_positive && !_Ls._Negative;
            }
        }

        return {_STD move(_Leap_sec_info), _All_ls_positive};
    }

    // TRANSITION: work in progress
    // CLASS tzdb_list
    class tzdb_list {
    private:
        using _ListType = forward_list<tzdb, _Crt_allocator<tzdb>>;

    public:
        using const_iterator = _ListType::const_iterator;

        tzdb_list(const tzdb_list&) = delete;
        tzdb_list& operator=(const tzdb_list&) = delete;

        tzdb_list() {
            auto [_Version, _Zones, _Links]    = _Xtzdb_generate_time_zones();
            auto [_Leap_sec, _All_ls_positive] = _Xtzdb_generate_leap_seconds(0);
            _Tzdb_list.emplace_front(tzdb{
                _STD move(_Version), _STD move(_Zones), _STD move(_Links), _STD move(_Leap_sec), _All_ls_positive});
        }

        _NODISCARD const tzdb& front() const noexcept {
            _Shared_lock _Lk(_Tzdb_mutex);
            return _Tzdb_list.front();
        }

        template <class... _ArgsTy>
        void _Emplace_front(_ArgsTy&&... _Args) {
            _Unique_lock _Lk(_Tzdb_mutex);
            _Tzdb_list.emplace_front(_STD forward<_ArgsTy>(_Args)...);
        }

        const tzdb& _Reload() {
            _Unique_lock _Lk(_Tzdb_mutex);
            auto [_Leap_sec, _All_ls_positive] = _Xtzdb_generate_leap_seconds(_Tzdb_list.front().leap_seconds.size());
            if (!_Leap_sec.empty()) {
                const auto& _Tzdb = _Tzdb_list.front();
                vector<time_zone> _Zones;
                _STD transform(_Tzdb.zones.begin(), _Tzdb.zones.end(), _STD back_inserter(_Zones),
                    [](const auto& _Tz) { return time_zone{_Tz.name()}; });
                vector<time_zone_link> _Links;
                _STD transform(
                    _Tzdb.links.begin(), _Tzdb.links.end(), _STD back_inserter(_Links), [](const auto& _Link) {
                        return time_zone_link{_Link.name(), _Link.target()};
                    });
                _Tzdb_list.emplace_front(
                    tzdb{_Tzdb.version, _STD move(_Zones), _STD move(_Links), _STD move(_Leap_sec), _All_ls_positive});
            }
            return _Tzdb_list.front();
        }

    private:
        _ListType _Tzdb_list;
        mutable _Smtx_t _Tzdb_mutex = {};

        struct _NODISCARD _Shared_lock {
            explicit _Shared_lock(_Smtx_t& _Mtx_) : _Mtx{&_Mtx_} {
                _Smtx_lock_shared(_Mtx);
            }

            _Shared_lock(const _Shared_lock&) = delete;
            _Shared_lock& operator=(const _Shared_lock&) = delete;

            void _Unlock() {
                if (_Owns) {
                    _Smtx_unlock_shared(_Mtx);
                }
                _Owns = false;
            }

            ~_Shared_lock() {
                if (_Owns) {
                    _Smtx_unlock_shared(_Mtx);
                }
            }

            _Smtx_t* _Mtx;
            bool _Owns = true;
        };

        struct _NODISCARD _Unique_lock {
            explicit _Unique_lock(_Smtx_t& _Mtx_) : _Mtx{&_Mtx_} {
                _Smtx_lock_exclusive(_Mtx);
            }

            _Unique_lock(const _Unique_lock&) = delete;
            _Unique_lock& operator=(const _Unique_lock&) = delete;

            ~_Unique_lock() {
                _Smtx_unlock_exclusive(_Mtx);
            }

            _Smtx_t* _Mtx;
        };
    };

    inline atomic<tzdb_list*> _Global_tzdb_list;

    // FUNCTION get_tzdb_list
    _NODISCARD inline tzdb_list& get_tzdb_list() {
        auto* _Tzdb_ptr = _Global_tzdb_list.load();
        if (_Tzdb_ptr == nullptr) {
            auto _My_tzdb = static_cast<tzdb_list*>(__std_calloc_crt(1, sizeof(tzdb_list)));
            if (_My_tzdb == nullptr) {
                _Xruntime_error("bad allocation");
            }

            try {
                _STD construct_at(_My_tzdb);
            } catch (const exception& _Except) {
                _Xruntime_error(_Except.what());
            }

            if (_Global_tzdb_list.compare_exchange_strong(_Tzdb_ptr, _My_tzdb)) {
                _Tzdb_ptr = _My_tzdb;
            } else {
                _STD destroy_at(_My_tzdb);
                __std_free_crt(_My_tzdb);
            }
        }

        return *_Tzdb_ptr;
    }

    // FUNCTION get_tzdb
    _NODISCARD inline const tzdb& get_tzdb() {
        return _CHRONO get_tzdb_list().front();
    }

    // FUNCTION reload_tzdb
    inline const tzdb& reload_tzdb() {
        try {
            return _CHRONO get_tzdb_list()._Reload();
        } catch (const exception& _Except) {
            _Xruntime_error(_Except.what());
        }
    }

    // [time.clock.utc]

    class utc_clock;
    template <class _Duration>
    using utc_time    = time_point<utc_clock, _Duration>;
    using utc_seconds = utc_time<seconds>;

    // STRUCT leap_second_info
    struct leap_second_info {
        bool is_leap_second;
        seconds elapsed;
    };

    // FUNCTION TEMPLATE get_leap_second_info
    template <class _Duration>
    _NODISCARD leap_second_info get_leap_second_info(const utc_time<_Duration>& _Time) {
        const utc_seconds _Time_floor = _CHRONO floor<seconds>(_Time);
        const auto& _Tzdb             = _CHRONO get_tzdb();
        const auto& _Ls_vector        = _Tzdb.leap_seconds;

        // Find first leap second after _Time.
        vector<leap_second>::const_iterator _It;
        if (_Tzdb._All_ls_positive) {
            // Where "target_ls" is the next leap second at or after _Time, _It either points to:
            //    (1) The 2nd leap second after _Time if _Time_floor is in the range [target_ls - _Elapsed() - 1,
            //    target_ls), or
            //    (2) The leap second just after _Time otherwise.
            // Note that we can always use prev(_It) to determine whether _Time is *during* a leap second insertion,
            // since that falls under case (2) above. However, when we fall under case (1), we need to execute an
            // additional decrement to get the correct elapsed offset. For example, if leap seconds are inserted at
            // seconds {100, 200, 300, 400}, we have:
            //
            //  UTC   sys   *_It
            //   99    99    100
            //  100     X    200
            //  101   100    200
            //  102   101    200
            //  ...
            //  199   198    200
            //  200   199    300^
            //  201     X    300
            //  202   200    300
            //  ...
            //  299   297    300
            //  300   298    400^
            //  301   299    400^
            //  302     X    400
            //  303   300    400
            //
            //  ^_It points to 2nd leap second

            _It = _STD upper_bound(_Ls_vector.begin(), _Ls_vector.end(), sys_seconds{_Time_floor.time_since_epoch()});
        } else {
            seconds _Prev_elapsed{0};
            for (_It = _Ls_vector.begin(); _It != _Ls_vector.end(); ++_It) {
                // UTC time when leap second insertion begins. In all cases, _It->date() + _It->_Elapsed() is the *end*
                // of the insertion. For a negative leap that's also the beginning, but for a positive one, insertion
                // begins 1 second earlier.
                const utc_seconds _This_ls_begin{
                    _It->date().time_since_epoch() + (_It->_Positive() ? _Prev_elapsed : _It->_Elapsed())};
                if (_This_ls_begin > _Time_floor) {
                    break;
                }
                _Prev_elapsed = _It->_Elapsed();
            }
        }

        if (_It == _Ls_vector.begin()) {
            return {false, seconds{0}};
        } else {
            // Convert to the last leap second before or equal to _Time.
            const auto& _Last_leap = *--_It;
            const utc_seconds _Utc_leap_second{_Last_leap.date().time_since_epoch() + _It->_Elapsed() - seconds{1}};
#ifdef __cpp_lib_concepts
            const auto _Leap_cmp = _Utc_leap_second <=> _Time_floor;
#else // ^^^ __cpp_lib_concepts / TRANSITION, GH-395 workaround vvv
            const auto _Leap_cmp = _Utc_leap_second > _Time_floor  ? strong_ordering::greater
                                 : _Utc_leap_second == _Time_floor ? strong_ordering::equal
                                                                   : strong_ordering::less;
#endif // ^^^ workaround
            if (_Tzdb._All_ls_positive && _STD is_gt(_Leap_cmp)) { // Case (1)
                --_It;
            }
            return {_Last_leap._Positive() && _STD is_eq(_Leap_cmp), _It->_Elapsed()};
        }
    }

    // CLASS utc_clock
    class utc_clock {
    public:
        using rep                       = system_clock::rep;
        using period                    = system_clock::period;
        using duration                  = duration<rep, period>;
        using time_point                = time_point<utc_clock>;
        static constexpr bool is_steady = system_clock::is_steady;

        _NODISCARD static time_point now() {
            return from_sys(system_clock::now());
        }

        template <class _Duration>
        _NODISCARD static sys_time<common_type_t<_Duration, seconds>> to_sys(const utc_time<_Duration>& _Utc_time) {
            using _CommonType = common_type_t<_Duration, seconds>;
            const auto _Lsi{get_leap_second_info(_Utc_time)};
            _CommonType _Ticks;
            if (_Lsi.is_leap_second) {
                const auto _Leap_sec_minus_one = _CHRONO floor<seconds>(_Utc_time.time_since_epoch()) - _Lsi.elapsed;
                if constexpr (is_integral_v<typename _Duration::rep>) {
                    constexpr auto _Delta{seconds{1} - _CommonType{1}};
                    _Ticks = _Leap_sec_minus_one + _Delta;
                } else {
                    const auto _Leap_sec_begin = _CHRONO ceil<_CommonType>(_Leap_sec_minus_one + seconds{1});
                    _Ticks = _CommonType{_STD nextafter(_Leap_sec_begin.count(), typename _CommonType::rep{0})};
                }
            } else {
                _Ticks = _Utc_time.time_since_epoch() - _Lsi.elapsed;
            }
            return sys_time<_CommonType>{_Ticks};
        }

        template <class _Duration>
        _NODISCARD static utc_time<common_type_t<_Duration, seconds>> from_sys(const sys_time<_Duration>& _Sys_time) {
            const auto& _Tzdb      = _CHRONO get_tzdb();
            const auto& _Ls_vector = _Tzdb.leap_seconds;
            auto _It = _STD upper_bound(_Ls_vector.begin(), _Ls_vector.end(), _CHRONO floor<seconds>(_Sys_time));
            const auto _Offset = _It == _Ls_vector.begin() ? seconds{0} : (--_It)->_Elapsed();
            return utc_time<common_type_t<_Duration, seconds>>{_Sys_time.time_since_epoch() + _Offset};
        }
    };

    // [time.clock.tai]

    class tai_clock;

    template <class _Duration>
    using tai_time    = time_point<tai_clock, _Duration>;
    using tai_seconds = tai_time<seconds>;

    // CLASS tai_clock
    class tai_clock {
    public:
        using rep                       = system_clock::rep;
        using period                    = system_clock::period;
        using duration                  = duration<rep, period>;
        using time_point                = time_point<tai_clock>;
        static constexpr bool is_steady = system_clock::is_steady;

        static constexpr seconds _Tai_epoch_adjust{378691210};

        _NODISCARD static time_point now() noexcept(noexcept(utc_clock::now())) {
            return from_utc(utc_clock::now());
        }

        template <class _Duration>
        _NODISCARD static utc_time<common_type_t<_Duration, seconds>> to_utc(
            const tai_time<_Duration>& _Time) noexcept {
            return utc_time<common_type_t<_Duration, seconds>>{_Time.time_since_epoch()} - _Tai_epoch_adjust;
        }

        template <class _Duration>
        _NODISCARD static tai_time<common_type_t<_Duration, seconds>> from_utc(
            const utc_time<_Duration>& _Time) noexcept {
            return tai_time<common_type_t<_Duration, seconds>>{_Time.time_since_epoch()} + _Tai_epoch_adjust;
        }
    };

    // [time.clock.gps]

    class gps_clock;

    template <class _Duration>
    using gps_time    = time_point<gps_clock, _Duration>;
    using gps_seconds = gps_time<seconds>;

    // CLASS gps_clock
    class gps_clock {
    public:
        using rep                       = system_clock::rep;
        using period                    = system_clock::period;
        using duration                  = chrono::duration<rep, period>;
        using time_point                = chrono::time_point<gps_clock>;
        static constexpr bool is_steady = system_clock::is_steady;

        static constexpr seconds _Gps_epoch_adjust{-315964809};

        _NODISCARD static time_point now() noexcept(noexcept(utc_clock::now())) {
            return from_utc(utc_clock::now());
        }

        template <class _Duration>
        _NODISCARD static utc_time<common_type_t<_Duration, seconds>> to_utc(
            const gps_time<_Duration>& _Time) noexcept {
            return utc_time<common_type_t<_Duration, seconds>>{_Time.time_since_epoch()} - _Gps_epoch_adjust;
        }

        template <class _Duration>
        _NODISCARD static gps_time<common_type_t<_Duration, seconds>> from_utc(
            const utc_time<_Duration>& _Time) noexcept {
            return gps_time<common_type_t<_Duration, seconds>>{_Time.time_since_epoch()} + _Gps_epoch_adjust;
        }
    };
#endif // ^^^ _HAS_CXX20
} // namespace chrono

// [time.clock.file]

#if _HAS_CXX20
namespace filesystem {
    struct _File_time_clock;
} // namespace filesystem

namespace chrono {
    // ALIAS file_clock
    using file_clock = filesystem::_File_time_clock;

    template <class _Duration>
    using file_time = time_point<file_clock, _Duration>;
} // namespace chrono
#endif // ^^^ _HAS_CXX20

#if _HAS_CXX17
namespace filesystem {
    inline constexpr long long __std_fs_file_time_epoch_adjustment = 0x19DB1DED53E8000LL; // TRANSITION, ABI

    struct _File_time_clock { // Implementation of trivial-clock
        using rep                       = long long;
        using period                    = chrono::system_clock::period;
        using duration                  = chrono::duration<rep, period>;
        using time_point                = chrono::time_point<_File_time_clock>;
        static constexpr bool is_steady = false;

        _NODISCARD static time_point now() noexcept { // get current time; undo epoch adjustment
            return time_point(duration(_Xtime_get_ticks() + __std_fs_file_time_epoch_adjustment)); // TRANSITION, ABI
        }

#if _HAS_CXX20
        // Assumes that FILETIME counts leap seconds only after the first 27 (i.e., after 1 January 2017), even though
        // systems can opt out of this behavior.
        static constexpr chrono::seconds _Skipped_filetime_leap_seconds{27};
        static constexpr chrono::sys_days _Cutoff{
            chrono::year_month_day{chrono::year{2017}, chrono::January, chrono::day{1}}};

        template <class _Duration>
        _NODISCARD static chrono::utc_time<common_type_t<_Duration, chrono::seconds>> to_utc(
            const chrono::file_time<_Duration>& _File_time) {
            using namespace chrono;
            using _CommonType = common_type_t<_Duration, seconds>;
            const auto _Ticks =
                _File_time.time_since_epoch() - duration_cast<seconds>(duration{__std_fs_file_time_epoch_adjustment});

            if (_Ticks < _Cutoff.time_since_epoch()) {
                return utc_clock::from_sys(sys_time<_CommonType>{_Ticks});
            } else {
                return utc_time<_CommonType>{_Ticks + _Skipped_filetime_leap_seconds};
            }
        }

        template <class _Duration>
        _NODISCARD static chrono::file_time<common_type_t<_Duration, chrono::seconds>> from_utc(
            const chrono::utc_time<_Duration>& _Utc_time) {
            using namespace chrono;
            file_time<common_type_t<_Duration, seconds>> _File_time{
                duration_cast<seconds>(duration{__std_fs_file_time_epoch_adjustment})};

            if (_Utc_time < utc_seconds{_Cutoff.time_since_epoch()} + _Skipped_filetime_leap_seconds) {
                _File_time += utc_clock::to_sys(_Utc_time).time_since_epoch();
            } else {
                _File_time += _Utc_time.time_since_epoch() - _Skipped_filetime_leap_seconds;
            }

            return _File_time;
        }
#endif // ^^^ _HAS_CXX20
    };
} // namespace filesystem
#endif // ^^^ _HAS_CXX17

namespace chrono {
#if _HAS_CXX20
    // [time.clock.conv]

    // STRUCT TEMPLATE clock_time_conversion
    template <class _DestClock, class _SourceClock>
    struct clock_time_conversion {};

    // [time.clock.cast.id]

    template <class _Clock>
    struct clock_time_conversion<_Clock, _Clock> {
        template <class _Duration>
        _NODISCARD time_point<_Clock, _Duration> operator()(const time_point<_Clock, _Duration>& _Time) const
            noexcept(is_arithmetic_v<typename _Duration::rep>) /* strengthened */ {
            return _Time;
        }
    };

    template <>
    struct clock_time_conversion<system_clock, system_clock> {
        template <class _Duration>
        _NODISCARD sys_time<_Duration> operator()(const sys_time<_Duration>& _Time) const
            noexcept(is_arithmetic_v<typename _Duration::rep>) /* strengthened */ {
            return _Time;
        }
    };

    template <>
    struct clock_time_conversion<utc_clock, utc_clock> {
        template <class _Duration>
        _NODISCARD utc_time<_Duration> operator()(const utc_time<_Duration>& _Time) const
            noexcept(is_arithmetic_v<typename _Duration::rep>) /* strengthened */ {
            return _Time;
        }
    };

    // [time.clock.cast.sys.utc]

    template <>
    struct clock_time_conversion<utc_clock, system_clock> {
        template <class _Duration>
        _NODISCARD utc_time<common_type_t<_Duration, seconds>> operator()(const sys_time<_Duration>& _Sys_time) const {
            return utc_clock::from_sys(_Sys_time);
        }
    };

    template <>
    struct clock_time_conversion<system_clock, utc_clock> {
        template <class _Duration>
        _NODISCARD sys_time<common_type_t<_Duration, seconds>> operator()(const utc_time<_Duration>& _Utc_time) const {
            return utc_clock::to_sys(_Utc_time);
        }
    };

    // [time.clock.cast.sys]

    // TRANSITION, GH-395 workaround, is_same_v -> same_as
    template <class _Ty, class _Clock>
    concept _Is_time_point = requires {
        typename _Ty::duration;
        requires is_same_v<time_point<_Clock, typename _Ty::duration>, _Ty>;
    };

    template <class _Clock, class _Duration>
    concept _Convertible_to_sys_time =
        is_same_v<_Clock, system_clock> || requires(const time_point<_Clock, _Duration>& _Time) {
        { _Clock::to_sys(_Time) }
        ->_Is_time_point<system_clock>;
    };

    template <class _Clock, class _Duration>
    concept _Convertible_from_sys_time = is_same_v<_Clock, system_clock> || requires(const sys_time<_Duration>& _Time) {
        { _Clock::from_sys(_Time) }
        ->_Is_time_point<_Clock>;
    };

    template <class _SourceClock>
    struct clock_time_conversion<system_clock, _SourceClock> {
        template <class _Duration>
        _NODISCARD auto operator()(const time_point<_SourceClock, _Duration>& _Time) const
            noexcept(noexcept(_SourceClock::to_sys(_Time))) /* strengthened */
            requires _Convertible_to_sys_time<_SourceClock, _Duration> {
            return _SourceClock::to_sys(_Time);
        }
    };

    template <class _DestClock>
    struct clock_time_conversion<_DestClock, system_clock> {
        template <class _Duration>
        _NODISCARD auto operator()(const sys_time<_Duration>& _Time) const
            noexcept(noexcept(_DestClock::from_sys(_Time))) /* strengthened */
            requires _Convertible_from_sys_time<_DestClock, _Duration> {
            return _DestClock::from_sys(_Time);
        }
    };

    // [time.clock.cast.utc]

    template <class _Clock, class _Duration>
    concept _Convertible_to_utc_time =
        is_same_v<_Clock, utc_clock> || requires(const time_point<_Clock, _Duration>& _Time) {
        { _Clock::to_utc(_Time) }
        ->_Is_time_point<utc_clock>;
    };

    template <class _Clock, class _Duration>
    concept _Convertible_from_utc_time = is_same_v<_Clock, utc_clock> || requires(const utc_time<_Duration>& _Time) {
        { _Clock::from_utc(_Time) }
        ->_Is_time_point<_Clock>;
    };

    template <class _SourceClock>
    struct clock_time_conversion<utc_clock, _SourceClock> {
        template <class _Duration>
        _NODISCARD auto operator()(const time_point<_SourceClock, _Duration>& _Time) const
            noexcept(noexcept(_SourceClock::to_utc(_Time))) /* strengthened */
            requires _Convertible_to_utc_time<_SourceClock, _Duration> {
            return _SourceClock::to_utc(_Time);
        }
    };

    template <class _DestClock>
    struct clock_time_conversion<_DestClock, utc_clock> {
        template <class _Duration>
        _NODISCARD auto operator()(const utc_time<_Duration>& _Time) const
            noexcept(noexcept(_DestClock::from_utc(_Time))) /* strengthened */
            requires _Convertible_from_utc_time<_DestClock, _Duration> {
            return _DestClock::from_utc(_Time);
        }
    };

    // [time.clock.cast.fn]

    // FUNCTION TEMPLATE clock_cast
    template <class _DestClock, class _SourceClock, class _Duration>
    _NODISCARD auto clock_cast(const time_point<_SourceClock, _Duration>& _Time) {
        constexpr bool _Has_direct_conversion =
            is_invocable_v<clock_time_conversion<_DestClock, _SourceClock>, decltype(_Time)>;

        constexpr bool _Utc_from_src  = _Convertible_to_utc_time<_SourceClock, _Duration>;
        constexpr bool _Sys_from_src  = _Convertible_to_sys_time<_SourceClock, _Duration>;
        constexpr bool _Dest_from_utc = _Convertible_from_utc_time<_DestClock, _Duration>;
        constexpr bool _Dest_from_sys = _Convertible_from_sys_time<_DestClock, _Duration>;

        constexpr bool _Has_utc_conversion = _Dest_from_utc && _Utc_from_src;
        constexpr bool _Has_sys_conversion = _Dest_from_sys && _Sys_from_src;
        static_assert(_Has_direct_conversion || !(_Has_utc_conversion && _Has_sys_conversion),
            "A two-step clock time conversion is required to be unique, either through utc_clock or system_clock, but "
            "not both (N4878 [time.clock.cast.fn]/2.)");

        constexpr bool _Has_sys_utc_conversion = _Dest_from_sys && _Utc_from_src;
        constexpr bool _Has_utc_sys_conversion = _Dest_from_utc && _Sys_from_src;
        static_assert(_Has_direct_conversion || _Has_utc_conversion || _Has_sys_conversion
                          || !(_Has_utc_sys_conversion && _Has_sys_utc_conversion),
            "A three-step clock time conversion is required to be unique, either utc-to-system or system-to-utc, but "
            "not both (N4878 [time.clock.cast.fn]/2).");

        // clang-format off
        if constexpr (_Has_direct_conversion) {
            return clock_time_conversion<_DestClock, _SourceClock>{}(_Time);
        } else if constexpr (_Has_utc_conversion) {
            return clock_time_conversion<_DestClock, utc_clock>{}(
                     clock_time_conversion<utc_clock, _SourceClock>{}(_Time));
        } else if constexpr (_Has_sys_conversion) {
            return clock_time_conversion<_DestClock, system_clock>{}(
                     clock_time_conversion<system_clock, _SourceClock>{}(_Time));
        } else if constexpr (_Has_sys_utc_conversion) {
            return clock_time_conversion<_DestClock, system_clock>{}(
                     clock_time_conversion<system_clock, utc_clock>{}(
                       clock_time_conversion<utc_clock, _SourceClock>{}(_Time)));
        } else if constexpr (_Has_utc_sys_conversion) {
            return clock_time_conversion<_DestClock, utc_clock>{}(
                     clock_time_conversion<utc_clock, system_clock>{}(
                       clock_time_conversion<system_clock, _SourceClock>{}(_Time)));
        } else {
            static_assert(_Always_false<_Duration>, "No clock time conversion exists from source clock type to "
                                                    "destination clock type (N4878 [time.clock.cast.fn]/1).");
        }
        // clang-format on
    }
#endif // _HAS_CXX20
} // namespace chrono

// HELPERS
template <class _Rep, class _Period>
_NODISCARD bool _To_xtime_10_day_clamped(_CSTD xtime& _Xt, const _CHRONO duration<_Rep, _Period>& _Rel_time) noexcept(
    is_arithmetic_v<_Rep>) {
    // Convert duration to xtime, maximum 10 days from now, returns whether clamping occurred.
    // If clamped, timeouts will be transformed into spurious non-timeout wakes, due to ABI restrictions where
    // the other side of the DLL boundary overflows int32_t milliseconds.
    // Every function calling this one is TRANSITION, ABI
    constexpr _CHRONO nanoseconds _Ten_days{_CHRONO hours{24} * 10};
    constexpr _CHRONO duration<double> _Ten_days_d{_Ten_days};
    _CHRONO nanoseconds _Tx0 = _CHRONO system_clock::now().time_since_epoch();
    const bool _Clamped      = _Ten_days_d < _Rel_time;
    if (_Clamped) {
        _Tx0 += _Ten_days;
    } else {
        _Tx0 += _CHRONO duration_cast<_CHRONO nanoseconds>(_Rel_time);
    }

    const auto _Whole_seconds = _CHRONO duration_cast<_CHRONO seconds>(_Tx0);
    _Xt.sec                   = _Whole_seconds.count();
    _Tx0 -= _Whole_seconds;
    _Xt.nsec = static_cast<long>(_Tx0.count());
    return _Clamped;
}

// duration LITERALS
inline namespace literals {
    inline namespace chrono_literals {
        _NODISCARD constexpr _CHRONO hours operator"" h(unsigned long long _Val) noexcept /* strengthened */ {
            return _CHRONO hours(_Val);
        }

        _NODISCARD constexpr _CHRONO duration<double, ratio<3600>> operator"" h(long double _Val) noexcept
        /* strengthened */ {
            return _CHRONO duration<double, ratio<3600>>(_Val);
        }

        _NODISCARD constexpr _CHRONO minutes(operator"" min)(unsigned long long _Val) noexcept /* strengthened */ {
            return _CHRONO minutes(_Val);
        }

        _NODISCARD constexpr _CHRONO duration<double, ratio<60>>(operator"" min)(long double _Val) noexcept
        /* strengthened */ {
            return _CHRONO duration<double, ratio<60>>(_Val);
        }

        _NODISCARD constexpr _CHRONO seconds operator"" s(unsigned long long _Val) noexcept /* strengthened */ {
            return _CHRONO seconds(_Val);
        }

        _NODISCARD constexpr _CHRONO duration<double> operator"" s(long double _Val) noexcept /* strengthened */ {
            return _CHRONO duration<double>(_Val);
        }

        _NODISCARD constexpr _CHRONO milliseconds operator"" ms(unsigned long long _Val) noexcept /* strengthened */ {
            return _CHRONO milliseconds(_Val);
        }

        _NODISCARD constexpr _CHRONO duration<double, milli> operator"" ms(long double _Val) noexcept
        /* strengthened */ {
            return _CHRONO duration<double, milli>(_Val);
        }

        _NODISCARD constexpr _CHRONO microseconds operator"" us(unsigned long long _Val) noexcept /* strengthened */ {
            return _CHRONO microseconds(_Val);
        }

        _NODISCARD constexpr _CHRONO duration<double, micro> operator"" us(long double _Val) noexcept
        /* strengthened */ {
            return _CHRONO duration<double, micro>(_Val);
        }

        _NODISCARD constexpr _CHRONO nanoseconds operator"" ns(unsigned long long _Val) noexcept /* strengthened */ {
            return _CHRONO nanoseconds(_Val);
        }

        _NODISCARD constexpr _CHRONO duration<double, nano> operator"" ns(long double _Val) noexcept
        /* strengthened */ {
            return _CHRONO duration<double, nano>(_Val);
        }
#if _HAS_CXX20
        _NODISCARD constexpr _CHRONO day operator"" d(unsigned long long _Day) noexcept {
            return _CHRONO day{static_cast<unsigned int>(_Day)};
        }
        _NODISCARD constexpr _CHRONO year operator"" y(unsigned long long _Year) noexcept {
            return _CHRONO year{static_cast<int>(_Year)};
        }
#endif // _HAS_CXX20
    } // namespace chrono_literals
} // namespace literals

namespace chrono {
    using namespace literals::chrono_literals;
} // namespace chrono

_STD_END
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _CHRONO_
