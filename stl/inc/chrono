// chrono standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _CHRONO_
#define _CHRONO_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR
#include <limits>
#include <ratio>
#include <time.h>
#include <utility>
#include <xtimec.h>

#if _HAS_CXX20
#include <compare>
#endif // _HAS_CXX20

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
namespace chrono {
    // STRUCT TEMPLATE treat_as_floating_point
    template <class _Rep>
    struct treat_as_floating_point : is_floating_point<_Rep> {}; // tests for floating-point type

    template <class _Rep>
    _INLINE_VAR constexpr bool treat_as_floating_point_v = treat_as_floating_point<_Rep>::value;

    // STRUCT TEMPLATE duration_values
    template <class _Rep>
    struct duration_values { // gets arithmetic properties of a type
        _NODISCARD static constexpr _Rep zero() noexcept {
            // get zero value
            return _Rep(0);
        }

        _NODISCARD static constexpr _Rep(min)() noexcept {
            // get smallest value
            return numeric_limits<_Rep>::lowest();
        }

        _NODISCARD static constexpr _Rep(max)() noexcept {
            // get largest value
            return (numeric_limits<_Rep>::max)();
        }
    };

    // CLASS TEMPLATE duration
    template <class _Rep, class _Period = ratio<1>>
    class duration;

    // VARIABLE TEMPLATE _Is_duration_v
    template <class _Ty>
    _INLINE_VAR constexpr bool _Is_duration_v = _Is_specialization_v<_Ty, duration>;

    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> = 0>
    constexpr _To duration_cast(const duration<_Rep, _Period>&) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>); // strengthened

    template <class _Rep, class _Period>
    class duration { // represents a time duration
    public:
        using rep    = _Rep;
        using period = typename _Period::type;

        static_assert(!_Is_duration_v<_Rep>, "duration can't have duration as first template argument");
        static_assert(_Is_ratio_v<_Period>, "period not an instance of std::ratio");
        static_assert(0 < _Period::num, "period negative or zero");

        constexpr duration() = default;

        template <class _Rep2,
            enable_if_t<is_convertible_v<const _Rep2&,
                            _Rep> && (treat_as_floating_point_v<_Rep> || !treat_as_floating_point_v<_Rep2>),
                int> = 0>
        constexpr explicit duration(const _Rep2& _Val) noexcept(
            is_arithmetic_v<_Rep>&& is_arithmetic_v<_Rep2>) // strengthened
            : _MyRep(static_cast<_Rep>(_Val)) {}

        template <class _Rep2, class _Period2,
            enable_if_t<
                treat_as_floating_point_v<
                    _Rep> || (_Ratio_divide_sfinae<_Period2, _Period>::den == 1 && !treat_as_floating_point_v<_Rep2>),
                int> = 0>
        constexpr duration(const duration<_Rep2, _Period2>& _Dur) noexcept(
            is_arithmetic_v<_Rep>&& is_arithmetic_v<_Rep2>) // strengthened
            : _MyRep(chrono::duration_cast<duration>(_Dur).count()) {}

        _NODISCARD constexpr _Rep count() const noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            return _MyRep;
        }

        _NODISCARD constexpr common_type_t<duration> operator+() const
            noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            return common_type_t<duration>(*this);
        }

        _NODISCARD constexpr common_type_t<duration> operator-() const
            noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            return common_type_t<duration>(-_MyRep);
        }

        _CONSTEXPR17 duration& operator++() noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            ++_MyRep;
            return *this;
        }

        _CONSTEXPR17 duration operator++(int) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            return duration(_MyRep++);
        }

        _CONSTEXPR17 duration& operator--() noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            --_MyRep;
            return *this;
        }

        _CONSTEXPR17 duration operator--(int) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            return duration(_MyRep--);
        }

        _CONSTEXPR17 duration& operator+=(const duration& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            _MyRep += _Right._MyRep;
            return *this;
        }

        _CONSTEXPR17 duration& operator-=(const duration& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            _MyRep -= _Right._MyRep;
            return *this;
        }

        _CONSTEXPR17 duration& operator*=(const _Rep& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            _MyRep *= _Right;
            return *this;
        }

        _CONSTEXPR17 duration& operator/=(const _Rep& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            _MyRep /= _Right;
            return *this;
        }

        _CONSTEXPR17 duration& operator%=(const _Rep& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            _MyRep %= _Right;
            return *this;
        }

        _CONSTEXPR17 duration& operator%=(const duration& _Right) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
            _MyRep %= _Right.count();
            return *this;
        }

        _NODISCARD static constexpr duration zero() noexcept {
            // get zero value
            return duration(duration_values<_Rep>::zero());
        }

        _NODISCARD static constexpr duration(min)() noexcept {
            // get minimum value
            return duration((duration_values<_Rep>::min)());
        }

        _NODISCARD static constexpr duration(max)() noexcept {
            // get maximum value
            return duration((duration_values<_Rep>::max)());
        }

    private:
        _Rep _MyRep; // the stored rep
    };

    template <class _Clock, class _Duration = typename _Clock::duration>
    class time_point { // represents a point in time
    public:
        using clock    = _Clock;
        using duration = _Duration;
        using rep      = typename _Duration::rep;
        using period   = typename _Duration::period;

        static_assert(_Is_duration_v<_Duration>, "duration must be an instance of std::duration");

        constexpr time_point() = default;

        constexpr explicit time_point(const _Duration& _Other) noexcept(is_arithmetic_v<rep>) // strengthened
            : _MyDur(_Other) {}

        template <class _Duration2, enable_if_t<is_convertible_v<_Duration2, _Duration>, int> = 0>
        constexpr time_point(const time_point<_Clock, _Duration2>& _Tp) noexcept(
            is_arithmetic_v<rep>&& is_arithmetic_v<typename _Duration2::rep>) // strengthened
            : _MyDur(_Tp.time_since_epoch()) {}

        _NODISCARD constexpr _Duration time_since_epoch() const noexcept(is_arithmetic_v<rep>) /* strengthened */ {
            return _MyDur;
        }

#if _HAS_CXX20
        constexpr time_point& operator++() {
            ++_MyDur;
            return *this;
        }
        constexpr time_point operator++(int) {
            return time_point{_MyDur++};
        }
        constexpr time_point& operator--() {
            --_MyDur;
            return *this;
        }
        constexpr time_point operator--(int) {
            return time_point{_MyDur--};
        }
#endif // _HAS_CXX20

        _CONSTEXPR17 time_point& operator+=(const _Duration& _Dur) noexcept(is_arithmetic_v<rep>) /* strengthened */ {
            _MyDur += _Dur;
            return *this;
        }

        _CONSTEXPR17 time_point& operator-=(const _Duration& _Dur) noexcept(is_arithmetic_v<rep>) /* strengthened */ {
            _MyDur -= _Dur;
            return *this;
        }

        _NODISCARD static constexpr time_point(min)() noexcept {
            return time_point((_Duration::min)());
        }

        _NODISCARD static constexpr time_point(max)() noexcept {
            return time_point((_Duration::max)());
        }

    private:
        _Duration _MyDur{duration::zero()}; // duration since the epoch
    };
} // namespace chrono

// STRUCT TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
template <intmax_t _Ax, intmax_t _Bx>
struct _Lcm : integral_constant<intmax_t, (_Ax / _Gcd<_Ax, _Bx>::value) * _Bx> {}; // compute LCM of _Ax and _Bx

// STRUCT TEMPLATE common_type SPECIALIZATIONS
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct common_type<chrono::duration<_Rep1, _Period1>,
    chrono::duration<_Rep2, _Period2>> { // common type of two durations
    using type = chrono::duration<common_type_t<_Rep1, _Rep2>,
        ratio<_Gcd<_Period1::num, _Period2::num>::value, _Lcm<_Period1::den, _Period2::den>::value>>;
};

template <class _Clock, class _Duration1, class _Duration2>
struct common_type<chrono::time_point<_Clock, _Duration1>,
    chrono::time_point<_Clock, _Duration2>> { // common type of two time points
    using type = chrono::time_point<_Clock, common_type_t<_Duration1, _Duration2>>;
};

namespace chrono {
    // duration ARITHMETIC
    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>
        operator+(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_CD(_Left).count() + _CD(_Right).count());
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>
        operator-(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_CD(_Left).count() - _CD(_Right).count());
    }

    template <class _Rep1, class _Period1, class _Rep2,
        enable_if_t<is_convertible_v<const _Rep2&, common_type_t<_Rep1, _Rep2>>, int> = 0>
    _NODISCARD constexpr duration<common_type_t<_Rep1, _Rep2>, _Period1> operator*(
        const duration<_Rep1, _Period1>& _Left,
        const _Rep2& _Right) noexcept(is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CR = common_type_t<_Rep1, _Rep2>;
        using _CD = duration<_CR, _Period1>;
        return _CD(_CD(_Left).count() * _Right);
    }

    template <class _Rep1, class _Rep2, class _Period2,
        enable_if_t<is_convertible_v<const _Rep1&, common_type_t<_Rep1, _Rep2>>, int> = 0>
    _NODISCARD constexpr duration<common_type_t<_Rep1, _Rep2>, _Period2>
        operator*(const _Rep1& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        return _Right * _Left;
    }

    template <class _CR, class _Period1, class _Rep2, bool = is_convertible_v<const _Rep2&, _CR>>
    struct _Duration_div_mod1 { // return type for duration / rep and duration % rep
        using type = duration<_CR, _Period1>;
    };

    template <class _CR, class _Period1, class _Rep2>
    struct _Duration_div_mod1<_CR, _Period1, _Rep2, false> {}; // no return type

    template <class _CR, class _Period1, class _Rep2, bool = _Is_duration_v<_Rep2>>
    struct _Duration_div_mod {}; // no return type

    template <class _CR, class _Period1, class _Rep2>
    struct _Duration_div_mod<_CR, _Period1, _Rep2, false> : _Duration_div_mod1<_CR, _Period1, _Rep2> {
        // return type for duration / rep and duration % rep
    };

    template <class _Rep1, class _Period1, class _Rep2>
    _NODISCARD constexpr typename _Duration_div_mod<common_type_t<_Rep1, _Rep2>, _Period1, _Rep2>::type operator/(
        const duration<_Rep1, _Period1>& _Left,
        const _Rep2& _Right) noexcept(is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CR = common_type_t<_Rep1, _Rep2>;
        using _CD = duration<_CR, _Period1>;
        return _CD(_CD(_Left).count() / _Right);
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr common_type_t<_Rep1, _Rep2>
        operator/(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_Left).count() / _CD(_Right).count();
    }

    template <class _Rep1, class _Period1, class _Rep2>
    _NODISCARD constexpr typename _Duration_div_mod<common_type_t<_Rep1, _Rep2>, _Period1, _Rep2>::type operator%(
        const duration<_Rep1, _Period1>& _Left,
        const _Rep2& _Right) noexcept(is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CR = common_type_t<_Rep1, _Rep2>;
        using _CD = duration<_CR, _Period1>;
        return _CD(_CD(_Left).count() % _Right);
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>
        operator%(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_CD(_Left).count() % _CD(_Right).count());
    }

    // duration COMPARISONS
    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr bool
        operator==(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CT(_Left).count() == _CT(_Right).count();
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr bool
        operator!=(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        return !(_Left == _Right);
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr bool
        operator<(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CT(_Left).count() < _CT(_Right).count();
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr bool
        operator<=(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        return !(_Right < _Left);
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr bool
        operator>(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        return _Right < _Left;
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    _NODISCARD constexpr bool
        operator>=(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>) /* strengthened */ {
        return !(_Left < _Right);
    }

    // FUNCTION TEMPLATE duration_cast
    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> _Enabled>
    _NODISCARD constexpr _To duration_cast(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // convert duration to another duration; truncate
        using _CF = ratio_divide<_Period, typename _To::period>;

        using _ToRep = typename _To::rep;
        using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;

        constexpr bool _Num_is_one = _CF::num == 1;
        constexpr bool _Den_is_one = _CF::den == 1;

        if (_Den_is_one) {
            if (_Num_is_one) {
                return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));
            } else {
                return static_cast<_To>(
                    static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
            }
        } else {
            if (_Num_is_one) {
                return static_cast<_To>(
                    static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
            } else {
                return static_cast<_To>(static_cast<_ToRep>(
                    static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
            }
        }
    }

    // FUNCTION TEMPLATE floor
    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> = 0>
    _NODISCARD constexpr _To floor(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // convert duration to another duration; round towards negative infinity
        // i.e. the greatest integral result such that the result <= _Dur
        const _To _Casted{chrono::duration_cast<_To>(_Dur)};
        if (_Casted > _Dur) {
            return _To{_Casted.count() - static_cast<typename _To::rep>(1)};
        }

        return _Casted;
    }

    // FUNCTION TEMPLATE ceil
    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> = 0>
    _NODISCARD constexpr _To ceil(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // convert duration to another duration; round towards positive infinity
        // i.e. the least integral result such that _Dur <= the result
        const _To _Casted{chrono::duration_cast<_To>(_Dur)};
        if (_Casted < _Dur) {
            return _To{_Casted.count() + static_cast<typename _To::rep>(1)};
        }

        return _Casted;
    }

    // FUNCTION TEMPLATE round
    template <class _Rep>
    constexpr bool _Is_even(_Rep _Val) noexcept(is_arithmetic_v<_Rep>) /* strengthened */ {
        // Tests whether _Val is even
        return _Val % 2 == 0;
    }

    template <class _To, class _Rep, class _Period,
        enable_if_t<_Is_duration_v<_To> && !treat_as_floating_point_v<typename _To::rep>, int> = 0>
    _NODISCARD constexpr _To round(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // convert duration to another duration, round to nearest, ties to even
        const _To _Floored{chrono::floor<_To>(_Dur)};
        const _To _Ceiled{_Floored + _To{1}};
        const auto _Floor_adjustment = _Dur - _Floored;
        const auto _Ceil_adjustment  = _Ceiled - _Dur;
        if (_Floor_adjustment < _Ceil_adjustment
            || (_Floor_adjustment == _Ceil_adjustment && _Is_even(_Floored.count()))) {
            return _Floored;
        }

        return _Ceiled;
    }

    // FUNCTION TEMPLATE abs
    template <class _Rep, class _Period, enable_if_t<numeric_limits<_Rep>::is_signed, int> = 0>
    _NODISCARD constexpr duration<_Rep, _Period> abs(const duration<_Rep, _Period> _Dur) noexcept(
        is_arithmetic_v<_Rep>) /* strengthened */ {
        // create a duration with count() the absolute value of _Dur.count()
        return _Dur < duration<_Rep, _Period>::zero() ? duration<_Rep, _Period>::zero() - _Dur : _Dur;
    }

    // duration TYPES
    using nanoseconds  = duration<long long, nano>;
    using microseconds = duration<long long, micro>;
    using milliseconds = duration<long long, milli>;
    using seconds      = duration<long long>;
    using minutes      = duration<int, ratio<60>>;
    using hours        = duration<int, ratio<3600>>;
#if _HAS_CXX20
    using days   = duration<int, ratio_multiply<ratio<24>, hours::period>>;
    using weeks  = duration<int, ratio_multiply<ratio<7>, days::period>>;
    using years  = duration<int, ratio_multiply<ratio<146097, 400>, days::period>>;
    using months = duration<int, ratio_divide<years::period, ratio<12>>>;
#endif // _HAS_CXX20

    // time_point ARITHMETIC
    template <class _Clock, class _Duration, class _Rep, class _Period>
    _NODISCARD constexpr time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>
        operator+(const time_point<_Clock, _Duration>& _Left, const duration<_Rep, _Period>& _Right) noexcept(
            is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<_Rep>) /* strengthened */ {
        using _RT = time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>;
        return _RT(_Left.time_since_epoch() + _Right);
    }

    template <class _Rep, class _Period, class _Clock, class _Duration>
    _NODISCARD constexpr time_point<_Clock, common_type_t<duration<_Rep, _Period>, _Duration>>
        operator+(const duration<_Rep, _Period>& _Left, const time_point<_Clock, _Duration>& _Right) noexcept(
            is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _Duration::rep>) /* strengthened */ {
        return _Right + _Left;
    }

    template <class _Clock, class _Duration, class _Rep, class _Period>
    _NODISCARD constexpr time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>
        operator-(const time_point<_Clock, _Duration>& _Left, const duration<_Rep, _Period>& _Right) noexcept(
            is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<_Rep>) /* strengthened */ {
        using _RT = time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>;
        return _RT(_Left.time_since_epoch() - _Right);
    }

    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr common_type_t<_Duration1, _Duration2>
        operator-(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return _Left.time_since_epoch() - _Right.time_since_epoch();
    }

    // time_point COMPARISONS
    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr bool
        operator==(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return _Left.time_since_epoch() == _Right.time_since_epoch();
    }

    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr bool
        operator!=(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return !(_Left == _Right);
    }

    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr bool
        operator<(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return _Left.time_since_epoch() < _Right.time_since_epoch();
    }

    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr bool
        operator<=(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return !(_Right < _Left);
    }

    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr bool
        operator>(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return _Right < _Left;
    }

    template <class _Clock, class _Duration1, class _Duration2>
    _NODISCARD constexpr bool
        operator>=(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>) /* strengthened */ {
        return !(_Left < _Right);
    }

    // FUNCTION TEMPLATE time_point_cast
    template <class _To, class _Clock, class _Duration, enable_if_t<_Is_duration_v<_To>, int> = 0>
    _NODISCARD constexpr time_point<_Clock, _To> time_point_cast(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // change the duration type of a time_point; truncate
        return time_point<_Clock, _To>(chrono::duration_cast<_To>(_Time.time_since_epoch()));
    }

    // FUNCTION TEMPLATE floor (for time_point instances)
    template <class _To, class _Clock, class _Duration, enable_if_t<_Is_duration_v<_To>, int> = 0>
    _NODISCARD constexpr time_point<_Clock, _To> floor(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // change the duration type of a time_point; round towards negative infinity
        return time_point<_Clock, _To>(chrono::floor<_To>(_Time.time_since_epoch()));
    }

    // FUNCTION TEMPLATE ceil (for time_point instances)
    template <class _To, class _Clock, class _Duration, enable_if_t<_Is_duration_v<_To>, int> = 0>
    _NODISCARD constexpr time_point<_Clock, _To> ceil(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // change the duration type of a time_point; round towards positive infinity
        return time_point<_Clock, _To>(chrono::ceil<_To>(_Time.time_since_epoch()));
    }

    // FUNCTION TEMPLATE round (for time_point instances)
    template <class _To, class _Clock, class _Duration,
        enable_if_t<_Is_duration_v<_To> && !treat_as_floating_point_v<typename _To::rep>, int> = 0>
    _NODISCARD constexpr time_point<_Clock, _To> round(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>) /* strengthened */ {
        // change the duration type of a time_point; round to nearest, ties to even
        return time_point<_Clock, _To>(chrono::round<_To>(_Time.time_since_epoch()));
    }

    // CLOCKS
    struct system_clock { // wraps GetSystemTimePreciseAsFileTime/GetSystemTimeAsFileTime
        using rep = long long;

        using period = ratio_multiply<ratio<_XTIME_NSECS_PER_TICK, 1>, nano>;

        using duration                  = chrono::duration<rep, period>;
        using time_point                = chrono::time_point<system_clock>;
        static constexpr bool is_steady = false;

        _NODISCARD static time_point now() noexcept { // get current time
            return time_point(duration(_Xtime_get_ticks()));
        }

        _NODISCARD static __time64_t to_time_t(const time_point& _Time) noexcept { // convert to __time64_t
            return static_cast<__time64_t>(_Time.time_since_epoch().count() / _XTIME_TICKS_PER_TIME_T);
        }

        _NODISCARD static time_point from_time_t(__time64_t _Tm) noexcept { // convert from __time64_t
            return time_point(duration(_Tm * _XTIME_TICKS_PER_TIME_T));
        }
    };

#if _HAS_CXX20
    // SYS_TIME aliases
    template <class _Duration>
    using sys_time    = time_point<system_clock, _Duration>;
    using sys_seconds = sys_time<seconds>;
    using sys_days    = sys_time<days>;
#endif // _HAS_CXX20

    struct steady_clock { // wraps QueryPerformanceCounter
        using rep                       = long long;
        using period                    = nano;
        using duration                  = nanoseconds;
        using time_point                = chrono::time_point<steady_clock>;
        static constexpr bool is_steady = true;

        _NODISCARD static time_point now() noexcept { // get current time
            const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot
            const long long _Ctr  = _Query_perf_counter();
            static_assert(period::num == 1, "This assumes period::num == 1.");
            // Instead of just having "(_Ctr * period::den) / _Freq",
            // the algorithm below prevents overflow when _Ctr is sufficiently large.
            // It assumes that _Freq * period::den does not overflow, which is currently true for nano period.
            // It is not realistic for _Ctr to accumulate to large values from zero with this assumption,
            // but the initial value of _Ctr could be large.
            const long long _Whole = (_Ctr / _Freq) * period::den;
            const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;
            return time_point(duration(_Whole + _Part));
        }
    };

    using high_resolution_clock = steady_clock;

#if _HAS_CXX20
    struct local_t {};

    template <class _Duration>
    using local_time    = time_point<local_t, _Duration>;
    using local_seconds = local_time<seconds>;
    using local_days    = local_time<days>;

    struct last_spec {
        explicit last_spec() = default;
    };
    inline constexpr last_spec last{};

    class day {
    public:
        day() = default;
        constexpr explicit day(unsigned _Val) noexcept : _Day{static_cast<unsigned char>(_Val)} {}

        constexpr day& operator++() noexcept {
            ++_Day;
            return *this;
        }
        constexpr day operator++(int) noexcept {
            return day{_Day++};
        }
        constexpr day& operator--() noexcept {
            --_Day;
            return *this;
        }
        constexpr day operator--(int) noexcept {
            return day{_Day--};
        }

        constexpr day& operator+=(const days& _Days) noexcept {
            _Day += static_cast<unsigned char>(_Days.count());
            return *this;
        }
        constexpr day& operator-=(const days& _Days) noexcept {
            _Day -= static_cast<unsigned char>(_Days.count());
            return *this;
        }

        _NODISCARD constexpr explicit operator unsigned() const noexcept {
            return _Day;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Day >= 1 && _Day <= 31;
        }

    private:
        unsigned char _Day;
    };

    constexpr bool operator==(const day& _Left, const day& _Right) noexcept {
        return static_cast<unsigned>(_Left) == static_cast<unsigned>(_Right);
    }
    constexpr strong_ordering operator<=>(const day& _Left, const day& _Right) noexcept {
        return static_cast<unsigned>(_Left) <=> static_cast<unsigned>(_Right);
    }

    constexpr day operator+(const day& _Left, const days& _Right) noexcept {
        return day{static_cast<unsigned>(_Left) + _Right.count()};
    }
    constexpr day operator+(const days& _Left, const day& _Right) noexcept {
        return _Right + _Left;
    }
    constexpr day operator-(const day& _Left, const days& _Right) noexcept {
        return day{static_cast<unsigned>(_Left) - _Right.count()};
    }
    constexpr days operator-(const day& _Left, const day& _Right) noexcept {
        return days{static_cast<int>(static_cast<unsigned>(_Left)) - static_cast<int>(static_cast<unsigned>(_Right))};
    }

    class month {
    public:
        month() = default;
        constexpr explicit month(unsigned _Val) noexcept : _Month{static_cast<unsigned char>(_Val)} {}

        constexpr month& operator++() noexcept {
            *this += months{1};
            return *this;
        }
        constexpr month operator++(int) noexcept {
            month _Temp{*this};
            ++(*this);
            return _Temp;
        }
        constexpr month& operator--() noexcept {
            *this -= months{1};
            return *this;
        }
        constexpr month operator--(int) noexcept {
            month _Temp{*this};
            --(*this);
            return _Temp;
        }

        constexpr month& operator+=(const months& _Months) noexcept;
        constexpr month& operator-=(const months& _Months) noexcept;

        _NODISCARD constexpr explicit operator unsigned() const noexcept {
            return static_cast<unsigned>(_Month);
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Month >= 1 && _Month <= 12;
        }

    private:
        unsigned char _Month;
    };

    constexpr bool operator==(const month& _Left, const month& _Right) noexcept {
        return static_cast<unsigned>(_Left) == static_cast<unsigned>(_Right);
    }
    constexpr strong_ordering operator<=>(const month& _Left, const month& _Right) noexcept {
        return static_cast<unsigned>(_Left) <=> static_cast<unsigned>(_Right);
    }

    constexpr month operator+(const month& _Left, const months& _Right) noexcept {
        const auto _Mo  = static_cast<long long>(static_cast<unsigned>(_Left)) + (_Right.count() - 1);
        const auto _Div = (_Mo >= 0 ? _Mo : _Mo - 11) / 12;
        return month{static_cast<unsigned>(_Mo - _Div * 12 + 1)};
    }
    constexpr month operator+(const months& _Left, const month& _Right) noexcept {
        return _Right + _Left;
    }
    constexpr month operator-(const month& _Left, const months& _Right) noexcept {
        return _Left + -_Right;
    }
    constexpr months operator-(const month& _Left, const month& _Right) noexcept {
        const auto _Mo = static_cast<unsigned>(_Left) - static_cast<unsigned>(_Right);
        return months{_Mo <= 11 ? _Mo : _Mo + 12};
    }

    constexpr month& month::operator+=(const months& _Months) noexcept {
        *this = *this + _Months;
        return *this;
    }
    constexpr month& month::operator-=(const months& _Months) noexcept {
        *this = *this - _Months;
        return *this;
    }

    class year {
    public:
        year() = default;
        constexpr explicit year(int _Val) noexcept : _Year{static_cast<short>(_Val)} {}

        constexpr year& operator++() noexcept {
            ++_Year;
            return *this;
        }
        constexpr year operator++(int) noexcept {
            return year{_Year++};
        }
        constexpr year& operator--() noexcept {
            --_Year;
            return *this;
        }
        constexpr year operator--(int) noexcept {
            return year{_Year--};
        }

        constexpr year& operator+=(const years& _Years) noexcept {
            _Year += static_cast<short>(_Years.count());
            return *this;
        }
        constexpr year& operator-=(const years& _Years) noexcept {
            _Year -= static_cast<short>(_Years.count());
            return *this;
        }

        constexpr year operator+() const noexcept {
            return *this;
        }
        constexpr year operator-() const noexcept {
            return year{-_Year};
        }

        _NODISCARD constexpr bool is_leap() const noexcept {
            return _Year % 4 == 0 && (_Year % 100 != 0 || _Year % 400 == 0);
        }

        _NODISCARD constexpr explicit operator int() const noexcept {
            return static_cast<int>(_Year);
        }

        _NODISCARD constexpr bool ok() const noexcept {
            return _Year_min <= _Year && _Year <= _Year_max;
        }

        _NODISCARD static constexpr year(min)() noexcept {
            return year{_Year_min};
        }
        _NODISCARD static constexpr year(max)() noexcept {
            return year{_Year_max};
        }

    private:
        short _Year;
        static constexpr int _Year_min = -32767;
        static constexpr int _Year_max = 32767;
    };

    constexpr bool operator==(const year& _Left, const year& _Right) noexcept {
        return static_cast<int>(_Left) == static_cast<int>(_Right);
    }
    constexpr strong_ordering operator<=>(const year& _Left, const year& _Right) noexcept {
        return static_cast<int>(_Left) <=> static_cast<int>(_Right);
    }

    constexpr year operator+(const year& _Left, const years& _Right) noexcept {
        return year{static_cast<int>(_Left) + _Right.count()};
    }
    constexpr year operator+(const years& _Left, const year& _Right) noexcept {
        return _Right + _Left;
    }
    constexpr year operator-(const year& _Left, const years& _Right) noexcept {
        return _Left + -_Right;
    }
    constexpr years operator-(const year& _Left, const year& _Right) noexcept {
        return years{static_cast<int>(_Left) - static_cast<int>(_Right)};
    }

    class weekday {
    public:
        weekday() = default;
        constexpr explicit weekday(unsigned _Val) noexcept
            : _Weekday{static_cast<unsigned char>(_Val == 7 ? 0 : _Val)} {}
        constexpr weekday(const sys_days& _Sys_day) noexcept
            : _Weekday{static_cast<unsigned char>(_Weekday_from_days(_Sys_day.time_since_epoch().count()))} {}
        constexpr explicit weekday(const local_days& _Local_day) noexcept
            : _Weekday{static_cast<unsigned char>(_Weekday_from_days(_Local_day.time_since_epoch().count()))} {}

        constexpr weekday& operator++() noexcept {
            return *this += days{1};
        }
        constexpr weekday operator++(int) noexcept {
            weekday _Temp{*this};
            ++(*this);
            return _Temp;
        }
        constexpr weekday& operator--() noexcept {
            return *this -= days{1};
        }
        constexpr weekday operator--(int) noexcept {
            weekday _Temp{*this};
            --(*this);
            return _Temp;
        }

        constexpr weekday& operator+=(const days& _Days) noexcept;
        constexpr weekday& operator-=(const days& _Days) noexcept;

        _NODISCARD constexpr unsigned c_encoding() const noexcept {
            return _Weekday;
        }
        _NODISCARD constexpr unsigned iso_encoding() const noexcept {
            return _Weekday == 0u ? 7u : _Weekday;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Weekday <= 6;
        }

        _NODISCARD constexpr class weekday_indexed operator[](unsigned _Index) const noexcept;
        _NODISCARD constexpr class weekday_last operator[](last_spec) const noexcept;

    private:
        unsigned char _Weekday;

        // courtesy of Howard Hinnant
        // https://howardhinnant.github.io/date_algorithms.html#weekday_from_days
        _NODISCARD static constexpr unsigned _Weekday_from_days(int _Tp) noexcept {
            return static_cast<unsigned>(_Tp >= -4 ? (_Tp + 4) % 7 : (_Tp + 5) % 7 + 6);
        }
    };

    constexpr bool operator==(const weekday& _Left, const weekday& _Right) noexcept {
        return _Left.c_encoding() == _Right.c_encoding();
    }

    constexpr weekday operator+(const weekday& _Left, const days& _Right) noexcept {
        const auto _Wd  = static_cast<long long>(_Left.c_encoding()) + _Right.count();
        const auto _Div = (_Wd >= 0 ? _Wd : _Wd - 6) / 7;
        return weekday{static_cast<unsigned>(_Wd - _Div * 7)};
    }
    constexpr weekday operator+(const days& _Left, const weekday& _Right) noexcept {
        return _Right + _Left;
    }
    constexpr weekday operator-(const weekday& _Left, const days& _Right) noexcept {
        return _Left + -_Right;
    }
    constexpr days operator-(const weekday& _Left, const weekday& _Right) noexcept {
        const auto _Wd = _Left.c_encoding() - _Right.c_encoding();
        const auto _Wk = _Wd <= 6 ? _Wd : _Wd + 7;
        return days{_Wk};
    }

    constexpr weekday& weekday::operator+=(const days& _Days) noexcept {
        *this = *this + _Days;
        return *this;
    }
    constexpr weekday& weekday::operator-=(const days& _Days) noexcept {
        *this = *this - _Days;
        return *this;
    }

    class weekday_indexed {
    public:
        weekday_indexed() = default;
        constexpr weekday_indexed(const weekday& _Wd, unsigned _Idx) noexcept
            : _Weekday{_Wd}, _Index{static_cast<unsigned char>(_Idx)} {}

        _NODISCARD constexpr weekday weekday() const noexcept {
            return _Weekday;
        }
        _NODISCARD constexpr unsigned index() const noexcept {
            return _Index;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Weekday.ok() && _Index >= 1 && _Index <= 5;
        }

    private:
        weekday _Weekday;
        unsigned char _Index;
    };

    constexpr bool operator==(const weekday_indexed& _Left, const weekday_indexed& _Right) noexcept {
        return _Left.weekday() == _Right.weekday() && _Left.index() == _Right.index();
    }

    class weekday_last {
    public:
        constexpr explicit weekday_last(const weekday& _Wd) noexcept : _Weekday{_Wd} {}

        _NODISCARD constexpr weekday weekday() const noexcept {
            return _Weekday;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Weekday.ok();
        }

    private:
        weekday _Weekday;
    };

    constexpr bool operator==(const weekday_last& _Left, const weekday_last& _Right) noexcept {
        return _Left.weekday() == _Right.weekday();
    }

    // weekday
    constexpr weekday_indexed weekday::operator[](unsigned _Index) const noexcept {
        return {*this, _Index};
    }
    constexpr weekday_last weekday::operator[](last_spec) const noexcept {
        return weekday_last{*this};
    }

    class month_day {
    public:
        month_day() = default;
        constexpr month_day(const month& _M, const day& _D) noexcept : _Month{_M}, _Day{_D} {}

        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr day day() const noexcept {
            return _Day;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            if (!_Month.ok() || !_Day.ok()) {
                return false;
            }

            const auto _Da = static_cast<unsigned>(_Day);
            const auto _Mo = static_cast<unsigned>(_Month);
            if (_Mo == 2 && _Da > 29) {
                return false;
            }

            if (_Mo == 4 || _Mo == 6 || _Mo == 9 || _Mo == 11) {
                return _Da <= 30;
            }
            return true;
        }

    private:
        month _Month;
        day _Day;
    };

    constexpr bool operator==(const month_day& _Left, const month_day& _Right) noexcept {
        return _Left.month() == _Right.month() && _Left.day() == _Right.day();
    }
    constexpr strong_ordering operator<=>(const month_day& _Left, const month_day& _Right) noexcept {
        auto _Comp = _Left.month() <=> _Right.month();
        if (_Comp != 0) {
            return _Comp;
        }

        return _Left.day() <=> _Right.day();
    }

    class month_day_last {
    public:
        constexpr explicit month_day_last(const month& _M) noexcept : _Month{_M} {}

        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Month.ok();
        }

    private:
        month _Month;
    };

    constexpr bool operator==(const month_day_last& _Left, const month_day_last& _Right) noexcept {
        return _Left.month() == _Right.month();
    }
    constexpr strong_ordering operator<=>(const month_day_last& _Left, const month_day_last& _Right) noexcept {
        return _Left.month() <=> _Right.month();
    }

    class month_weekday {
    public:
        constexpr month_weekday(const month& _M, const weekday_indexed& _Wdi) noexcept
            : _Month{_M}, _Weekday_index{_Wdi} {}

        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr weekday_indexed weekday_indexed() const noexcept {
            return _Weekday_index;
        }

        _NODISCARD constexpr bool ok() const noexcept {
            return _Month.ok() && _Weekday_index.ok();
        }

    private:
        month _Month;
        weekday_indexed _Weekday_index;
    };

    constexpr bool operator==(const month_weekday& _Left, const month_weekday& _Right) noexcept {
        return _Left.month() == _Right.month() && _Left.weekday_indexed() == _Right.weekday_indexed();
    }

    class month_weekday_last {
    public:
        constexpr month_weekday_last(const month& _M, const weekday_last& _Wdl) noexcept
            : _Month{_M}, _Weekday_last{_Wdl} {}

        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr weekday_last weekday_last() const noexcept {
            return _Weekday_last;
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Month.ok() && _Weekday_last.ok();
        }

    private:
        month _Month;
        weekday_last _Weekday_last;
    };

    constexpr bool operator==(const month_weekday_last& _Left, const month_weekday_last& _Right) noexcept {
        return _Left.month() == _Right.month() && _Left.weekday_last() == _Right.weekday_last();
    }

    class year_month {
    public:
        year_month() = default;
        constexpr year_month(const year& _Y, const month& _M) noexcept : _Year{_Y}, _Month{_M} {}

        _NODISCARD constexpr year year() const noexcept {
            return _Year;
        }
        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }

        constexpr year_month& operator+=(const months& _Months) noexcept;
        constexpr year_month& operator-=(const months& _Months) noexcept;
        constexpr year_month& operator+=(const years& _Years) noexcept;
        constexpr year_month& operator-=(const years& _Years) noexcept;

        _NODISCARD constexpr bool ok() const noexcept {
            return _Year.ok() && _Month.ok();
        }

    private:
        year _Year;
        month _Month;
    };

    constexpr bool operator==(const year_month& _Left, const year_month& _Right) noexcept {
        return _Left.year() == _Right.year() && _Left.month() == _Right.month();
    }
    constexpr strong_ordering operator<=>(const year_month& _Left, const year_month& _Right) noexcept {
        auto _Comp = _Left.year() <=> _Right.year();
        if (_Comp != 0) {
            return _Comp;
        }

        return _Left.month() <=> _Right.month();
    }

    constexpr year_month operator+(const year_month& _Left, const months& _Right) noexcept {
        const auto _Mo  = static_cast<long long>(static_cast<unsigned>(_Left.month())) + (_Right.count() - 1);
        const auto _Div = (_Mo >= 0 ? _Mo : _Mo - 11) / 12;
        return year_month{_Left.year() + years{_Div}, month{static_cast<unsigned>(_Mo - _Div * 12 + 1)}};
    }
    constexpr year_month operator+(const months& _Left, const year_month& _Right) noexcept {
        return _Right + _Left;
    }

    constexpr year_month operator-(const year_month& _Left, const months& _Right) noexcept {
        return _Left + -_Right;
    }

    constexpr months operator-(const year_month& _Left, const year_month& _Right) noexcept {
        return _Left.year() - _Right.year()
               + months{static_cast<int>(static_cast<unsigned>(_Left.month()))
                        - static_cast<int>(static_cast<unsigned>(_Right.month()))};
    }

    constexpr year_month operator+(const year_month& _Left, const years& _Right) noexcept {
        return {year{_Left.year() + _Right}, _Left.month()};
    }

    constexpr year_month operator+(const years& _Left, const year_month& _Right) noexcept {
        return _Right + _Left;
    }

    constexpr year_month operator-(const year_month& _Left, const years& _Right) noexcept {
        return _Left + -_Right;
    }

    constexpr year_month& year_month::operator+=(const months& _Months) noexcept {
        *this = *this + _Months;
        return *this;
    }
    constexpr year_month& year_month::operator-=(const months& _Months) noexcept {
        *this = *this - _Months;
        return *this;
    }
    constexpr year_month& year_month::operator+=(const years& _Years) noexcept {
        *this = *this + _Years;
        return *this;
    }
    constexpr year_month& year_month::operator-=(const years& _Years) noexcept {
        *this = *this - _Years;
        return *this;
    }

    constexpr inline day _Last_day(const year& _Year, const month& _Month) {
        constexpr day _Days[] = {
            day{31}, day{28}, day{31}, day{30}, day{31}, day{30}, day{31}, day{31}, day{30}, day{31}, day{30}, day{31}};
        return _Month == month{2} && _Year.is_leap() ? _Days[static_cast<unsigned>(_Month) - 1] + days{1}
                                                     : _Days[static_cast<unsigned>(_Month) - 1];
    }

    class year_month_day {

    public:
        year_month_day() = default;
        constexpr year_month_day(const year& _Y, const month& _M, const day& _D) noexcept
            : _Year{_Y}, _Month{_M}, _Day{_D} {}
        constexpr year_month_day(const class year_month_day_last& _Ymdl) noexcept;
        constexpr year_month_day(const sys_days& _Sys_days) noexcept
            : year_month_day{_Civil_from_days(_Sys_days.time_since_epoch().count())} {}
        constexpr explicit year_month_day(const local_days& _Local_days) noexcept
            : year_month_day{_Civil_from_days(_Local_days.time_since_epoch().count())} {}

        constexpr year_month_day& operator+=(const months& _Months) noexcept;
        constexpr year_month_day& operator-=(const months& _Months) noexcept;
        constexpr year_month_day& operator+=(const years& _Years) noexcept;
        constexpr year_month_day& operator-=(const years& _Years) noexcept;

        _NODISCARD constexpr year year() const noexcept {
            return _Year;
        }
        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr day day() const noexcept {
            return _Day;
        }

        _NODISCARD constexpr operator sys_days() const noexcept {
            return sys_days{_Days_from_civil()};
        }
        _NODISCARD constexpr explicit operator local_days() const noexcept {
            return local_days{static_cast<sys_days>(*this).time_since_epoch()};
        }
        _NODISCARD constexpr bool ok() const noexcept {
            if (!_Year.ok() || !_Month.ok()) {
                return false;
            }

            return _Day >= day{1} && _Day <= _Last_day(_Year, _Month);
        }

    private:
        year _Year;
        month _Month;
        day _Day;
        // courtesy of Howard Hinnant
        // https://howardhinnant.github.io/date_algorithms.html#civil_from_days
        _NODISCARD static constexpr year_month_day _Civil_from_days(int _Tp) noexcept {
            static_assert(numeric_limits<unsigned>::digits >= 18);
            static_assert(numeric_limits<int>::digits >= 20);
            const int _Zx       = _Tp + 719468;
            const int _Era      = (_Zx >= 0 ? _Zx : _Zx - 146096) / 146097;
            const unsigned _Doe = static_cast<unsigned>(_Zx - _Era * 146097);
            const unsigned _Yoe = (_Doe - _Doe / 1460 + _Doe / 36524 - _Doe / 146096) / 365;
            const int _Ye       = static_cast<int>(_Yoe) + _Era * 400;
            const unsigned _Doy = _Doe - (365 * _Yoe + _Yoe / 4 - _Yoe / 100);
            const unsigned _Mp  = (5 * _Doy + 2) / 153;
            const unsigned _Da  = _Doy - (153 * _Mp + 2) / 5 + 1;
            const unsigned _Mo  = _Mp + (_Mp < 10 ? 3 : static_cast<unsigned>(-9));
            return year_month_day(year{_Ye + (_Mo <= 2)}, month{_Mo}, day{_Da});
        }
        // courtesy of Howard Hinnant
        // https://howardhinnant.github.io/date_algorithms.html#days_from_civil
        _NODISCARD constexpr days _Days_from_civil() const noexcept {
            static_assert(numeric_limits<unsigned>::digits >= 18);
            static_assert(numeric_limits<int>::digits >= 20);
            const int _Ye       = static_cast<int>(_Year) - (_Month <= month{2});
            const unsigned _Mo  = static_cast<unsigned>(_Month);
            const int _Era      = (_Ye >= 0 ? _Ye : _Ye - 399) / 400;
            const unsigned _Yoe = static_cast<unsigned>(_Ye - _Era * 400);
            const unsigned _Doy =
                (153 * (_Mo + (_Mo > 2 ? static_cast<unsigned>(-3) : 9)) + 2) / 5 + static_cast<unsigned>(_Day) - 1;
            const unsigned _Doe = _Yoe * 365 + _Yoe / 4 - _Yoe / 100 + _Doy;
            return days{_Era * 146097 + static_cast<int>(_Doe) - 719468};
        }
    };

    constexpr bool operator==(const year_month_day& _Left, const year_month_day& _Right) noexcept {
        return _Left.year() == _Right.year() && _Left.month() == _Right.month() && _Left.day() == _Right.day();
    }
    constexpr strong_ordering operator<=>(const year_month_day& _Left, const year_month_day& _Right) noexcept {
        auto _Comp = _Left.year() <=> _Right.year();
        if (_Comp != 0) {
            return _Comp;
        }

        _Comp = _Left.month() <=> _Right.month();
        if (_Comp != 0) {
            return _Comp;
        }

        return _Left.day() <=> _Right.day();
    }

    constexpr year_month_day operator+(const year_month_day& _Left, const months& _Right) noexcept {
        const auto _Ym = year_month{_Left.year(), _Left.month()} + _Right;
        return {_Ym.year(), _Ym.month(), _Left.day()};
    }

    constexpr year_month_day operator+(const months& _Left, const year_month_day& _Right) noexcept {
        return _Right + _Left;
    }

    constexpr year_month_day operator-(const year_month_day& _Left, const months& _Right) noexcept {
        return _Left + (-_Right);
    }

    constexpr year_month_day operator+(const year_month_day& _Left, const years& _Right) noexcept {
        return {_Left.year() + _Right, _Left.month(), _Left.day()};
    }

    constexpr year_month_day operator+(const years& _Left, const year_month_day& _Right) noexcept {
        return _Right + _Left;
    }

    constexpr year_month_day operator-(const year_month_day& _Left, const years& _Right) noexcept {
        return _Left + (-_Right);
    }

    constexpr year_month_day& year_month_day::operator+=(const months& _Months) noexcept {
        *this = *this + _Months;
        return *this;
    }
    constexpr year_month_day& year_month_day::operator-=(const months& _Months) noexcept {
        *this = *this - _Months;
        return *this;
    }
    constexpr year_month_day& year_month_day::operator+=(const years& _Years) noexcept {
        *this = *this + _Years;
        return *this;
    }
    constexpr year_month_day& year_month_day::operator-=(const years& _Years) noexcept {
        *this = *this - _Years;
        return *this;
    }

    class year_month_day_last {
    public:
        constexpr year_month_day_last(const year& _Y, const month_day_last& _Mdl) noexcept
            : _Year{_Y}, _Month_day_last{_Mdl} {}

        constexpr year_month_day_last& operator+=(const months& _Months) noexcept;
        constexpr year_month_day_last& operator-=(const months& _Months) noexcept;
        constexpr year_month_day_last& operator+=(const years& _Years) noexcept;
        constexpr year_month_day_last& operator-=(const years& _Years) noexcept;

        _NODISCARD constexpr year year() const noexcept {
            return _Year;
        }
        _NODISCARD constexpr month month() const noexcept {
            return _Month_day_last.month();
        }
        _NODISCARD constexpr month_day_last month_day_last() const noexcept {
            return _Month_day_last;
        }
        _NODISCARD constexpr day day() const noexcept {
            return _Last_day(year(), month());
        }

        _NODISCARD constexpr operator sys_days() const noexcept {
            return sys_days{year_month_day{year(), month(), day()}};
        }
        _NODISCARD constexpr explicit operator local_days() const noexcept {
            return _STD local_days{static_cast<sys_days>(*this).time_since_epoch()};
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Year.ok() && _Month_day_last.ok();
        }

    private:
        year _Year;
        month_day_last _Month_day_last;
    };

    constexpr bool operator==(const year_month_day_last& _Left, const year_month_day_last& _Right) noexcept {
        return _Left.year() == _Right.year() && _Left.month_day_last() == _Right.month_day_last();
    }
    constexpr strong_ordering operator<=>(
        const year_month_day_last& _Left, const year_month_day_last& _Right) noexcept {
        auto _Comp = _Left.year() <=> _Right.year();
        if (_Comp != 0) {
            return _Comp;
        }

        return _Left.month_day_last() <=> _Right.month_day_last();
    }

    constexpr year_month_day_last operator+(const year_month_day_last& _Left, const months& _Right) noexcept {
        const auto _Ym = year_month{_Left.year(), _Left.month()} + _Right;
        return {_Ym.year(), month_day_last{_Ym.month()}};
    }
    constexpr year_month_day_last operator+(const months& _Left, const year_month_day_last& _Right) noexcept {
        return _Right + _Left;
    }

    constexpr year_month_day_last operator-(const year_month_day_last& _Left, const months& _Right) noexcept {
        return _Left + (-_Right);
    }

    constexpr year_month_day_last operator+(const year_month_day_last& _Left, const years& _Right) noexcept {
        return {_Left.year() + _Right, _Left.month_day_last()};
    }
    constexpr year_month_day_last operator+(const years& _Left, const year_month_day_last& _Right) noexcept {
        return _Right + _Left;
    }
    constexpr year_month_day_last operator-(const year_month_day_last& _Left, const years& _Right) noexcept {
        return _Left + (-_Right);
    }

    constexpr year_month_day_last& year_month_day_last::operator+=(const months& _Months) noexcept {
        *this = *this + _Months;
        return *this;
    }
    constexpr year_month_day_last& year_month_day_last::operator-=(const months& _Months) noexcept {
        *this = *this - _Months;
        return *this;
    }
    constexpr year_month_day_last& year_month_day_last::operator+=(const years& _Years) noexcept {
        *this = *this + _Years;
        return *this;
    }
    constexpr year_month_day_last& year_month_day_last::operator-=(const years& _Years) noexcept {
        *this = *this - _Years;
        return *this;
    }
    // year
    constexpr year_month_day::year_month_day(const year_month_day_last& _Ymdl) noexcept
        : _Year{_Ymdl.year()}, _Month{_Ymdl.month()}, _Day{_Ymdl.day()} {}

    class year_month_weekday {
    public:
        year_month_weekday() = default;
        constexpr year_month_weekday(const year& _Y, const month& _M, const weekday_indexed& _Wdi) noexcept
            : _Year{_Y}, _Month{_M}, _Weekday_index{_Wdi} {}
        constexpr year_month_weekday(const sys_days& _Sys_days) noexcept
            : year_month_weekday{_Ymwd_from_days(_Sys_days.time_since_epoch())} {}
        constexpr explicit year_month_weekday(const local_days& _Local_days) noexcept
            : year_month_weekday{_Ymwd_from_days(_Local_days.time_since_epoch())} {}

        constexpr year_month_weekday& operator+=(const months& _Months) noexcept;
        constexpr year_month_weekday& operator-=(const months& _Months) noexcept;
        constexpr year_month_weekday& operator+=(const years& _Years) noexcept;
        constexpr year_month_weekday& operator-=(const years& _Years) noexcept;

        _NODISCARD constexpr year year() const noexcept {
            return _Year;
        }
        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr weekday weekday() const noexcept {
            return _Weekday_index.weekday();
        }
        _NODISCARD constexpr unsigned index() const noexcept {
            return _Weekday_index.index();
        }
        _NODISCARD constexpr weekday_indexed weekday_indexed() const noexcept {
            return _Weekday_index;
        }

        _NODISCARD constexpr operator sys_days() const noexcept {
            const sys_days _First = year_month_day{_Year, _Month, day{1}};
            const days _Diff      = weekday() - weekday{_First};
            const days _Days      = _Diff + days{(static_cast<int>(index()) - 1) * 7};
            return _First + _Days;
        }
        _NODISCARD constexpr explicit operator local_days() const noexcept {
            return local_days{static_cast<sys_days>(*this).time_since_epoch()};
        }
        _NODISCARD constexpr bool ok() const noexcept {
            if (!_Year.ok() || !_Month.ok() || !_Weekday_index.ok()) {
                return false;
            }

            if (_Weekday_index.index() <= 4) {
                return true;
            }

            const sys_days _First = year_month_day{_Year, _Month, day{1}};
            const days _Diff      = weekday() - weekday{_First};
            const days _Last      = _Diff + days{29};
            return static_cast<unsigned>(_Last.count()) <= static_cast<unsigned>(_Last_day(_Year, _Month));
        }

    private:
        year _Year;
        month _Month;
        weekday_indexed _Weekday_index;

        _NODISCARD static constexpr year_month_weekday _Ymwd_from_days(days _Dp) noexcept {
            const year_month_day _Ymd = sys_days{_Dp};
            const weekday _Wd         = sys_days{_Dp};
            const auto _Idx           = ((static_cast<unsigned>(_Ymd.day()) - 1) / 7) + 1;
            return {_Ymd.year(), _Ymd.month(), _Wd[_Idx]};
        }
    };

    constexpr bool operator==(const year_month_weekday& _Left, const year_month_weekday& _Right) noexcept {
        return _Left.year() == _Right.year() && _Left.month() == _Right.month()
               && _Left.weekday_indexed() == _Right.weekday_indexed();
    }

    constexpr year_month_weekday operator+(const year_month_weekday& _Left, const months& _Right) noexcept {
        const auto _Ym = year_month{_Left.year(), _Left.month()} + _Right;
        return {_Ym.year(), _Ym.month(), _Left.weekday_indexed()};
    }
    constexpr year_month_weekday operator+(const months& _Left, const year_month_weekday& _Right) noexcept {
        return _Right + _Left;
    }

    constexpr year_month_weekday operator-(const year_month_weekday& _Left, const months& _Right) noexcept {
        return _Left + (-_Right);
    }

    constexpr year_month_weekday operator+(const year_month_weekday& _Left, const years& _Right) noexcept {
        return year_month_weekday{_Left.year() + _Right, _Left.month(), _Left.weekday_indexed()};
    }
    constexpr year_month_weekday operator+(const years& _Left, const year_month_weekday& _Right) noexcept {
        return _Right + _Left;
    }

    constexpr year_month_weekday operator-(const year_month_weekday& _Left, const years& _Right) noexcept {
        return _Left + (-_Right);
    }

    constexpr year_month_weekday& year_month_weekday::operator+=(const months& _Months) noexcept {
        *this = *this + _Months;
        return *this;
    }
    constexpr year_month_weekday& year_month_weekday::operator-=(const months& _Months) noexcept {
        *this = *this - _Months;
        return *this;
    }
    constexpr year_month_weekday& year_month_weekday::operator+=(const years& _Years) noexcept {
        *this = *this + _Years;
        return *this;
    }
    constexpr year_month_weekday& year_month_weekday::operator-=(const years& _Years) noexcept {
        *this = *this - _Years;
        return *this;
    }

    class year_month_weekday_last {
    public:
        constexpr year_month_weekday_last(const year& _Y, const month& _M, const weekday_last& _Wdl) noexcept
            : _Year{_Y}, _Month{_M}, _Weekday_last{_Wdl} {}

        constexpr year_month_weekday_last& operator+=(const months& _Months) noexcept;
        constexpr year_month_weekday_last& operator-=(const months& _Months) noexcept;
        constexpr year_month_weekday_last& operator+=(const years& _Years) noexcept;
        constexpr year_month_weekday_last& operator-=(const years& _Years) noexcept;

        _NODISCARD constexpr year year() const noexcept {
            return _Year;
        }
        _NODISCARD constexpr month month() const noexcept {
            return _Month;
        }
        _NODISCARD constexpr weekday weekday() const noexcept {
            return _Weekday_last.weekday();
        }

        _NODISCARD constexpr weekday_last weekday_last() const noexcept {
            return _Weekday_last;
        }

        _NODISCARD constexpr operator sys_days() const noexcept {
            const sys_days _Last = year_month_day_last{_Year, month_day_last{_Month}};
            const auto _Diff     = weekday{_Last} - weekday();
            return _Last - _Diff;
        }
        _NODISCARD constexpr explicit operator local_days() const noexcept {
            return local_days{static_cast<sys_days>(*this).time_since_epoch()};
        }
        _NODISCARD constexpr bool ok() const noexcept {
            return _Year.ok() && _Month.ok() && _Weekday_last.ok();
        }

    private:
        year _Year;
        month _Month;
        weekday_last _Weekday_last;
    };

    constexpr bool operator==(const year_month_weekday_last& _Left, const year_month_weekday_last& _Right) noexcept {
        return _Left.year() == _Right.year() && _Left.month() == _Right.month()
               && _Left.weekday_last() == _Right.weekday_last();
    }

    constexpr year_month_weekday_last operator+(const year_month_weekday_last& _Left, const months& _Right) noexcept {
        const auto _Ym = year_month{_Left.year(), _Left.month()} + _Right;
        return {_Ym.year(), _Ym.month(), _Left.weekday_last()};
    }
    constexpr year_month_weekday_last operator+(const months& _Left, const year_month_weekday_last& _Right) noexcept {
        return _Right + _Left;
    }

    constexpr year_month_weekday_last operator-(const year_month_weekday_last& _Left, const months& _Right) noexcept {
        return _Left + (-_Right);
    }

    constexpr year_month_weekday_last operator+(const year_month_weekday_last& _Left, const years& _Right) noexcept {
        return {_Left.year() + _Right, _Left.month(), _Left.weekday_last()};
    }
    constexpr year_month_weekday_last operator+(const years& _Left, const year_month_weekday_last& _Right) noexcept {
        return _Right + _Left;
    }

    constexpr year_month_weekday_last operator-(const year_month_weekday_last& _Left, const years& _Right) noexcept {
        return _Left + (-_Right);
    }

    constexpr year_month_weekday_last& year_month_weekday_last::operator+=(const months& _Months) noexcept {
        *this = *this + _Months;
        return *this;
    }
    constexpr year_month_weekday_last& year_month_weekday_last::operator-=(const months& _Months) noexcept {
        *this = *this - _Months;
        return *this;
    }
    constexpr year_month_weekday_last& year_month_weekday_last::operator+=(const years& _Years) noexcept {
        *this = *this + _Years;
        return *this;
    }
    constexpr year_month_weekday_last& year_month_weekday_last::operator-=(const years& _Years) noexcept {
        *this = *this - _Years;
        return *this;
    }

    // Civil calendar conventional syntax operators
    _NODISCARD constexpr year_month operator/(const year& _Year, const month& _Month) noexcept {
        return {_Year, _Month};
    }
    _NODISCARD constexpr year_month operator/(const year& _Year, int _Month) noexcept {
        return _Year / month{static_cast<unsigned>(_Month)};
    }
    _NODISCARD constexpr month_day operator/(const month& _Month, const day& _Day) noexcept {
        return {_Month, _Day};
    }
    _NODISCARD constexpr month_day operator/(const month& _Month, int _Day) noexcept {
        return _Month / day{static_cast<unsigned>(_Day)};
    }
    _NODISCARD constexpr month_day operator/(int _Month, const day& _Day) noexcept {
        return month{static_cast<unsigned>(_Month)} / _Day;
    }
    _NODISCARD constexpr month_day operator/(const day& _Day, const month& _Month) noexcept {
        return _Month / _Day;
    }
    _NODISCARD constexpr month_day operator/(const day& _Day, int _Month) noexcept {
        return month{static_cast<unsigned>(_Month)} / _Day;
    }
    _NODISCARD constexpr month_day_last operator/(const month& _Month, last_spec) noexcept {
        return month_day_last{_Month};
    }
    _NODISCARD constexpr month_day_last operator/(int _Month, last_spec) noexcept {
        return month{static_cast<unsigned>(_Month)} / last;
    }
    _NODISCARD constexpr month_day_last operator/(last_spec, const month& _Month) noexcept {
        return _Month / last;
    }
    _NODISCARD constexpr month_day_last operator/(last_spec, int _Month) noexcept {
        return month{static_cast<unsigned>(_Month)} / last;
    }
    _NODISCARD constexpr month_weekday operator/(const month& _Month, const weekday_indexed& _Wdi) noexcept {
        return {_Month, _Wdi};
    }
    _NODISCARD constexpr month_weekday operator/(int _Month, const weekday_indexed& _Wdi) noexcept {
        return month{static_cast<unsigned>(_Month)} / _Wdi;
    }
    _NODISCARD constexpr month_weekday operator/(const weekday_indexed& _Wdi, const month& _Month) noexcept {
        return _Month / _Wdi;
    }
    _NODISCARD constexpr month_weekday operator/(const weekday_indexed& _Wdi, int _Month) noexcept {
        return month{static_cast<unsigned>(_Month)} / _Wdi;
    }
    _NODISCARD constexpr month_weekday_last operator/(const month& _Month, const weekday_last& _Wdl) noexcept {
        return {_Month, _Wdl};
    }
    _NODISCARD constexpr month_weekday_last operator/(int _Month, const weekday_last& _Wdl) noexcept {
        return month{static_cast<unsigned>(_Month)} / _Wdl;
    }
    _NODISCARD constexpr month_weekday_last operator/(const weekday_last& _Wdl, const month& _Month) noexcept {
        return _Month / _Wdl;
    }
    _NODISCARD constexpr month_weekday_last operator/(const weekday_last& _Wdl, int _Month) noexcept {
        return month{static_cast<unsigned>(_Month)} / _Wdl;
    }
    _NODISCARD constexpr year_month_day operator/(const year_month& _Ym, const day& _Day) noexcept {
        return {_Ym.year(), _Ym.month(), _Day};
    }
    _NODISCARD constexpr year_month_day operator/(const year_month& _Ym, int _Day) noexcept {
        return _Ym / day{static_cast<unsigned>(_Day)};
    }
    _NODISCARD constexpr year_month_day operator/(const year& _Year, const month_day& _Md) noexcept {
        return _Year / _Md.month() / _Md.day();
    }
    _NODISCARD constexpr year_month_day operator/(int _Year, const month_day& _Md) noexcept {
        return year{_Year} / _Md.month() / _Md.day();
    }
    _NODISCARD constexpr year_month_day operator/(const month_day& _Md, const year& _Year) noexcept {
        return _Year / _Md.month() / _Md.day();
    }
    _NODISCARD constexpr year_month_day operator/(const month_day& _Md, int _Year) noexcept {
        return year{_Year} / _Md.month() / _Md.day();
    }
    _NODISCARD constexpr year_month_day_last operator/(const year_month& _Ym, last_spec) noexcept {
        return {_Ym.year(), month_day_last{_Ym.month()}};
    }
    _NODISCARD constexpr year_month_day_last operator/(const year& _Year, const month_day_last& _Mdl) noexcept {
        return {_Year, _Mdl};
    }
    _NODISCARD constexpr year_month_day_last operator/(int _Year, const month_day_last& _Mdl) noexcept {
        return year{_Year} / _Mdl;
    }
    _NODISCARD constexpr year_month_day_last operator/(const month_day_last& _Mdl, const year& _Year) noexcept {
        return _Year / _Mdl;
    }
    _NODISCARD constexpr year_month_day_last operator/(const month_day_last& _Mdl, int _Year) noexcept {
        return year{_Year} / _Mdl;
    }
    _NODISCARD constexpr year_month_weekday operator/(const year_month& _Ym, const weekday_indexed& _Wdi) noexcept {
        return year_month_weekday{_Ym.year(), _Ym.month(), _Wdi};
    }
    _NODISCARD constexpr year_month_weekday operator/(const year& _Year, const month_weekday& _Mwd) noexcept {
        return year_month_weekday{_Year, _Mwd.month(), _Mwd.weekday_indexed()};
    }
    _NODISCARD constexpr year_month_weekday operator/(int _Year, const month_weekday& _Mwd) noexcept {
        return year{_Year} / _Mwd;
    }
    _NODISCARD constexpr year_month_weekday operator/(const month_weekday& _Mwd, const year& _Year) noexcept {
        return _Year / _Mwd;
    }
    _NODISCARD constexpr year_month_weekday operator/(const month_weekday& _Mwd, int _Year) noexcept {
        return year{_Year} / _Mwd;
    }
    _NODISCARD constexpr year_month_weekday_last operator/(const year_month& _Ym, const weekday_last& _Wdl) noexcept {
        return {_Ym.year(), _Ym.month(), _Wdl};
    }
    _NODISCARD constexpr year_month_weekday_last operator/(
        const year& _Year, const month_weekday_last& _Mwdl) noexcept {
        return {_Year, _Mwdl.month(), _Mwdl.weekday_last()};
    }
    _NODISCARD constexpr year_month_weekday_last operator/(int _Year, const month_weekday_last& _Mwdl) noexcept {
        return year{_Year} / _Mwdl;
    }
    _NODISCARD constexpr year_month_weekday_last operator/(
        const month_weekday_last& _Mwdl, const year& _Year) noexcept {
        return _Year / _Mwdl;
    }
    _NODISCARD constexpr year_month_weekday_last operator/(const month_weekday_last& _Mwdl, int _Year) noexcept {
        return year{_Year} / _Mwdl;
    }

    // Calendrical constants
    inline constexpr weekday Sunday{0};
    inline constexpr weekday Monday{1};
    inline constexpr weekday Tuesday{2};
    inline constexpr weekday Wednesday{3};
    inline constexpr weekday Thursday{4};
    inline constexpr weekday Friday{5};
    inline constexpr weekday Saturday{6};

    inline constexpr month January{1};
    inline constexpr month February{2};
    inline constexpr month March{3};
    inline constexpr month April{4};
    inline constexpr month May{5};
    inline constexpr month June{6};
    inline constexpr month July{7};
    inline constexpr month August{8};
    inline constexpr month September{9};
    inline constexpr month October{10};
    inline constexpr month November{11};
    inline constexpr month December{12};
#endif // _HAS_CXX20
} // namespace chrono

// HELPERS
template <class _Rep, class _Period>
_NODISCARD bool _To_xtime_10_day_clamped(_CSTD xtime& _Xt, const chrono::duration<_Rep, _Period>& _Rel_time) noexcept(
    is_arithmetic_v<_Rep>) {
    // Convert duration to xtime, maximum 10 days from now, returns whether clamping occurred.
    // If clamped, timeouts will be transformed into spurious non-timeout wakes, due to ABI restrictions where
    // the other side of the DLL boundary overflows int32_t milliseconds.
    // Every function calling this one is TRANSITION, ABI
    constexpr chrono::nanoseconds _Ten_days{chrono::hours{24} * 10};
    constexpr chrono::duration<double> _Ten_days_d{_Ten_days};
    chrono::nanoseconds _Tx0 = chrono::system_clock::now().time_since_epoch();
    const bool _Clamped      = _Ten_days_d < _Rel_time;
    if (_Clamped) {
        _Tx0 += _Ten_days;
    } else {
        _Tx0 += chrono::duration_cast<chrono::nanoseconds>(_Rel_time);
    }

    const auto _Whole_seconds = chrono::duration_cast<chrono::seconds>(_Tx0);
    _Xt.sec                   = _Whole_seconds.count();
    _Tx0 -= _Whole_seconds;
    _Xt.nsec = static_cast<long>(_Tx0.count());
    return _Clamped;
}

// duration LITERALS
inline namespace literals {
    inline namespace chrono_literals {
        _NODISCARD constexpr chrono::hours operator"" h(unsigned long long _Val) noexcept /* strengthened */ {
            return chrono::hours(_Val);
        }

        _NODISCARD constexpr chrono::duration<double, ratio<3600>> operator"" h(long double _Val) noexcept
        /* strengthened */ {
            return chrono::duration<double, ratio<3600>>(_Val);
        }

        _NODISCARD constexpr chrono::minutes(operator"" min)(unsigned long long _Val) noexcept /* strengthened */ {
            return chrono::minutes(_Val);
        }

        _NODISCARD constexpr chrono::duration<double, ratio<60>>(operator"" min)(long double _Val) noexcept
        /* strengthened */ {
            return chrono::duration<double, ratio<60>>(_Val);
        }

        _NODISCARD constexpr chrono::seconds operator"" s(unsigned long long _Val) noexcept /* strengthened */ {
            return chrono::seconds(_Val);
        }

        _NODISCARD constexpr chrono::duration<double> operator"" s(long double _Val) noexcept /* strengthened */ {
            return chrono::duration<double>(_Val);
        }

        _NODISCARD constexpr chrono::milliseconds operator"" ms(unsigned long long _Val) noexcept /* strengthened */ {
            return chrono::milliseconds(_Val);
        }

        _NODISCARD constexpr chrono::duration<double, milli> operator"" ms(long double _Val) noexcept
        /* strengthened */ {
            return chrono::duration<double, milli>(_Val);
        }

        _NODISCARD constexpr chrono::microseconds operator"" us(unsigned long long _Val) noexcept /* strengthened */ {
            return chrono::microseconds(_Val);
        }

        _NODISCARD constexpr chrono::duration<double, micro> operator"" us(long double _Val) noexcept
        /* strengthened */ {
            return chrono::duration<double, micro>(_Val);
        }

        _NODISCARD constexpr chrono::nanoseconds operator"" ns(unsigned long long _Val) noexcept /* strengthened */ {
            return chrono::nanoseconds(_Val);
        }

        _NODISCARD constexpr chrono::duration<double, nano> operator"" ns(long double _Val) noexcept
        /* strengthened */ {
            return chrono::duration<double, nano>(_Val);
        }
#if _HAS_CXX20
        _NODISCARD constexpr day operator"" d(unsigned long long _Day) noexcept /* strengthened */ {
            return day{static_cast<unsigned>(_Day)};
        }
        _NODISCARD constexpr year operator"" y(unsigned long long _Year) noexcept /* strengthened */ {
            return year{static_cast<int>(_Year)};
        }
#endif // _HAS_CXX20
    } // namespace chrono_literals
} // namespace literals

namespace chrono {
    using namespace literals::chrono_literals;
} // namespace chrono

_STD_END
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _CHRONO_
