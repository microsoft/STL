// flat_map standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _FLAT_MAP_
#define _FLAT_MAP_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR
#if !_HAS_CXX23
_EMIT_STL_WARNING(STL4038, "The contents of <flat_map> are available only with C++23 or later.");
#else // ^^^ !_HAS_CXX23 / _HAS_CXX23 vvv

#include <algorithm>
#include <compare>
#include <concepts>
#include <initializer_list>
#include <type_traits>
#include <utility>
#include <vector>
#include <xmemory>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
_EXPORT_STD struct sorted_unique_t {
    explicit sorted_unique_t() = default;
};
_EXPORT_STD inline constexpr sorted_unique_t sorted_unique{};

_EXPORT_STD struct sorted_equivalent_t {
    explicit sorted_equivalent_t() = default;
};
_EXPORT_STD inline constexpr sorted_equivalent_t sorted_equivalent{};

template <class _Alloc, class _Key_container, class _Mapped_container>
concept _Valid_allocator_for_flat_map =
    uses_allocator_v<_Key_container, _Alloc> && uses_allocator_v<_Mapped_container, _Alloc>;

template <class _Compare, class _Key_container>
concept _Valid_compare_for_container = is_invocable_v<const _Compare&, const typename _Key_container::value_type&,
    const typename _Key_container::value_type&>;

template <class _Key, class _Mapped, class _KeyCompare>
struct _Flat_map_value_compare_provider {
    struct value_compare {
    public:
        bool operator()(pair<const _Key&, const _Mapped&> _Left, pair<const _Key&, const _Mapped&> _Right) const {
            return _Key_comparator(_Left.first, _Right.first);
        }

        value_compare(_KeyCompare _Comp) : _Key_comparator(_Comp) {}

    private:
        _KeyCompare _Key_comparator;
    };
};

template <class _KeyContainer, class _MappedContainer>
struct _Flat_map_container_provider {
    struct containers {
        _KeyContainer keys;
        _MappedContainer values;
    };
};

template <class _Ty>
struct _NODISCARD _Clear_flat_map_scope_guard {
    _Ty* _Clearable;
    _Clear_flat_map_scope_guard(_Ty* _Clearable) : _Clearable(_Clearable) {}

    ~_Clear_flat_map_scope_guard() {
        if (_Clearable) {
            _Clearable->clear();
        }
    }
};

// Implementation

template <bool _IsUnique, class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer>
class _Flat_map_base;

template <class _KeyIter, class _MappedIter, class _MappedConvIter>
struct _Pairing_iterator_provider {
    class _Iterator {
    public:
        template <bool _IsUnique, class _Key, class _Mapped, class _Compare, class _KeyContainer,
            class _MappedContainer>
        friend class _Flat_map_base;

        _Iterator() = default;
        _Iterator(_KeyIter _Key_iter, _MappedIter _Mapped_iter) : _Key_it(_Key_iter), _Mapped_it(_Mapped_iter) {}

        using iterator_category = input_iterator_tag;
        using iterator_concept  = random_access_iterator_tag;
        using difference_type   = ptrdiff_t;
        using value_type        = pair<iter_value_t<_KeyIter>, iter_value_t<_MappedIter>>;
        using reference         = pair<iter_reference_t<_KeyIter>, iter_reference_t<_MappedIter>>;

    private:
        using _Const_iterator = _Pairing_iterator_provider<_KeyIter, _MappedConvIter, _MappedConvIter>::_Iterator;

        class _Arrow_proxy {
        public:
            explicit _Arrow_proxy(const reference& _Rx) noexcept : _Ref{_Rx} {}

            const reference* operator->() const noexcept {
                return _STD addressof(_Ref);
            }

        private:
            reference _Ref;
        };

    public:
        using pointer = _Arrow_proxy;

        reference operator*() const {
            return reference{*_Key_it, *_Mapped_it};
        }

        pointer operator->() const {
            return pointer{**this};
        }

        _Iterator& operator++() {
            ++_Key_it;
            ++_Mapped_it;
            return *this;
        }

        _Iterator operator++(int) {
            auto _Old = *this;
            ++*this;
            return _Old;
        }

        bool operator==(const _Iterator& _Right) const {
            return _Key_it == _Right._Key_it;
        }

        auto operator<=>(const _Iterator& _Right) const {
            return _Key_it <=> _Right._Key_it;
        }

        _Iterator& operator--() {
            --_Key_it;
            --_Mapped_it;
            return *this;
        }

        _Iterator operator--(int) {
            auto _Old = *this;
            --*this;
            return _Old;
        }

        _Iterator& operator+=(const difference_type _Off) {
            _Key_it += _Off;
            _Mapped_it += _Off;
            return *this;
        }

        _Iterator& operator-=(const difference_type _Off) {
            _Key_it -= _Off;
            _Mapped_it -= _Off;
            return *this;
        }

        _Iterator operator+(const difference_type _Off) const {
            auto _Old = *this;
            _Old += _Off;
            return _Old;
        }

        _Iterator operator-(const difference_type _Off) const {
            auto _Old = *this;
            _Old -= _Off;
            return _Old;
        }

        reference operator[](const difference_type _Off) const {
            return *(*this + _Off);
        }

        difference_type operator-(const _Iterator& _Right) const {
            return _Key_it - _Right._Key_it;
        }

        friend _Iterator operator+(const difference_type _Off, const _Iterator& _Right) {
            return _Right + _Off;
        }

        operator _Const_iterator() const
            requires (!is_same_v<_MappedIter, _MappedConvIter>)
        {
            return _Const_iterator{_Key_it, _Mapped_it};
        }

    private:
        _KeyIter _Key_it;
        _MappedIter _Mapped_it;
    };

    _STL_INTERNAL_STATIC_ASSERT(swappable<_Iterator>);
};

_EXPORT_STD template <class _Key, class _Mapped, class _Compare = less<_Key>, class _KeyContainer = vector<_Key>,
    class _MappedContainer = vector<_Mapped>>
class flat_map;

_EXPORT_STD template <class _Key, class _Mapped, class _Compare = less<_Key>, class _KeyContainer = vector<_Key>,
    class _MappedContainer = vector<_Mapped>>
class flat_multimap;

template <bool _IsUnique, class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer>
class _Flat_map_base {
private:
    using _Sorted_t = conditional_t<_IsUnique, sorted_unique_t, sorted_equivalent_t>;
    using _Derived  = conditional_t<_IsUnique, flat_map<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>,
        flat_multimap<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>>;

public:
    using key_type               = _Key;
    using mapped_type            = _Mapped;
    using value_type             = pair<key_type, mapped_type>;
    using key_compare            = _Compare;
    using reference              = pair<const key_type&, mapped_type&>;
    using const_reference        = pair<const key_type&, const mapped_type&>;
    using size_type              = size_t;
    using difference_type        = ptrdiff_t;
    using key_container_type     = _KeyContainer;
    using mapped_container_type  = _MappedContainer;
    using iterator               = _Pairing_iterator_provider<typename key_container_type::const_iterator,
        typename mapped_container_type::iterator, typename mapped_container_type::const_iterator>::_Iterator;
    using const_iterator         = _Pairing_iterator_provider<typename key_container_type::const_iterator,
        typename mapped_container_type::const_iterator, typename mapped_container_type::const_iterator>::_Iterator;
    using reverse_iterator       = _STD reverse_iterator<iterator>;
    using const_reverse_iterator = _STD reverse_iterator<const_iterator>;

    static_assert(is_same_v<key_type, typename key_container_type::value_type>,
        "key_type should be the element type of key_container_type");
    static_assert(is_same_v<mapped_type, typename mapped_container_type::value_type>,
        "mapped_type should be the element type of mapped_container_type");

    _STL_INTERNAL_STATIC_ASSERT(random_access_iterator<iterator>);
    _STL_INTERNAL_STATIC_ASSERT(convertible_to<iterator, const_iterator>);

    using value_compare = _Flat_map_value_compare_provider<key_type, mapped_type, key_compare>::value_compare;
    using containers    = _Flat_map_container_provider<key_container_type, mapped_container_type>::containers;

public:
    // [flat.map.cons] Constructors
    explicit _Flat_map_base(const key_compare& _Comp) : _Key_compare(_Comp), _Data() {}
    _Flat_map_base() : _Flat_map_base(key_compare()) {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    explicit _Flat_map_base(const _Allocator& _Alloc) : _Flat_map_base(key_compare(), _Alloc) {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    explicit _Flat_map_base(const key_compare& _Comp, const _Allocator& _Alloc)
        : _Key_compare(_Comp), _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc),
                                   .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc)} {}

    _Flat_map_base(
        key_container_type _Key_cont, mapped_container_type _Mapped_cont, const key_compare& _Comp = key_compare())
        : _Flat_map_base(_Sorted_t(), _Key_cont, _Mapped_cont, _Comp) {
        _Sort();
        if constexpr (_IsUnique) {
            _Dedup();
        }
    }

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(
        const key_container_type& _Key_cont, const mapped_container_type& _Mapped_cont, const _Allocator& _Alloc)
        : _Flat_map_base(_Sorted_t(), _Key_cont, _Mapped_cont, _Alloc) {
        _Sort();
        if constexpr (_IsUnique) {
            _Dedup();
        }
    }

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(const key_container_type& _Key_cont, const mapped_container_type& _Mapped_cont,
        const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Sorted_t(), _Key_cont, _Mapped_cont, _Comp, _Alloc) {
        _Sort();
        if constexpr (_IsUnique) {
            _Dedup();
        }
    }

    _Flat_map_base(_Sorted_t, key_container_type _Key_cont, mapped_container_type _Mapped_cont,
        const key_compare& _Comp = key_compare())
        : _Key_compare(_Comp), _Data{.keys = _STD move(_Key_cont), .values = _STD move(_Mapped_cont)} {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_Sorted_t, const key_container_type& _Key_cont, const mapped_container_type& _Mapped_cont,
        const _Allocator& _Alloc)
        : _Key_compare(key_compare()),
          _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc, _Key_cont),
              .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc, _Mapped_cont)} {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_Sorted_t, const key_container_type& _Key_cont, const mapped_container_type& _Mapped_cont,
        const key_compare& _Comp, const _Allocator& _Alloc)
        : _Key_compare(_Comp),
          _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc, _Key_cont),
              .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc, _Mapped_cont)} {}

    template <class _InputIterator>
        requires _Is_iterator_v<_InputIterator>
    _Flat_map_base(_InputIterator _First, _InputIterator _Last, const key_compare& _Comp = key_compare())
        : _Flat_map_base(_Comp) {
        insert(_First, _Last);
    }

    template <class _InputIterator, _Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
        requires _Is_iterator_v<_InputIterator>
    _Flat_map_base(_InputIterator _First, _InputIterator _Last, const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Comp, _Alloc) {
        insert(_First, _Last);
    }

    template <_Container_compatible_range<value_type> _Rng>
    _Flat_map_base(from_range_t _From_range, _Rng&& _Range)
        : _Flat_map_base(_From_range, _STD forward<_Rng>(_Range), key_compare()) {}

    template <_Container_compatible_range<value_type> _Rng,
        _Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(from_range_t _From_range, _Rng&& _Range, const _Allocator& _Alloc)
        : _Flat_map_base(_From_range, _STD forward<_Rng>(_Range), key_compare(), _Alloc) {}

    template <_Container_compatible_range<value_type> _Rng>
    _Flat_map_base(from_range_t, _Rng&& _Range, const key_compare& _Comp) : _Flat_map_base(_Comp) {
        insert_range(_STD forward<_Rng>(_Range));
    }

    template <_Container_compatible_range<value_type> _Rng,
        _Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(from_range_t, _Rng&& _Range, const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Comp, _Alloc) {
        insert_range(_STD forward<_Rng>(_Range));
    }

    template <class _InputIterator>
        requires _Is_iterator_v<_InputIterator>
    _Flat_map_base(
        _Sorted_t _Tag, _InputIterator _First, _InputIterator _Last, const key_compare& _Comp = key_compare())
        : _Flat_map_base(_Comp) {
        insert(_Tag, _First, _Last);
    }

    template <class _InputIterator, _Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
        requires _Is_iterator_v<_InputIterator>
    _Flat_map_base(
        _Sorted_t _Tag, _InputIterator _First, _InputIterator _Last, const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Comp, _Alloc) {
        insert(_Tag, _First, _Last);
    }

    template <class _InputIterator, _Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
        requires _Is_iterator_v<_InputIterator>
    _Flat_map_base(_Sorted_t _Tag, _InputIterator _First, _InputIterator _Last, const _Allocator& _Alloc)
        : _Flat_map_base(_Tag, _First, _Last, key_compare(), _Alloc) {}

    _Flat_map_base(initializer_list<value_type> _Ilist, const key_compare& _Comp = key_compare())
        : _Flat_map_base(_Ilist.begin(), _Ilist.end(), _Comp) {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(initializer_list<value_type> _Ilist, const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Ilist.begin(), _Ilist.end(), _Comp, _Alloc) {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(initializer_list<value_type> _Ilist, const _Allocator& _Alloc)
        : _Flat_map_base(_Ilist, key_compare(), _Alloc) {}

    _Flat_map_base(_Sorted_t _Tag, initializer_list<value_type> _Ilist, const key_compare& _Comp = key_compare())
        : _Flat_map_base(_Tag, _Ilist.begin(), _Ilist.end(), _Comp) {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(
        _Sorted_t _Tag, initializer_list<value_type> _Ilist, const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Tag, _Ilist.begin(), _Ilist.end(), _Comp, _Alloc) {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_Sorted_t _Tag, initializer_list<value_type> _Ilist, const _Allocator& _Alloc)
        : _Flat_map_base(_Tag, _Ilist, key_compare(), _Alloc) {}

    // Copy constructors
    _Flat_map_base(const _Derived& _Other) : _Key_compare(_Other._Key_compare), _Data(_Other._Data) {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(const _Derived& _Other, const _Allocator& _Alloc)
        : _Key_compare(_Other._Key_compare),
          _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc, _Other._Data.keys),
              .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc, _Other._Data.values)} {}

    // Move constructors
    _Flat_map_base(_Derived&& _Other) noexcept(is_nothrow_move_constructible_v<key_compare>
                                               && is_nothrow_move_constructible_v<key_container_type>
                                               && is_nothrow_move_constructible_v<mapped_container_type>)
        : _Key_compare(move(_Other._Key_compare)), _Data(move(_Other).extract()) {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_Derived&& _Other, const _Allocator& _Alloc) noexcept(
        is_nothrow_move_constructible_v<key_compare> && is_nothrow_move_constructible_v<key_container_type>
        && is_nothrow_move_constructible_v<mapped_container_type>)
        : _Key_compare(move(_Other._Key_compare)),
          _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc, move(_Other._Data.keys)),
              .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc, move(_Other._Data.values))} {}

    _Derived& operator=(initializer_list<value_type> _Ilist) {
        clear();
        insert(_Ilist.begin(), _Ilist.end());
        return static_cast<_Derived&>(*this); // TRANSITION, P0847R7, should use explicit object parameter
    }

    // [container.reqmts] iterators
    _NODISCARD iterator begin() noexcept {
        return iterator{_Data.keys.cbegin(), _Data.values.begin()};
    }

    _NODISCARD const_iterator begin() const noexcept {
        return const_iterator{_Data.keys.cbegin(), _Data.values.begin()};
    }

    _NODISCARD iterator end() noexcept {
        return iterator{_Data.keys.cend(), _Data.values.end()};
    }

    _NODISCARD const_iterator end() const noexcept {
        return const_iterator{_Data.keys.cend(), _Data.values.end()};
    }

    _NODISCARD reverse_iterator rbegin() noexcept {
        return _STD make_reverse_iterator(end());
    }

    _NODISCARD const_reverse_iterator rbegin() const noexcept {
        return _STD make_reverse_iterator(end());
    }

    _NODISCARD reverse_iterator rend() noexcept {
        return _STD make_reverse_iterator(begin());
    }

    _NODISCARD const_reverse_iterator rend() const noexcept {
        return _STD make_reverse_iterator(begin());
    }

    _NODISCARD const_iterator cbegin() const noexcept {
        return const_iterator{_Data.keys.cbegin(), _Data.values.cbegin()};
    }

    _NODISCARD const_iterator cend() const noexcept {
        return const_iterator{_Data.keys.cend(), _Data.values.cend()};
    }

    _NODISCARD const_reverse_iterator crbegin() const noexcept {
        return _STD make_reverse_iterator(cend());
    }

    _NODISCARD const_reverse_iterator crend() const noexcept {
        return _STD make_reverse_iterator(cbegin());
    }

    void swap(_Derived& _Other) noexcept {
        _RANGES swap(_Key_compare, _Other._Key_compare);
        _RANGES swap(_Data.keys, _Other._Data.keys);
        _RANGES swap(_Data.values, _Other._Data.values);
    }

    // [container.reqmts] clear
    void clear() noexcept {
        _Data.keys.clear();
        _Data.values.clear();
    }

    // [flat.map.capacity] Capacity
    _NODISCARD_EMPTY_MEMBER bool empty() const noexcept {
        return _Data.keys.empty();
    }

    _NODISCARD size_type size() const noexcept {
        return _Data.keys.size();
    }

    _NODISCARD size_type max_size() const noexcept {
        return _STD min(_Data.keys.max_size(), _Data.values.max_size());
    }

    template <class... _ArgTypes>
    iterator emplace_hint(const_iterator _Position, _ArgTypes&&... _Args)
        requires is_constructible_v<value_type, _ArgTypes...>
    {
        value_type _Val(_STD forward<_ArgTypes>(_Args)...);
        return _Emplace_hint<false>(_Position, _STD move(_Val.first), _STD move(_Val.second));
    }

    iterator insert(const_iterator _Position, const value_type& _Pair_val) {
        return emplace_hint(_Position, _Pair_val);
    }

    iterator insert(const_iterator _Position, value_type&& _Pair_val) {
        return emplace_hint(_Position, _STD move(_Pair_val));
    }

    template <class _PairValTy>
    iterator insert(const_iterator _Position, _PairValTy&& _Pair_val)
        requires is_constructible_v<value_type, _PairValTy>
    {
        return emplace_hint(_Position, _STD forward<_PairValTy>(_Pair_val));
    }

    template <class _InputIterator>
        requires _Is_iterator_v<_InputIterator>
    void insert(_InputIterator _First, _InputIterator _Last) {
        _Insert_range<true, _IsUnique>(_First, _Last);
    }

    template <class _InputIterator>
        requires _Is_iterator_v<_InputIterator>
    void insert(_Sorted_t, _InputIterator _First, _InputIterator _Last) {
        _Insert_range<false, _IsUnique>(_First, _Last);
    }

    template <_Container_compatible_range<value_type> _Rng>
    void insert_range(_Rng&& _Range) {
        insert(_RANGES begin(_Range), _RANGES end(_Range));
    }

    void insert(initializer_list<value_type> _Ilist) {
        insert(_Ilist.begin(), _Ilist.end());
    }

    void insert(_Sorted_t _Tag, initializer_list<value_type> _Ilist) {
        insert(_Tag, _Ilist.begin(), _Ilist.end());
    }

    iterator erase(iterator _Position) {
        return erase(static_cast<const_iterator>(_Position));
    }

    iterator erase(const_iterator _Position) {
        _Clear_flat_map_scope_guard _Guard{this};
        auto _Key_it      = _Data.keys.erase(_Position._Key_it);
        auto _Val_it      = _Data.values.erase(_Position._Mapped_it);
        _Guard._Clearable = nullptr;
        return iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    iterator erase(const_iterator _First, const_iterator _Last) {
        _Clear_flat_map_scope_guard _Guard{this};
        auto _Key_it      = _Data.keys.erase(_First._Key_it, _Last._Key_it);
        auto _Val_it      = _Data.values.erase(_First._Mapped_it, _Last._Mapped_it);
        _Guard._Clearable = nullptr;
        return iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    size_type erase(const key_type& _Key_val) {
        return _Erase_key(_Key_val);
    }

    template <class _OtherKey>
        requires _Is_transparent_v<key_compare>
              && (!is_convertible_v<_OtherKey, iterator>) && (!is_convertible_v<_OtherKey, const_iterator>)
    size_type erase(_OtherKey&& _Key_val) {
        return _Erase_key(_STD forward<_OtherKey>(_Key_val));
    }

    containers extract() && {
        _Clear_flat_map_scope_guard _Guard{this};
        return _STD move(_Data);
    }

    void replace(key_container_type&& _Key_cont, mapped_container_type&& _Mapped_cont) {
        _Clear_flat_map_scope_guard _Guard{this};
        _Data.keys        = _STD move(_Key_cont);
        _Data.values      = _STD move(_Mapped_cont);
        _Guard._Clearable = nullptr;
    }

    // observers
    key_compare key_comp() const {
        return _Key_compare;
    }

    value_compare value_comp() const {
        return value_compare(_Key_compare);
    }

    const key_container_type& keys() const noexcept {
        return _Data.keys;
    }

    const mapped_container_type& values() const noexcept {
        return _Data.values;
    }

    // map operations
    _NODISCARD iterator find(const key_type& _Key_val) {
        return _Find(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD iterator find(const _OtherKey& _Key_val)
        requires _Is_transparent_v<key_compare>
    {
        return _Find(_Key_val);
    }

    _NODISCARD const_iterator find(const key_type& _Key_val) const {
        return _Find(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD const_iterator find(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _Find(_Key_val);
    }

    _NODISCARD size_type count(const key_type& _Key_val) const {
        return _Count(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD size_type count(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _Count(_Key_val);
    }

    _NODISCARD bool contains(const key_type& _Key_val) const {
        return _Contains(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD bool contains(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _Contains(_Key_val);
    }

    _NODISCARD iterator lower_bound(const key_type& _Key_val) {
        return _Lower_bound(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD iterator lower_bound(const _OtherKey& _Key_val)
        requires _Is_transparent_v<key_compare>
    {
        return _Lower_bound(_Key_val);
    }

    _NODISCARD const_iterator lower_bound(const key_type& _Key_val) const {
        return _Lower_bound(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD const_iterator lower_bound(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _Lower_bound(_Key_val);
    }

    _NODISCARD iterator upper_bound(const key_type& _Key_val) {
        return _Upper_bound(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD iterator upper_bound(const _OtherKey& _Key_val)
        requires _Is_transparent_v<key_compare>
    {
        return _Upper_bound(_Key_val);
    }

    _NODISCARD const_iterator upper_bound(const key_type& _Key_val) const {
        return _Upper_bound(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD const_iterator upper_bound(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _Upper_bound(_Key_val);
    }

    _NODISCARD pair<iterator, iterator> equal_range(const key_type& _Key_val) {
        return _Equal_range(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD pair<iterator, iterator> equal_range(const _OtherKey& _Key_val)
        requires _Is_transparent_v<key_compare>
    {
        return _Equal_range(_Key_val);
    }

    _NODISCARD pair<const_iterator, const_iterator> equal_range(const key_type& _Key_val) const {
        return _Equal_range(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD pair<const_iterator, const_iterator> equal_range(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _Equal_range(_Key_val);
    }

    _NODISCARD_FRIEND bool operator==(const _Derived& _Left, const _Derived& _Right) {
        return _RANGES equal(_Left._Data.keys, _Right._Data.keys)
            && _RANGES equal(_Left._Data.values, _Right._Data.values);
    }

    _NODISCARD_FRIEND auto operator<=>(const _Derived& _Left, const _Derived& _Right) {
        return _STD lexicographical_compare_three_way(_STD _Get_unwrapped(_Left.cbegin()),
            _STD _Get_unwrapped(_Left.cend()), _STD _Get_unwrapped(_Right.cbegin()), _STD _Get_unwrapped(_Right.cend()),
            _Synth_three_way{});
    }

    friend void swap(_Derived& _Left, _Derived& _Right) noexcept {
        _Left.swap(_Right);
    }


protected:
    key_compare _Key_compare;
    containers _Data;

    template <class _Predicate>
    size_type _Erase_if(_Predicate _Pred) {
        auto _View           = _View_to_mutate();
        auto _Mut_first      = _View.begin();
        auto _Mut_last       = _View.end();
        const auto _Old_size = size();

        _Clear_flat_map_scope_guard<_Flat_map_base> _Guard{this};

        _STD _Seek_wrapped(_Mut_first, _RANGES remove_if(_View, _Pred).begin());
        (void) _Data.keys.erase(_Mut_first._Key_it, _Mut_last._Key_it);
        (void) _Data.values.erase(_Mut_first._Mapped_it, _Mut_last._Mapped_it);

        _Guard._Clearable = nullptr;
        return _Old_size - size();
    }

    template <bool _OverwriteIfExists, class _OtherKey, class... _MappedArgTypes>
    iterator _Emplace_hint(const_iterator _Position, _OtherKey&& _Key_val, _MappedArgTypes&&... _Args) {
        _STL_INTERNAL_STATIC_ASSERT(
            is_constructible_v<mapped_type, _MappedArgTypes...>
            && (is_same_v<remove_cvref_t<_OtherKey>, key_type>
                || (is_constructible_v<key_type, _OtherKey> && _Is_transparent_v<key_compare>) ));
        static_assert(_IsUnique || !_OverwriteIfExists,
            "Overwriting is not supported when the container allows multiple copies of a key.");
        const const_iterator _Begin = cbegin();
        const const_iterator _End   = cend();

        const bool _Hint_is_accurate = [&] {
            if constexpr (_IsUnique) {
                if (_Position == _End || _Key_compare(_Key_val, *_Position._Key_it)) {
                    return _Position == _Begin || _Key_compare(_Position._Key_it[-1], _Key_val);
                }
            } else {
                if (_Position == _End || !_Key_compare(*_Position._Key_it, _Key_val)) {
                    return _Position == _Begin || !_Key_compare(_Key_val, _Position._Key_it[-1]);
                }
            }
            return false;
        }();

        if (_Hint_is_accurate) {
            const auto _Dist = _Position._Key_it - _Begin._Key_it;
            {
                key_type _Key_to_insert(_STD forward<_OtherKey>(_Key_val));
                mapped_type _Mapped_to_insert(_STD forward<_MappedArgTypes>(_Args)...);
                _Insert_exact(_Position, _STD move(_Key_to_insert), _STD move(_Mapped_to_insert));
            }
            return begin() + _Dist;
        }

        if constexpr (_OverwriteIfExists) {
            if (_Key_equal(_Key_val, *_Position._Key_it)) {
                const auto _Dist = _Position._Key_it - _Begin._Key_it;
                const auto _It   = begin() + _Dist;
                *_It._Mapped_it  = mapped_type(_STD forward<_MappedArgTypes>(_Args)...);
                return _It;
            }

            _Position = lower_bound(_Key_val);
            if (_Position != _End && !_Key_compare(_Key_val, *_Position._Key_it)) {
                const auto _Dist = _Position._Key_it - _Begin._Key_it;
                auto _It         = begin() + _Dist;
                *_It._Mapped_it  = mapped_type(_STD forward<_MappedArgTypes>(_Args)...);
                return _It;
            }
        } else {
            _Position = lower_bound(_Key_val);
        }

        const auto _Dist = _Position._Key_it - _Begin._Key_it;
        {
            key_type _Key_to_insert(_STD forward<_OtherKey>(_Key_val));
            mapped_type _Mapped_to_insert(_STD forward<_MappedArgTypes>(_Args)...);
            _Insert_exact(_Position, _STD move(_Key_to_insert), _STD move(_Mapped_to_insert));
        }
        return begin() + _Dist;
    }

    void _Insert_exact(const_iterator _Position, key_type&& _Key_val, mapped_type&& _Mapped_val) {
        _Clear_flat_map_scope_guard _Guard{this};
        _Data.keys.insert(_Position._Key_it, _STD move(_Key_val));
        _Data.values.insert(_Position._Mapped_it, _STD move(_Mapped_val));
        _Guard._Clearable = nullptr;
    }

    template <class _KeyTy1, class _KeyTy2>
    bool _Key_equal(_KeyTy1&& _Left, _KeyTy2&& _Right) const {
        _STL_INTERNAL_STATIC_ASSERT(
            (is_same_v<remove_cvref_t<_KeyTy1>, key_type> && is_same_v<remove_cvref_t<_KeyTy2>, key_type>)
            || (is_constructible_v<key_type, _KeyTy1> && is_constructible_v<key_type, _KeyTy2>
                && _Is_transparent_v<key_compare>) );
        return !_Key_compare(_STD forward<_KeyTy1>(_Left), _STD forward<_KeyTy2>(_Right))
            && !_Key_compare(_STD forward<_KeyTy2>(_Right), _STD forward<_KeyTy1>(_Left));
    }

private:
    auto _View_to_mutate() {
        using _Mutating_iterator = _Pairing_iterator_provider<typename key_container_type::iterator,
            typename mapped_container_type::iterator, typename mapped_container_type::iterator>::_Iterator;
        return _RANGES subrange<_Mutating_iterator>{_Mutating_iterator{_Data.keys.begin(), _Data.values.begin()},
            _Mutating_iterator{_Data.keys.end(), _Data.values.end()}};
    }

    void _Sort() {
        _Clear_flat_map_scope_guard _Guard{this};
        _RANGES sort(_View_to_mutate(), value_compare(_Key_compare));
        _Guard._Clearable = nullptr;
    }

    void _Dedup() {
        _Clear_flat_map_scope_guard _Guard{this};
        auto _Sorted_view = _View_to_mutate();
        auto _Subrange    = _RANGES unique(_Sorted_view, [this](const_reference _Left, const_reference _Right) {
            return this->_Key_equal(_Left.first, _Right.first);
        });
        const auto _Remaining_count = _Subrange.begin() - _Sorted_view.begin();
        _Data.keys.erase(_Data.keys.begin() + _Remaining_count, _Data.keys.end());
        _Data.values.erase(_Data.values.begin() + _Remaining_count, _Data.values.end());
        _Guard._Clearable = nullptr;
    }

    template <bool _NeedSorting, bool _NeedDeduping, class _InputIterator>
        requires _Is_iterator_v<_InputIterator>
    void _Insert_range(_InputIterator _First, _InputIterator _Last) {
        _Clear_flat_map_scope_guard _Guard{this};

        // Insert the new elements at the end
        const size_type _Old_size = size();
        if constexpr (_Is_cpp17_fwd_iter_v<_InputIterator>) {
            const auto _New_size = static_cast<size_type>(_STD distance(_First, _Last));

            _Data.keys.reserve(_Data.keys.size() + _New_size);
            _Data.values.reserve(_Data.values.size() + _New_size);
        }

        for (; _First != _Last; ++_First) {
            value_type _Val = *_First;
            _Data.keys.emplace_back(_STD move(_Val.first));
            _Data.values.emplace_back(_STD move(_Val.second));
        }

        // Sort the newly inserted elements
        auto _Sorted_view = _View_to_mutate();
        if constexpr (_NeedSorting) {
            auto _Sorted_new_elements = _Sorted_view;
            _Sorted_new_elements.advance(_Old_size);
            _RANGES sort(_Sorted_new_elements, value_compare(_Key_compare));
        }

        // Merge the newly inserted elements with the existing elements
        _RANGES inplace_merge(_Sorted_view, _Sorted_view.begin() + _Old_size, value_compare(_Key_compare));

        if constexpr (_NeedDeduping) {
            _Dedup();
        }

        _Guard._Clearable = nullptr;
    }

    template <class _KeyTy>
    size_type _Erase_key(_KeyTy&& _Key_val) {
        const auto _Equal_pos = equal_range(_STD forward<_KeyTy>(_Key_val));
        const auto _Count     = static_cast<size_type>(_Equal_pos.second - _Equal_pos.first);
        erase(_Equal_pos.second, _Equal_pos.first);
        return _Count;
    }

    template <class _KeyTy>
    _NODISCARD iterator _Find(const _KeyTy& _Key_val) {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        iterator _Position = lower_bound(_Key_val);
        if (_Position != end() && !_Key_compare(_Key_val, _Position->first)) {
            return _Position;
        } else {
            return end();
        }
    }

    template <class _KeyTy>
    _NODISCARD const_iterator _Find(const _KeyTy& _Key_val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        const_iterator _Position = lower_bound(_Key_val);
        if (_Position != cend() && !_Key_compare(_Key_val, _Position->first)) {
            return _Position;
        } else {
            return cend();
        }
    }

    template <class _KeyTy>
    _NODISCARD size_type _Count(const _KeyTy& _Key_val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        return upper_bound(_Key_val) - lower_bound(_Key_val);
    }

    template <class _KeyTy>
    _NODISCARD bool _Contains(const _KeyTy& _Key_val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        return find(_Key_val) != cend();
    }

    template <class _KeyTy>
    _NODISCARD iterator _Lower_bound(const _KeyTy& _Key_val) {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        const auto _Key_unchecked_begin = _STD _Get_unwrapped(_Data.keys.cbegin());
        const auto _Key_unchecked_it =
            _STD lower_bound(_Key_unchecked_begin, _STD _Get_unwrapped(_Data.keys.cend()), _Key_val, _Key_compare);
        const auto _Dist = _Key_unchecked_it - _Key_unchecked_begin;

        auto _Key_it = _Data.keys.cbegin();
        _STD _Seek_wrapped(_Key_it, _Key_unchecked_it);
        auto _Val_it = _Data.values.begin() + _Dist;
        return iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    template <class _KeyTy>
    _NODISCARD const_iterator _Lower_bound(const _KeyTy& _Key_val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        const auto _Key_unchecked_begin = _STD _Get_unwrapped(_Data.keys.cbegin());
        const auto _Key_unchecked_it =
            _STD lower_bound(_Key_unchecked_begin, _STD _Get_unwrapped(_Data.keys.cend()), _Key_val, _Key_compare);
        const auto _Dist = _Key_unchecked_it - _Key_unchecked_begin;

        auto _Key_it = _Data.keys.cbegin();
        _STD _Seek_wrapped(_Key_it, _Key_unchecked_it);
        auto _Val_it = _Data.values.cbegin() + _Dist;
        return const_iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    template <class _KeyTy>
    _NODISCARD iterator _Upper_bound(const _KeyTy& _Key_val) {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        const auto _Key_unchecked_begin = _STD _Get_unwrapped(_Data.keys.cbegin());
        const auto _Key_unchecked_it =
            _STD upper_bound(_Key_unchecked_begin, _STD _Get_unwrapped(_Data.keys.cend()), _Key_val, _Key_compare);
        const auto _Dist = _Key_unchecked_it - _Key_unchecked_begin;

        auto _Key_it = _Data.keys.cbegin();
        _STD _Seek_wrapped(_Key_it, _Key_unchecked_it);
        auto _Val_it = _Data.values.begin() + _Dist;
        return iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    template <class _KeyTy>
    _NODISCARD const_iterator _Upper_bound(const _KeyTy& _Key_val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        const auto _Key_unchecked_begin = _STD _Get_unwrapped(_Data.keys.cbegin());
        const auto _Key_unchecked_it =
            _STD upper_bound(_Key_unchecked_begin, _STD _Get_unwrapped(_Data.keys.cend()), _Key_val, _Key_compare);
        const auto _Dist = _Key_unchecked_it - _Key_unchecked_begin;

        auto _Key_it = _Data.keys.cbegin();
        _STD _Seek_wrapped(_Key_it, _Key_unchecked_it);
        auto _Val_it = _Data.values.cbegin() + _Dist;
        return const_iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    template <class _KeyTy>
    _NODISCARD pair<iterator, iterator> _Equal_range(const _KeyTy& _Key_val) {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        return {lower_bound(_Key_val), upper_bound(_Key_val)};
    }

    template <class _KeyTy>
    _NODISCARD pair<const_iterator, const_iterator> _Equal_range(const _KeyTy& _Key_val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        return {lower_bound(_Key_val), upper_bound(_Key_val)};
    }
};

_EXPORT_STD template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer>
class flat_map : public _Flat_map_base<true, _Key, _Mapped, _Compare, _KeyContainer, _MappedContainer> {
private:
    using _MyBase = _Flat_map_base<true, _Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>;

    using _MyBase::_Data;
    using _MyBase::_Key_compare;

public:
    using typename _MyBase::const_iterator;
    using typename _MyBase::iterator;
    using typename _MyBase::key_compare;
    using typename _MyBase::key_type;
    using typename _MyBase::mapped_type;
    using typename _MyBase::value_type;

    using _MyBase::_MyBase;
    using _MyBase::operator=;

    // [flat.map.access] Access
    _NODISCARD mapped_type& operator[](const key_type& _Key_val) {
        return this->try_emplace(_Key_val).first->second;
    }
    _NODISCARD mapped_type& operator[](key_type&& _Key_val) {
        return this->try_emplace(_STD move(_Key_val)).first->second;
    }

    template <class _OtherKey>
    _NODISCARD mapped_type& operator[](_OtherKey&& _Key_val)
        requires _Is_transparent_v<key_compare>
    {
        return this->try_emplace(_STD forward<_OtherKey>(_Key_val)).first->second;
    }

    _NODISCARD mapped_type& at(const key_type& _Key_val) {
        return _At(_Key_val);
    }

    _NODISCARD const mapped_type& at(const key_type& _Key_val) const {
        return _At(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD mapped_type& at(const _OtherKey& _Key_val)
        requires _Is_transparent_v<key_compare>
    {
        return _At(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD const mapped_type& at(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _At(_Key_val);
    }

    // [flat.map.modifiers] Modifiers
    template <class... _ArgTypes>
    pair<iterator, bool> emplace(_ArgTypes&&... _Args)
        requires is_constructible_v<value_type, _ArgTypes...>
    {
        value_type _Val(_STD forward<_ArgTypes>(_Args)...);
        return try_emplace(_STD move(_Val.first), _STD move(_Val.second));
    }

    pair<iterator, bool> insert(const value_type& _Pair_val) {
        return try_emplace(_Pair_val.first, _Pair_val.second);
    }

    pair<iterator, bool> insert(value_type&& _Pair_val) {
        return try_emplace(_STD move(_Pair_val.first), _STD move(_Pair_val.second));
    }

    template <class _PairValTy>
    pair<iterator, bool> insert(_PairValTy&& _Pair_val)
        requires is_constructible_v<value_type, _PairValTy>
    {
        return emplace(_STD forward<_PairValTy>(_Pair_val));
    }

    template <class... _MappedArgTypes>
        requires is_constructible_v<mapped_type, _MappedArgTypes&&...>
    pair<iterator, bool> try_emplace(const key_type& _Key_val, _MappedArgTypes&&... _Mapped_args) {
        return _Try_emplace(_Key_val, _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class... _MappedArgTypes>
        requires is_constructible_v<mapped_type, _MappedArgTypes&&...>
    pair<iterator, bool> try_emplace(key_type&& _Key_val, _MappedArgTypes&&... _Mapped_args) {
        return _Try_emplace(_STD move(_Key_val), _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class _OtherKey, class... _MappedArgTypes>
        requires _Is_transparent_v<key_compare> && is_constructible_v<key_type, _OtherKey>
              && is_constructible_v<mapped_type, _MappedArgTypes...>
              && (!is_convertible_v<_OtherKey, const_iterator>) && (!is_convertible_v<_OtherKey, iterator>)
    pair<iterator, bool> try_emplace(_OtherKey&& _Key_val, _MappedArgTypes&&... _Mapped_args) {
        return _Try_emplace(_STD forward<_OtherKey>(_Key_val), _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class... _MappedArgTypes>
    iterator try_emplace(const_iterator _Position, const key_type& _Key_val, _MappedArgTypes&&... _Mapped_args)
        requires is_constructible_v<mapped_type, _MappedArgTypes...>
    {
        return this->template _Emplace_hint<false>(_Position, _Key_val, _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class... _MappedArgTypes>
    iterator try_emplace(const_iterator _Position, key_type&& _Key_val, _MappedArgTypes&&... _Mapped_args)
        requires is_constructible_v<mapped_type, _MappedArgTypes&&...>
    {
        return this->template _Emplace_hint<false>(
            _Position, _STD move(_Key_val), _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class _OtherKey, class... _MappedArgTypes>
    iterator try_emplace(const_iterator _Position, _OtherKey&& _Key_val, _MappedArgTypes&&... _Mapped_args)
        requires _Is_transparent_v<key_compare> && is_constructible_v<key_type, _OtherKey>
              && is_constructible_v<mapped_type, _MappedArgTypes&&...>
    {
        return this->template _Emplace_hint<false>(
            _Position, _STD forward<_OtherKey>(_Key_val), _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class _MappedTy>
    pair<iterator, bool> insert_or_assign(const key_type& _Key_val, _MappedTy&& _Mapped_val)
        requires is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return _Insert_or_assign(_Key_val, _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _MappedTy>
    pair<iterator, bool> insert_or_assign(key_type&& _Key_val, _MappedTy&& _Mapped_val)
        requires is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return _Insert_or_assign(_STD move(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _OtherKey, class _MappedTy>
    pair<iterator, bool> insert_or_assign(_OtherKey&& _Key_val, _MappedTy&& _Mapped_val)
        requires _Is_transparent_v<key_compare> && is_constructible_v<key_type, _OtherKey>
              && is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return _Insert_or_assign(_STD forward<_OtherKey>(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _MappedTy>
    iterator insert_or_assign(const_iterator _Position, const key_type& _Key_val, _MappedTy&& _Mapped_val)
        requires is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return this->template _Emplace_hint<true>(_Position, _Key_val, _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _MappedTy>
    iterator insert_or_assign(const_iterator _Position, key_type&& _Key_val, _MappedTy&& _Mapped_val)
        requires is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return this->template _Emplace_hint<true>(_Position, _STD move(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _OtherKey, class _MappedTy>
    iterator insert_or_assign(const_iterator _Position, _OtherKey&& _Key_val, _MappedTy&& _Mapped_val)
        requires _Is_transparent_v<key_compare> && is_constructible_v<key_type, _OtherKey>
              && is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return this->template _Emplace_hint<true>(
            _Position, _STD forward<_OtherKey>(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
    }

private:
    using _MyBase::_Emplace_hint;
    using _MyBase::_Erase_if;
    using _MyBase::_Insert_exact;
    using _MyBase::_Key_equal;

    template <class _KTy, class _MTy, class _Comp, class _KeyCont, class _MappedCont, class _Pred>
    friend typename flat_map<_KTy, _MTy, _Comp, _KeyCont, _MappedCont>::size_type erase_if(
        flat_map<_KTy, _MTy, _Comp, _KeyCont, _MappedCont>&, _Pred);

    template <class _KeyTy>
    _NODISCARD mapped_type& _At(const _KeyTy& _Key_val) {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        const auto _Position = this->find(_Key_val);
        if (_Position == this->end()) {
            _Xout_of_range("std::flat_map::at: the specified key does not exist.");
        }

        return _Position->second;
    }

    template <class _KeyTy>
    _NODISCARD const mapped_type& _At(const _KeyTy& _Key_val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        const auto _Position = this->find(_Key_val);
        if (_Position == this->end()) {
            _Xout_of_range("std::flat_map::at: the specified key does not exist.");
        }

        return _Position->second;
    }

    template <class _KeyTy, class... _MappedArgTypes>
    pair<iterator, bool> _Try_emplace(_KeyTy&& _Key_val, _MappedArgTypes&&... _Mapped_args) {
        auto _Key_it = _STD lower_bound(_Data.keys.begin(), _Data.keys.end(), _Key_val, _Key_compare);
        if (_Key_it != _Data.keys.end() && !_Key_compare(_STD forward<_KeyTy>(_Key_val), *_Key_it)) {
            // Already exists
            return {this->begin() + (_Key_it - _Data.keys.begin()), false};
        }

        // Need to insert
        const auto _Index = _Key_it - _Data.keys.begin();
        {
            key_type _Key_to_insert(_STD forward<_KeyTy>(_Key_val));
            mapped_type _Mapped_to_insert(_STD forward<_MappedArgTypes>(_Mapped_args)...);
            this->_Insert_exact(this->cbegin() + _Index, _STD move(_Key_to_insert), _STD move(_Mapped_to_insert));
        }
        return {this->begin() + _Index, true};
    }

    template <class _KeyTy, class _MappedTy>
    pair<iterator, bool> _Insert_or_assign(_KeyTy&& _Key_val, _MappedTy&& _Mapped_val) {
        auto _Res = _Try_emplace(_STD forward<_KeyTy>(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
        if (!_Res.second) { // Already exists
            _Res.first->second = _STD forward<_MappedTy>(_Mapped_val);
        }
        return _Res;
    }
};

template <class _KeyContainer, class _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare = less<typename _KeyContainer::value_type>>
flat_map(_KeyContainer, _MappedContainer, _Compare = _Compare()) -> flat_map<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, _Compare, _KeyContainer, _MappedContainer>;

template <class _KeyContainer, class _MappedContainer,
    _Valid_allocator_for_flat_map<_KeyContainer, _MappedContainer> _Allocator>
flat_map(_KeyContainer, _MappedContainer, _Allocator) -> flat_map<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, less<typename _KeyContainer::value_type>, _KeyContainer, _MappedContainer>;

template <class _KeyContainer, class _MappedContainer, _Valid_compare_for_container<_KeyContainer> _Compare,
    _Valid_allocator_for_flat_map<_KeyContainer, _MappedContainer> _Allocator>
flat_map(_KeyContainer, _MappedContainer, _Compare, _Allocator) -> flat_map<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, _Compare, _KeyContainer, _MappedContainer>;

template <class _KeyContainer, class _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare = less<typename _KeyContainer::value_type>>
flat_map(sorted_unique_t, _KeyContainer, _MappedContainer, _Compare = _Compare())
    -> flat_map<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <class _KeyContainer, class _MappedContainer,
    _Valid_allocator_for_flat_map<_KeyContainer, _MappedContainer> _Allocator>
flat_map(sorted_unique_t, _KeyContainer, _MappedContainer, _Allocator) -> flat_map<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, less<typename _KeyContainer::value_type>, _KeyContainer, _MappedContainer>;

template <class _KeyContainer, class _MappedContainer, _Valid_compare_for_container<_KeyContainer> _Compare,
    _Valid_allocator_for_flat_map<_KeyContainer, _MappedContainer> _Allocator>
flat_map(sorted_unique_t, _KeyContainer, _MappedContainer, _Compare, _Allocator)
    -> flat_map<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <class _InputIterator, class _Compare = less<_Guide_key_t<_InputIterator>>>
flat_map(_InputIterator, _InputIterator, _Compare = _Compare())
    -> flat_map<_Guide_key_t<_InputIterator>, _Guide_val_t<_InputIterator>, _Compare>;

template <class _InputIterator, class _Compare = less<_Guide_key_t<_InputIterator>>>
flat_map(sorted_unique_t, _InputIterator, _InputIterator, _Compare = _Compare())
    -> flat_map<_Guide_key_t<_InputIterator>, _Guide_val_t<_InputIterator>, _Compare>;

#ifdef __cpp_lib_byte
template <_RANGES input_range _Rng, class _Compare = less<_Range_key_type<_Rng>>, class _Allocator = allocator<byte>>
flat_map(from_range_t, _Rng&&, _Compare = _Compare(), _Allocator = _Allocator())
    -> flat_map<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>, _Compare,
        vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
        vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;
#else // ^^^ defined(__cpp_lib_byte) / !defined(__cpp_lib_byte) vvv
template <_RANGES input_range _Rng, class _Compare = less<_Range_key_type<_Rng>>>
flat_map(from_range_t, _Rng&&, _Compare = _Compare()) -> flat_map<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>,
    _Compare, vector<_Range_key_type<_Rng>, allocator<_Range_key_type<_Rng>>>,
    vector<_Range_mapped_type<_Rng>, allocator<_Range_mapped_type<_Rng>>>>;

template <_RANGES input_range _Rng, class _Compare, class _Allocator>
flat_map(from_range_t, _Rng&&, _Compare, _Allocator) -> flat_map<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>,
    _Compare, vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
    vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;
#endif // ^^^ !defined(__cpp_lib_byte) ^^^

template <_RANGES input_range _Rng, class _Allocator>
flat_map(from_range_t, _Rng&&, _Allocator) -> flat_map<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>,
    less<_Range_key_type<_Rng>>, vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
    vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;

template <class _Key, class _Mapped, class _Compare = less<_Key>>
flat_map(initializer_list<pair<_Key, _Mapped>>, _Compare = _Compare()) -> flat_map<_Key, _Mapped, _Compare>;

template <class _Key, class _Mapped, class _Compare = less<_Key>>
flat_map(sorted_unique_t, initializer_list<pair<_Key, _Mapped>>, _Compare = _Compare())
    -> flat_map<_Key, _Mapped, _Compare>;

// Specialization of uses_allocator
template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer, class _Allocator>
struct uses_allocator<flat_map<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>, _Allocator>
    : bool_constant<uses_allocator_v<_KeyContainer, _Allocator> && uses_allocator_v<_MappedContainer, _Allocator>> {};

_EXPORT_STD template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer,
    class _Predicate>
flat_map<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>::size_type erase_if(
    flat_map<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>& _Cont, _Predicate _Pred) {
    return _Cont._Erase_if(_STD _Pass_fn(_Pred));
}

_EXPORT_STD template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer>
class flat_multimap : public _Flat_map_base<false, _Key, _Mapped, _Compare, _KeyContainer, _MappedContainer> {
private:
    using _MyBase = _Flat_map_base<false, _Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>;

    using _MyBase::_Data;
    using _MyBase::_Key_compare;

public:
    using typename _MyBase::iterator;
    using typename _MyBase::value_type;

    using _MyBase::_MyBase;
    using _MyBase::operator=;

    // [flat.multimap.modifiers] Modifiers
    template <class... _ArgTypes>
    iterator emplace(_ArgTypes&&... _Args) {
        value_type _Val(_STD forward<_ArgTypes>(_Args)...);
        return _Emplace_key_mapped(_STD move(_Val.first), _STD move(_Val.second));
    }

    iterator insert(const value_type& _Px) {
        return _Emplace_key_mapped(_Px.first, _Px.second);
    }

    iterator insert(value_type&& _Px) {
        return _Emplace_key_mapped(_STD move(_Px.first), _STD move(_Px.second));
    }

    template <class _PairValTy>
    iterator insert(_PairValTy&& _Pair_val)
        requires is_constructible_v<value_type, _PairValTy>
    {
        return emplace(_STD forward<_PairValTy>(_Pair_val));
    }

private:
    using _MyBase::_Emplace_hint;
    using _MyBase::_Erase_if;
    using _MyBase::_Insert_exact;
    using _MyBase::_Key_equal;

    template <class _KTy, class _MTy, class _Comp, class _KeyCont, class _MappedCont, class _Pred>
    friend typename flat_multimap<_KTy, _MTy, _Comp, _KeyCont, _MappedCont>::size_type erase_if(
        flat_multimap<_KTy, _MTy, _Comp, _KeyCont, _MappedCont>&, _Pred);

    template <class _KeyTy, class _MappedTy>
    iterator _Emplace_key_mapped(_KeyTy&& _Key_val, _MappedTy&& _Mapped_val) {
        const auto _Key_it = _STD lower_bound(_Data.keys.begin(), _Data.keys.end(), _Key_val, _Key_compare);
        const auto _Index  = _Key_it - _Data.keys.begin();

        {
            _Key _Key_to_insert(_STD forward<_KeyTy>(_Key_val));
            _Mapped _Mapped_to_insert(_STD forward<_MappedTy>(_Mapped_val));
            this->_Insert_exact(this->cbegin() + _Index, _STD move(_Key_to_insert), _STD move(_Mapped_to_insert));
        }
        return this->begin() + _Index;
    }
};

template <class _KeyContainer, class _MappedContainer, class _Compare = less<typename _KeyContainer::value_type>>
flat_multimap(_KeyContainer, _MappedContainer, _Compare = _Compare())
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <class _KeyContainer, class _MappedContainer, class _Allocator>
flat_multimap(_KeyContainer, _MappedContainer, _Allocator) -> flat_multimap<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, less<typename _KeyContainer::value_type>, _KeyContainer, _MappedContainer>;
template <class _KeyContainer, class _MappedContainer, class _Compare, class _Allocator>
flat_multimap(_KeyContainer, _MappedContainer, _Compare, _Allocator)
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <class _KeyContainer, class _MappedContainer, class _Compare = less<typename _KeyContainer::value_type>>
flat_multimap(sorted_equivalent_t, _KeyContainer, _MappedContainer, _Compare = _Compare())
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <class _KeyContainer, class _MappedContainer, class _Allocator>
flat_multimap(sorted_equivalent_t, _KeyContainer, _MappedContainer, _Allocator)
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type,
        less<typename _KeyContainer::value_type>, _KeyContainer, _MappedContainer>;
template <class _KeyContainer, class _MappedContainer, class _Compare, class _Allocator>
flat_multimap(sorted_equivalent_t, _KeyContainer, _MappedContainer, _Compare, _Allocator)
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <class _InputIterator, class _Compare = less<_Guide_key_t<_InputIterator>>>
flat_multimap(_InputIterator, _InputIterator, _Compare = _Compare())
    -> flat_multimap<_Guide_key_t<_InputIterator>, _Guide_val_t<_InputIterator>, _Compare>;

template <class _InputIterator, class _Compare = less<_Guide_key_t<_InputIterator>>>
flat_multimap(sorted_equivalent_t, _InputIterator, _InputIterator, _Compare = _Compare())
    -> flat_multimap<_Guide_key_t<_InputIterator>, _Guide_val_t<_InputIterator>, _Compare>;

#ifdef __cpp_lib_byte
template <_RANGES input_range _Rng, class _Compare = less<_Range_key_type<_Rng>>, class _Allocator = allocator<byte>>
flat_multimap(from_range_t, _Rng&&, _Compare = _Compare(), _Allocator = _Allocator())
    -> flat_multimap<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>, _Compare,
        vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
        vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;
#else // ^^^ defined(__cpp_lib_byte) / !defined(__cpp_lib_byte) vvv
template <_RANGES input_range _Rng, class _Compare = less<_Range_key_type<_Rng>>>
flat_multimap(from_range_t, _Rng&&, _Compare = _Compare()) -> flat_multimap<_Range_key_type<_Rng>,
    _Range_mapped_type<_Rng>, _Compare, vector<_Range_key_type<_Rng>, allocator<_Range_key_type<_Rng>>>,
    vector<_Range_mapped_type<_Rng>, allocator<_Range_mapped_type<_Rng>>>>;

template <_RANGES input_range _Rng, class _Compare, class _Allocator>
flat_multimap(from_range_t, _Rng&&, _Compare, _Allocator)
    -> flat_multimap<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>, _Compare,
        vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
        vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;
#endif // ^^^ !defined(__cpp_lib_byte) ^^^

template <_RANGES input_range _Rng, class _Allocator>
flat_multimap(from_range_t, _Rng&&, _Allocator) -> flat_multimap<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>,
    less<_Range_key_type<_Rng>>, vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
    vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;

template <class _Key, class _Mapped, class _Compare = less<_Key>>
flat_multimap(initializer_list<pair<_Key, _Mapped>>, _Compare = _Compare()) -> flat_multimap<_Key, _Mapped, _Compare>;

template <class _Key, class _Mapped, class _Compare = less<_Key>>
flat_multimap(sorted_equivalent_t, initializer_list<pair<_Key, _Mapped>>, _Compare = _Compare())
    -> flat_multimap<_Key, _Mapped, _Compare>;

// Specialization of uses_allocator
template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer, class _Allocator>
struct uses_allocator<flat_multimap<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>, _Allocator>
    : bool_constant<uses_allocator_v<_KeyContainer, _Allocator> && uses_allocator_v<_MappedContainer, _Allocator>> {};

_EXPORT_STD template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer,
    class _Predicate>
flat_multimap<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>::size_type erase_if(
    flat_multimap<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>& _Cont, _Predicate _Pred) {
    return _Cont._Erase_if(_STD _Pass_fn(_Pred));
}
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // ^^^ _HAS_CXX23 ^^^
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _FLAT_MAP_
