// flat_map standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _FLAT_MAP_
#define _FLAT_MAP_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR

#include <algorithm>
#include <compare>
#include <concepts>
#include <cstdint>
#include <initializer_list>
#include <memory>
#include <ranges>
#include <type_traits>
#include <utility>
#include <vector>
#include <xmemory>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN

template <class Key, class T, class Compare = less<Key>, class KeyContainer = vector<Key>,
    class MappedContainer = vector<T>>
    requires same_as<Key, typename KeyContainer::value_type> && same_as<T, typename MappedContainer::value_type>
class flat_map;

struct sorted_unique_t {
    explicit sorted_unique_t() = default;
};
inline constexpr sorted_unique_t sorted_unique{};

template <class _Alloc, class _Key_container, class _Mapped_container>
concept _Valid_Allocator_for_flat_map =
    _STD uses_allocator_v<_Key_container, _Alloc> && _STD uses_allocator_v<_Mapped_container, _Alloc>;

template <class _Compare>
concept _Compare_is_transparent = requires { typename _Compare::is_transparent; };

template <class _Key, class _T, class _Key_compare>
struct _Flat_value_compare {
    struct value_compare {
    public:
        bool operator()(_STD pair<const _Key&, const _T&> _X, _STD pair<const _Key&, const _T&> _Y) const {
            return _Key_compare_for_val(_X.first, _Y.first);
        }

        value_compare(_Key_compare _Comp) : _Key_compare_for_val(_Comp) {}

    private:
        _Key_compare _Key_compare_for_val;
    };
};

template <class _Key_container, class _Mapped_container>
struct _Flat_Container {
    struct container {
        _Key_container keys;
        _Mapped_container values;
    };
};

// Implementation

template <_STD random_access_iterator _Key_iterator_t, _STD random_access_iterator _Mapped_iterator_t>
class _Flat_map_iterator_Impl {
public:
    class type {
    public:
        template <class Key, class T, class Compare, class KeyContainer, class MappedContainer> requires same_as<Key, typename KeyContainer::value_type> && same_as<T, typename MappedContainer::value_type>
        friend class flat_map;
        type() = default;
        type(_Key_iterator_t _Key_it, _Mapped_iterator_t _Mapped_it) : _Key_it(_Key_it), _Mapped_it(_Mapped_it) {}
        // Copy-constructible
        type(const type&) = default;
        // Copy-assignable
        type& operator=(const type&) = default;
        // Move-assignable
        type& operator=(type&&) = default;
        // Swappable
        // Destructible
        ~type() = default;

        using iterator_category = input_iterator_tag;
        using iterator_concept  = random_access_iterator_tag;
        using difference_type   = ptrdiff_t;
        using value_type        = _STD pair<_STD iter_value_t<_Key_iterator_t>, _STD iter_value_t<_Mapped_iterator_t>>;

    private:
        class _Arrow_Proxy: public _STD pair<_STD iter_const_reference_t<_Key_iterator_t>, _STD iter_reference_t<_Mapped_iterator_t>> {
        public:
            using _STD pair<_STD iter_const_reference_t<_Key_iterator_t>, _STD iter_reference_t<_Mapped_iterator_t>>::pair;
            _Arrow_Proxy* operator->() noexcept {
                return this;
            }
        };

    public:
        using pointer           = _Arrow_Proxy;
        using reference         = _STD pair<_STD iter_const_reference_t<_Key_iterator_t>, _STD iter_reference_t<_Mapped_iterator_t>>;

        reference operator*() const {
            return reference {*_Key_it, *_Mapped_it};
        }

        pointer operator->() const {
            return pointer {*_Key_it, *_Mapped_it};
        }

        type& operator++() {
            ++_Key_it;
            ++_Mapped_it;
            return *this;
        }

        type operator++(int) {
            type _Tmp = *this;
            ++*this;
            return _Tmp;
        }

        bool operator==(const type& _Right) const {
            return _Key_it == _Right._Key_it;
        }

        auto operator<=>(const type& _Right) const {
            return _Key_it <=> _Right._Key_it;
        }

        type& operator--() {
            --_Key_it;
            --_Mapped_it;
            return *this;
        }

        type operator--(int) {
            type _Tmp = *this;
            --*this;
            return _Tmp;
        }

        type& operator+=(difference_type _Off) {
            _Key_it += _Off;
            _Mapped_it += _Off;
            return *this;
        }

        type& operator-=(difference_type _Off) {
            _Key_it -= _Off;
            _Mapped_it -= _Off;
            return *this;
        }

        type operator+(difference_type _Off) const {
            type _Tmp = *this;
            return _Tmp += _Off;
        }

        type operator-(difference_type _Off) const {
            type _Tmp = *this;
            return _Tmp -= _Off;
        }

        reference operator[](difference_type _Off) const {
            return *(*this + _Off);
        }

        difference_type operator-(const type& _Right) const {
            return _Key_it - _Right._Key_it;
        }

        friend type operator+(difference_type _Off, const type& _Right);

    private:
        _Key_iterator_t _Key_it;
        _Mapped_iterator_t _Mapped_it;
    };

    static_assert(_STD swappable<type>);
};

template <_STD random_access_iterator _Key_iterator_t, _STD random_access_iterator _Mapped_iterator_t>
_EXPORT_STD typename _Flat_map_iterator_Impl<_Key_iterator_t, _Mapped_iterator_t>::type operator+(
    typename _Flat_map_iterator_Impl<_Key_iterator_t, _Mapped_iterator_t>::type::difference_type _Off,
    const typename _Flat_map_iterator_Impl<_Key_iterator_t, _Mapped_iterator_t>::type& _Right) {
    return _Right + _Off;
}

_EXPORT_STD
template <class Key, class T, class Compare, class KeyContainer, class MappedContainer>
    requires same_as<Key, typename KeyContainer::value_type> && same_as<T, typename MappedContainer::value_type>
class flat_map {
public:
    using key_type               = Key;
    using mapped_type            = T;
    using value_type             = pair<key_type, mapped_type>;
    using key_compare            = Compare;
    using reference              = pair<const key_type&, mapped_type&>;
    using const_reference        = pair<const key_type&, const mapped_type&>;
    using size_type              = size_t;
    using difference_type        = ptrdiff_t;
    using key_container_type     = KeyContainer;
    using mapped_container_type  = MappedContainer;
    using iterator               = typename _STD _Flat_map_iterator_Impl<typename key_container_type::const_iterator,
        typename mapped_container_type::iterator>::type;
    using const_iterator         = typename _STD _Flat_map_iterator_Impl<typename key_container_type::const_iterator,
        typename mapped_container_type::const_iterator>::type;
    using reverse_iterator       = _STD reverse_iterator<iterator>;
    using const_reverse_iterator = _STD reverse_iterator<const_iterator>;

    static_assert(_STD random_access_iterator<iterator>);

    using value_compare = typename _STD _Flat_value_compare<key_type, mapped_type, key_compare>::value_compare;
    using containers    = typename _STD _Flat_Container<key_container_type, mapped_container_type>::container;

private:
    template <class T> requires same_as<remove_cvref_t<T>, flat_map>
    using _Maybe_const_iterator_t = _STD conditional_t<_STD is_const_v<_STD remove_reference_t<T>>, const_iterator, iterator>;

public:
    // [flat.map.cons] Constructors
    explicit flat_map(const key_compare& _Comp) : _Key_compare(_Comp), _Data() {}
    flat_map() : flat_map(key_compare()) {}

    template <_Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    explicit flat_map(const Allocator& _Alloc) : flat_map(key_compare(), _Alloc) {}

    template <_Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    explicit flat_map(const key_compare& _Comp, const Allocator& _Alloc)
        : _Key_compare(_Comp), _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc),
                                   .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc)} {}

    flat_map(key_container_type _Key_cont, mapped_container_type _Mapped_cont)
        : flat_map(sorted_unique_t(), _Key_cont, _Mapped_cont) {
        _SortAndDedup();
    }

    template <_Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    flat_map(const key_container_type& _Key_cont, const mapped_container_type& _Mapped_cont, const Allocator& _Alloc)
        : flat_map(sorted_unique_t(), _Key_cont, _Mapped_cont, _Alloc) {
        _SortAndDedup();
    }

    flat_map(sorted_unique_t _Sorted_unique, key_container_type _Key_cont, mapped_container_type _Mapped_cont)
        : _Key_compare(key_compare()), _Data{.keys = _STD move(_Key_cont), .values = _STD move(_Mapped_cont)} {}

    template <_Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    flat_map(sorted_unique_t _Sorted_unique, const key_container_type& _Key_cont,
        const mapped_container_type& _Mapped_cont, const Allocator& _Alloc)
        : _Key_compare(key_compare()),
          _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc, _Key_cont),
              .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc, _Mapped_cont)} {}

    template <_STD input_iterator _InputIterator>
    flat_map(_InputIterator _First, _InputIterator _Last, const key_compare& _Comp = key_compare()) : flat_map(_Comp) {
        insert(_First, _Last);
    }

    template <_STD input_iterator _InputIterator,
        _Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    flat_map(_InputIterator _First, _InputIterator _Last, const key_compare& _Comp, const Allocator& _Alloc)
        : flat_map(_Comp, _Alloc) {
        insert(_First, _Last);
    }

    template <_Container_compatible_range<value_type> R>
    flat_map(_STD from_range_t _From_range, R&& _Range)
        : flat_map(_From_range, _STD forward<R>(_Range), key_compare()) {}

    template <_Container_compatible_range<value_type> R,
        _Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    flat_map(_STD from_range_t _From_range, R&& _Range, const Allocator& _Alloc)
        : flat_map(_From_range, _STD forward<R>(_Range), key_compare(), _Alloc) {}

    template <_Container_compatible_range<value_type> R>
    flat_map(_STD from_range_t _From_range, R&& _Range, const key_compare& _Comp) : flat_map(_Comp) {
        insert_range(_STD forward<R>(_Range));
    }

    template <_Container_compatible_range<value_type> R,
        _Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    flat_map(_STD from_range_t _From_range, R&& _Range, const key_compare& _Comp, const Allocator& _Alloc)
        : flat_map(_Comp, _Alloc) {
        insert_range(_STD forward<R>(_Range));
    }

    template <_STD input_iterator _InputIterator>
    flat_map(sorted_unique_t _S, _InputIterator _First, _InputIterator _Last, const key_compare& _Comp = key_compare())
        : flat_map(_Comp) {
        insert(_S, _First, _Last);
    }

    template <_STD input_iterator _InputIterator,
        _Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    flat_map(sorted_unique_t _S, _InputIterator _First, _InputIterator _Last, const key_compare& _Comp,
        const Allocator& _Alloc)
        : flat_map(_Comp, _Alloc) {
        insert(_S, _First, _Last);
    }

    template <_STD input_iterator _InputIterator,
        _Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    flat_map(sorted_unique_t _S, _InputIterator _First, _InputIterator _Last, const Allocator& _Alloc)
        : flat_map(_S, _First, _Last, key_compare(), _Alloc) {}

    flat_map(initializer_list<value_type> _I, const key_compare& _Comp = key_compare())
        : flat_map(_I.begin(), _I.end(), _Comp) {}

    template <_Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    flat_map(initializer_list<value_type> _I, const key_compare& _Comp, const Allocator& _Alloc)
        : flat_map(_I.begin(), _I.end(), _Comp, _Alloc) {}

    template <_Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    flat_map(initializer_list<value_type> _I, const Allocator& _Alloc) : flat_map(_I, key_compare(), _Alloc) {}

    flat_map(sorted_unique_t _S, initializer_list<value_type> _I, const key_compare& _Comp = key_compare())
        : flat_map(_S, _I.begin(), _I.end(), _Comp) {}

    template <_Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    flat_map(sorted_unique_t _S, initializer_list<value_type> _I, const key_compare& _Comp, const Allocator& _Alloc)
        : flat_map(_S, _I.begin(), _I.end(), _Comp, _Alloc) {}

    template <_Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    flat_map(sorted_unique_t _S, initializer_list<value_type> _I, const Allocator& _Alloc)
        : flat_map(_S, _I, key_compare(), _Alloc) {}

    flat_map& operator=(initializer_list<value_type> _I) {
        clear();
        insert(_I.begin(), _I.end());
        return *this;
    }

    // [container.reqmts] iterators
    template <class _Self_t>
    _NODISCARD auto begin(this _Self_t&& _Self) noexcept {
        return _Maybe_const_iterator_t<_Self_t&&> { _Self._Data.keys.cbegin(), _Self._Data.values.begin() };
    }

    template <class _Self_t>
    _NODISCARD auto end(this _Self_t&& _Self) noexcept {
        return _Maybe_const_iterator_t<_Self_t&&> { _Self._Data.keys.cend(), _Self._Data.values.end() };
    }

    template <class _Self_t>
    _NODISCARD auto rbegin(this _Self_t&& _Self) noexcept {
        return _STD make_reverse_iterator(_Self.end());
    }

    template <class _Self_t>
    _NODISCARD auto rend(this _Self_t&& _Self) noexcept {
        return _STD make_reverse_iterator(_Self.begin());
    }

    _NODISCARD const_iterator cbegin() const noexcept {
        return const_iterator {_Data.keys.cbegin(), _Data.values.cbegin()};
    }

    _NODISCARD const_iterator cend() const noexcept {
        return const_iterator {_Data.keys.cend(), _Data.values.cend()};
    }

    _NODISCARD const_reverse_iterator crbegin() const noexcept {
        return _STD make_reverse_iterator(cend());
    }

    _NODISCARD const_reverse_iterator crend() const noexcept {
        return _STD make_reverse_iterator(cbegin());
    }

    // [container.reqmts] clear
    void clear() noexcept {
        _Data.keys.clear();
        _Data.values.clear();
    }

    // [flat.map.capacity] Capacity
    _NODISCARD_EMPTY_MEMBER bool empty() const noexcept {
        return _Data.keys.empty();
    }

    _NODISCARD size_type size() const noexcept {
        return _Data.keys.size();
    }

    _NODISCARD size_type max_size() const noexcept {
        return _STD min(_Data.keys.max_size(), _Data.values.max_size());
    }

    // [flat.map.access] Access
    _NODISCARD mapped_type& operator[](const key_type& _Key); // TODO: implement
    _NODISCARD mapped_type& operator[](key_type&& _Key); // TODO: implement
    template <class _C>
    _NODISCARD mapped_type& operator[](_C&& _Key)
        requires _Compare_is_transparent<key_compare>; // TODO: implement

    template <class _Self_t>
    _NODISCARD auto&& at(this _Self_t&& _Self, const key_type& _Key); // TODO: implement
    template <class _Self_t, class _C>
    _NODISCARD auto&& at(this _Self_t&& _Self, const _C& _Key)
        requires _Compare_is_transparent<key_compare>; // TODO: implement

    // [flat.map.modifiers] Modifiers
    template <class... _Args_t>
    _STD pair<iterator, bool> emplace(_Args_t&&... _Args) requires _STD is_constructible_v<value_type, _Args_t...> {
        value_type _Val(_STD forward<_Args_t>(_Args)...);
        iterator _It = lower_bound(_Data.keys.begin(), _Data.keys.end(), _Val.first, _Key_compare);

        if(_It != end() && *(_It._Key_it) == _Val.first) {
            // Already exists
            return _STD make_pair(_It, false);
        }
        else{
            // Need to insert
            auto _Index = _STD distance(begin(), _It);
            _Data.keys.insert(_It._Key_it, _STD move(_Val.first));
            _Data.values.insert(_It._Mapped_it, _STD move(_Val.second));
            // Note: Consider _It invalidated by the insert operation
            return _STD make_pair(begin() + _Index, true);
        }
    }

    // observers
    key_compare key_comp() const {
        return _Key_compare;
    }

    value_compare value_comp() const {
        return value_compare(_Key_compare);
    }

    const key_container_type& keys() const noexcept {
        return _Data.keys;
    }

    const mapped_container_type& values() const noexcept {
        return _Data.values;
    }

    // map operations
    template<class _Self_t>
    auto lower_bound(this _Self_t&& _Self, const key_type& _X) {
        auto _Key_it = _STD lower_bound(_Self._Data.keys.begin(), _Self._Data.keys.end(), _X, _Self._Key_compare);
        auto _Dist = _STD distance(_Self._Data.keys.begin(), _Key_it);
        auto _Val_it = _Self._Data.values.begin() + _Dist;
        return _Maybe_const_iterator_t<_Self_t&&> { _STD move(_Key_it), _STD move(_Val_it) };
    }

private:
    key_compare _Key_compare;
    containers _Data;

    struct _Key_equal {
        key_compare _Key_compare;
        _Key_equal(key_compare _Comp) : _Key_compare(_Comp) {}
        bool operator()(const_reference _X, const_reference _Y) const {
            return !_Key_compare(_X.first, _Y.first) && !_Key_compare(_Y.first, _X.first);
        }
    };

    void _SortAndDedup() {
        auto _Zip_view = _RANGES views::zip(_Data.keys, _Data.values);
        _RANGES sort(_Zip_view, value_compare(_Key_compare));

        auto _Subrange        = _RANGES unique(_Zip_view, _Key_equal(_Key_compare));
        auto _Remaining_count = _STD distance(_Zip_view.begin(), _Subrange.begin());

        _Data.keys.erase(_Data.keys.begin() + _Remaining_count, _Data.keys.end());
        _Data.values.erase(_Data.values.begin() + _Remaining_count, _Data.values.end());
    }
};

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _FLAT_MAP_
