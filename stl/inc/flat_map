// flat_map standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _FLAT_MAP_
#define _FLAT_MAP_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR
#if !_HAS_CXX23 || !defined(__cpp_lib_concepts) // TRANSITION, GH-395
_EMIT_STL_WARNING(STL4038, "The contents of <flat_map> are available only with C++23 or later.");
#else // ^^^ not supported / supported language mode vvv

#include <algorithm>
#include <compare>
#include <concepts>
#include <initializer_list>
#include <type_traits>
#include <utility>
#include <vector>
#include <xmemory>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN

template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer, bool _IsMulti,
    class _Derived>
    requires same_as<_Key, typename _KeyContainer::value_type>
          && same_as<_Mapped, typename _MappedContainer::value_type>
class _Flat_map_base;

template <class _Key, class _Mapped, class _Compare = less<_Key>, class _KeyContainer = vector<_Key>,
    class _MappedContainer = vector<_Mapped>>
class flat_map;

template <class _Key, class _Mapped, class _Compare = less<_Key>, class _KeyContainer = vector<_Key>,
    class _MappedContainer = vector<_Mapped>>
class flat_multimap;

struct sorted_unique_t {
    explicit sorted_unique_t() = default;
};
inline constexpr sorted_unique_t sorted_unique{};

struct sorted_equivalent_t {
    explicit sorted_equivalent_t() = default;
};
inline constexpr sorted_equivalent_t sorted_equivalent{};

template <class _Alloc, class _Key_container, class _Mapped_container>
concept _Valid_allocator_for_flat_map =
    uses_allocator_v<_Key_container, _Alloc> && uses_allocator_v<_Mapped_container, _Alloc>;

template <class _Compare, class _Key_container>
concept _Valid_compare_for_container = is_invocable_v<const _Compare&, const typename _Key_container::value_type&,
    const typename _Key_container::value_type&>;

template <class _Key, class _Mapped, class _KeyCompare>
struct _Flat_map_value_compare_provider {
    struct value_compare {
    public:
        bool operator()(pair<const _Key&, const _Mapped&> _Left, pair<const _Key&, const _Mapped&> _Right) const {
            return _Key_comparator(_Left.first, _Right.first);
        }

        value_compare(_KeyCompare _Comp) : _Key_comparator(_Comp) {}

    private:
        _KeyCompare _Key_comparator;
    };
};

template <class _KeyContainer, class _MappedContainer>
struct _Flat_map_container_provider {
    struct containers {
        _KeyContainer keys;
        _MappedContainer values;
    };
};

template <class _Ty>
struct _NODISCARD _Clear_flat_map_scope_guard {
    _Ty* _Clearable;
    _Clear_flat_map_scope_guard(_Ty* _Clearable) : _Clearable(_Clearable) {}

    ~_Clear_flat_map_scope_guard() {
        if (_Clearable) {
            _Clearable->clear();
        }
    }
};

// Implementation

template <class _KeyIter, class _MappedIter, class _MappedConvIter>
struct _Pairing_iterator_provider {
    class _Iterator {
    public:
        template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer, bool _IsMulti,
            class _Derived>
            requires same_as<_Key, typename _KeyContainer::value_type>
                  && same_as<_Mapped, typename _MappedContainer::value_type>
        friend class _Flat_map_base;

        _Iterator() = default;
        _Iterator(_KeyIter _Key_iter, _MappedIter _Mapped_iter) : _Key_it(_Key_iter), _Mapped_it(_Mapped_iter) {}

        using iterator_category = input_iterator_tag;
        using iterator_concept  = random_access_iterator_tag;
        using difference_type   = ptrdiff_t;
        using value_type        = pair<iter_value_t<_KeyIter>, iter_value_t<_MappedIter>>;
        using reference         = pair<iter_reference_t<_KeyIter>, iter_reference_t<_MappedIter>>;

    private:
        using _Const_iterator =
            typename _Pairing_iterator_provider<_KeyIter, _MappedConvIter, _MappedConvIter>::_Iterator;

        class _Arrow_proxy {
        public:
            explicit _Arrow_proxy(const reference& _Rx) noexcept : _Ref{_Rx} {}

            const reference* operator->() const noexcept {
                return _STD addressof(_Ref);
            }

        private:
            reference _Ref;
        };

    public:
        using pointer = _Arrow_proxy;

        reference operator*() const {
            return reference{*_Key_it, *_Mapped_it};
        }

        pointer operator->() const {
            return pointer{*(*this)};
        }

        _Iterator& operator++() {
            ++_Key_it;
            ++_Mapped_it;
            return *this;
        }

        _Iterator operator++(int) {
            auto _Old = *this;
            ++*this;
            return _Old;
        }

        bool operator==(const _Iterator& _Right) const {
            return _Key_it == _Right._Key_it;
        }

        auto operator<=>(const _Iterator& _Right) const {
            return _Key_it <=> _Right._Key_it;
        }

        _Iterator& operator--() {
            --_Key_it;
            --_Mapped_it;
            return *this;
        }

        _Iterator operator--(int) {
            auto _Old = *this;
            --*this;
            return _Old;
        }

        _Iterator& operator+=(const difference_type _Off) {
            _Key_it += _Off;
            _Mapped_it += _Off;
            return *this;
        }

        _Iterator& operator-=(const difference_type _Off) {
            _Key_it -= _Off;
            _Mapped_it -= _Off;
            return *this;
        }

        _Iterator operator+(const difference_type _Off) const {
            auto _Old = *this;
            _Old += _Off;
            return _Old;
        }

        _Iterator operator-(const difference_type _Off) const {
            auto _Old = *this;
            _Old -= _Off;
            return _Old;
        }

        reference operator[](const difference_type _Off) const {
            return *(*this + _Off);
        }

        difference_type operator-(const _Iterator& _Right) const {
            return _Key_it - _Right._Key_it;
        }

        friend _Iterator operator+(const difference_type _Off, const _Iterator& _Right) {
            return _Right + _Off;
        }

        operator _Const_iterator() const
            requires (!is_same_v<_MappedIter, _MappedConvIter>)
        {
            return _Const_iterator{_Key_it, _Mapped_it};
        }

    private:
        _KeyIter _Key_it;
        _MappedIter _Mapped_it;
    };

    _STL_INTERNAL_STATIC_ASSERT(swappable<_Iterator>);
};

_EXPORT_STD
template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer, bool _IsMulti,
    class _Derived>
    requires same_as<_Key, typename _KeyContainer::value_type>
          && same_as<_Mapped, typename _MappedContainer::value_type>
class _Flat_map_base {
private:
    using _Sorted_t = conditional_t<_IsMulti, sorted_equivalent_t, sorted_unique_t>;

public:
    using key_type               = _Key;
    using mapped_type            = _Mapped;
    using value_type             = pair<key_type, mapped_type>;
    using key_compare            = _Compare;
    using reference              = pair<const key_type&, mapped_type&>;
    using const_reference        = pair<const key_type&, const mapped_type&>;
    using size_type              = size_t;
    using difference_type        = ptrdiff_t;
    using key_container_type     = _KeyContainer;
    using mapped_container_type  = _MappedContainer;
    using iterator               = _Pairing_iterator_provider<typename key_container_type::const_iterator,
        typename mapped_container_type::iterator, typename mapped_container_type::const_iterator>::_Iterator;
    using const_iterator         = _Pairing_iterator_provider<typename key_container_type::const_iterator,
        typename mapped_container_type::const_iterator, typename mapped_container_type::const_iterator>::_Iterator;
    using reverse_iterator       = _STD reverse_iterator<iterator>;
    using const_reverse_iterator = _STD reverse_iterator<const_iterator>;

    _STL_INTERNAL_STATIC_ASSERT(random_access_iterator<iterator>);
    _STL_INTERNAL_STATIC_ASSERT(convertible_to<iterator, const_iterator>);

    using value_compare = _Flat_map_value_compare_provider<key_type, mapped_type, key_compare>::value_compare;
    using containers    = _Flat_map_container_provider<key_container_type, mapped_container_type>::containers;

public:
    // [flat.map.cons] Constructors
    explicit _Flat_map_base(const key_compare& _Comp) : _Key_compare(_Comp), _Data() {}
    _Flat_map_base() : _Flat_map_base(key_compare()) {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    explicit _Flat_map_base(const _Allocator& _Alloc) : _Flat_map_base(key_compare(), _Alloc) {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    explicit _Flat_map_base(const key_compare& _Comp, const _Allocator& _Alloc)
        : _Key_compare(_Comp), _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc),
                                   .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc)} {}

    _Flat_map_base(
        key_container_type _Key_cont, mapped_container_type _Mapped_cont, const key_compare& _Comp = key_compare())
        : _Flat_map_base(_Sorted_t(), _Key_cont, _Mapped_cont, _Comp) {
        _Sort();
        if constexpr (!_IsMulti) {
            _Dedup();
        }
    }

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(
        const key_container_type& _Key_cont, const mapped_container_type& _Mapped_cont, const _Allocator& _Alloc)
        : _Flat_map_base(_Sorted_t(), _Key_cont, _Mapped_cont, _Alloc) {
        _Sort();
        if constexpr (!_IsMulti) {
            _Dedup();
        }
    }

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(const key_container_type& _Key_cont, const mapped_container_type& _Mapped_cont,
        const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Sorted_t(), _Key_cont, _Mapped_cont, _Comp, _Alloc) {
        _Sort();
        if constexpr (!_IsMulti) {
            _Dedup();
        }
    }

    _Flat_map_base(_Sorted_t, key_container_type _Key_cont, mapped_container_type _Mapped_cont,
        const key_compare& _Comp = key_compare())
        : _Key_compare(_Comp), _Data{.keys = _STD move(_Key_cont), .values = _STD move(_Mapped_cont)} {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_Sorted_t, const key_container_type& _Key_cont, const mapped_container_type& _Mapped_cont,
        const _Allocator& _Alloc)
        : _Key_compare(key_compare()),
          _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc, _Key_cont),
              .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc, _Mapped_cont)} {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_Sorted_t, const key_container_type& _Key_cont, const mapped_container_type& _Mapped_cont,
        const key_compare& _Comp, const _Allocator& _Alloc)
        : _Key_compare(_Comp),
          _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc, _Key_cont),
              .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc, _Mapped_cont)} {}

    template <class _InputIterator>
        requires _Is_iterator_v<_InputIterator>
    _Flat_map_base(_InputIterator _First, _InputIterator _Last, const key_compare& _Comp = key_compare())
        : _Flat_map_base(_Comp) {
        insert(_First, _Last);
    }

    template <class _InputIterator, _Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
        requires _Is_iterator_v<_InputIterator>
    _Flat_map_base(_InputIterator _First, _InputIterator _Last, const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Comp, _Alloc) {
        insert(_First, _Last);
    }

    template <_Container_compatible_range<value_type> _Rng>
    _Flat_map_base(from_range_t _From_range, _Rng&& _Range)
        : _Flat_map_base(_From_range, _STD forward<_Rng>(_Range), key_compare()) {}

    template <_Container_compatible_range<value_type> _Rng,
        _Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(from_range_t _From_range, _Rng&& _Range, const _Allocator& _Alloc)
        : _Flat_map_base(_From_range, _STD forward<_Rng>(_Range), key_compare(), _Alloc) {}

    template <_Container_compatible_range<value_type> _Rng>
    _Flat_map_base(from_range_t, _Rng&& _Range, const key_compare& _Comp) : _Flat_map_base(_Comp) {
        insert_range(_STD forward<_Rng>(_Range));
    }

    template <_Container_compatible_range<value_type> _Rng,
        _Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(from_range_t, _Rng&& _Range, const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Comp, _Alloc) {
        insert_range(_STD forward<_Rng>(_Range));
    }

    template <class _InputIterator>
        requires _Is_iterator_v<_InputIterator>
    _Flat_map_base(
        _Sorted_t _Tag, _InputIterator _First, _InputIterator _Last, const key_compare& _Comp = key_compare())
        : _Flat_map_base(_Comp) {
        insert(_Tag, _First, _Last);
    }

    template <class _InputIterator, _Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
        requires _Is_iterator_v<_InputIterator>
    _Flat_map_base(
        _Sorted_t _Tag, _InputIterator _First, _InputIterator _Last, const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Comp, _Alloc) {
        insert(_Tag, _First, _Last);
    }

    template <class _InputIterator, _Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
        requires _Is_iterator_v<_InputIterator>
    _Flat_map_base(_Sorted_t _Tag, _InputIterator _First, _InputIterator _Last, const _Allocator& _Alloc)
        : _Flat_map_base(_Tag, _First, _Last, key_compare(), _Alloc) {}

    _Flat_map_base(initializer_list<value_type> _Ilist, const key_compare& _Comp = key_compare())
        : _Flat_map_base(_Ilist.begin(), _Ilist.end(), _Comp) {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(initializer_list<value_type> _Ilist, const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Ilist.begin(), _Ilist.end(), _Comp, _Alloc) {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(initializer_list<value_type> _Ilist, const _Allocator& _Alloc)
        : _Flat_map_base(_Ilist, key_compare(), _Alloc) {}

    _Flat_map_base(_Sorted_t _Tag, initializer_list<value_type> _Ilist, const key_compare& _Comp = key_compare())
        : _Flat_map_base(_Tag, _Ilist.begin(), _Ilist.end(), _Comp) {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(
        _Sorted_t _Tag, initializer_list<value_type> _Ilist, const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Tag, _Ilist.begin(), _Ilist.end(), _Comp, _Alloc) {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_Sorted_t _Tag, initializer_list<value_type> _Ilist, const _Allocator& _Alloc)
        : _Flat_map_base(_Tag, _Ilist, key_compare(), _Alloc) {}

    // Copy constructors
    _Flat_map_base(const _Derived& _Other) : _Key_compare(_Other._Key_compare), _Data(_Other._Data) {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(const _Derived& _Other, const _Allocator& _Alloc)
        : _Key_compare(_Other._Key_compare),
          _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc, _Other._Data.keys),
              .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc, _Other._Data.values)} {}

    // Move constructors
    _Flat_map_base(_Derived&& _Other) noexcept(is_nothrow_move_constructible_v<key_compare>
                                               && is_nothrow_move_constructible_v<key_container_type>
                                               && is_nothrow_move_constructible_v<mapped_container_type>)
        : _Key_compare(move(_Other._Key_compare)), _Data(move(_Other).extract()) {}

    template <_Valid_allocator_for_flat_map<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_Derived&& _Other, const _Allocator& _Alloc) noexcept(
        is_nothrow_move_constructible_v<key_compare> && is_nothrow_move_constructible_v<key_container_type>
        && is_nothrow_move_constructible_v<mapped_container_type>)
        : _Key_compare(move(_Other._Key_compare)),
          _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc, move(_Other._Data.keys)),
              .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc, move(_Other._Data.values))} {}

    _Derived& operator=(initializer_list<value_type> _Ilist) {
        clear();
        insert(_Ilist.begin(), _Ilist.end());
        return static_cast<_Derived&>(*this); // Use "deducing this" when it is supported
    }

    // [container.reqmts] iterators
    _NODISCARD iterator begin() noexcept {
        return iterator{_Data.keys.cbegin(), _Data.values.begin()};
    }

    _NODISCARD const_iterator begin() const noexcept {
        return const_iterator{_Data.keys.cbegin(), _Data.values.begin()};
    }

    _NODISCARD iterator end() noexcept {
        return iterator{_Data.keys.cend(), _Data.values.end()};
    }

    _NODISCARD const_iterator end() const noexcept {
        return const_iterator{_Data.keys.cend(), _Data.values.end()};
    }

    _NODISCARD reverse_iterator rbegin() noexcept {
        return _STD make_reverse_iterator(end());
    }

    _NODISCARD const_reverse_iterator rbegin() const noexcept {
        return _STD make_reverse_iterator(end());
    }

    _NODISCARD reverse_iterator rend() noexcept {
        return _STD make_reverse_iterator(begin());
    }

    _NODISCARD const_reverse_iterator rend() const noexcept {
        return _STD make_reverse_iterator(begin());
    }

    _NODISCARD const_iterator cbegin() const noexcept {
        return const_iterator{_Data.keys.cbegin(), _Data.values.cbegin()};
    }

    _NODISCARD const_iterator cend() const noexcept {
        return const_iterator{_Data.keys.cend(), _Data.values.cend()};
    }

    _NODISCARD const_reverse_iterator crbegin() const noexcept {
        return _STD make_reverse_iterator(cend());
    }

    _NODISCARD const_reverse_iterator crend() const noexcept {
        return _STD make_reverse_iterator(cbegin());
    }

    void swap(_Derived& _Other) noexcept {
        _RANGES swap(_Key_compare, _Other._Key_compare);
        _RANGES swap(_Data.keys, _Other._Data.keys);
        _RANGES swap(_Data.values, _Other._Data.values);
    }

    // [container.reqmts] clear
    void clear() noexcept {
        _Data.keys.clear();
        _Data.values.clear();
    }

    // [flat.map.capacity] Capacity
    _NODISCARD_EMPTY_MEMBER bool empty() const noexcept {
        return _Data.keys.empty();
    }

    _NODISCARD size_type size() const noexcept {
        return _Data.keys.size();
    }

    _NODISCARD size_type max_size() const noexcept {
        return _STD min(_Data.keys.max_size(), _Data.values.max_size());
    }

    template <class... _ArgTypes>
    iterator emplace_hint(const_iterator _Position, _ArgTypes&&... _Args)
        requires is_constructible_v<value_type, _ArgTypes...>
    {
        value_type _Val(_STD forward<_ArgTypes>(_Args)...);
        return _Emplace_hint<false>(_Position, _STD move(_Val.first), _STD move(_Val.second));
    }

    iterator insert(const_iterator _Position, const value_type& _Pair_val) {
        return emplace_hint(_Position, _Pair_val);
    }

    iterator insert(const_iterator _Position, value_type&& _Pair_val) {
        return emplace_hint(_Position, _STD move(_Pair_val));
    }

    template <class _PairValTy>
    iterator insert(const_iterator _Position, _PairValTy&& _Pair_val)
        requires is_constructible_v<value_type, _PairValTy>
    {
        return emplace_hint(_Position, _STD forward<_PairValTy>(_Pair_val));
    }

    template <class _InputIterator>
        requires _Is_iterator_v<_InputIterator>
    void insert(_InputIterator _First, _InputIterator _Last) {
        _Insert_range<true, !_IsMulti>(_First, _Last);
    }

    template <class _InputIterator>
        requires _Is_iterator_v<_InputIterator>
    void insert(_Sorted_t, _InputIterator _First, _InputIterator _Last) {
        _Insert_range<false, !_IsMulti>(_First, _Last);
    }

    template <_Container_compatible_range<value_type> _Rng>
    void insert_range(_Rng&& _Range) {
        insert(_RANGES begin(_Range), _RANGES end(_Range));
    }

    void insert(initializer_list<value_type> _Ilist) {
        insert(_Ilist.begin(), _Ilist.end());
    }

    void insert(_Sorted_t _Tag, initializer_list<value_type> _Ilist) {
        insert(_Tag, _Ilist.begin(), _Ilist.end());
    }

    iterator erase(iterator _Position) {
        return erase(static_cast<const_iterator>(_Position));
    }

    iterator erase(const_iterator _Position) {
        _Clear_flat_map_scope_guard _Guard{this};
        auto _Key_it      = _Data.keys.erase(_Position._Key_it);
        auto _Val_it      = _Data.values.erase(_Position._Mapped_it);
        _Guard._Clearable = nullptr;
        return iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    iterator erase(const_iterator _First, const_iterator _Last) {
        _Clear_flat_map_scope_guard _Guard{this};
        auto _Key_it      = _Data.keys.erase(_First._Key_it, _Last._Key_it);
        auto _Val_it      = _Data.values.erase(_First._Mapped_it, _Last._Mapped_it);
        _Guard._Clearable = nullptr;
        return iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    size_type erase(const key_type& _Key_val) {
        return _Erase_key(_Key_val);
    }

    template <class _OtherKey>
        requires _Is_transparent_v<key_compare>
              && (!is_convertible_v<_OtherKey, iterator>) && (!is_convertible_v<_OtherKey, const_iterator>)
    size_type erase(_OtherKey&& _Key_val) {
        return _Erase_key(_STD forward<_OtherKey>(_Key_val));
    }

    containers extract() && {
        _Clear_flat_map_scope_guard _Guard{this};
        return _STD move(_Data);
    }

    void replace(key_container_type&& _Key_cont, mapped_container_type&& _Mapped_cont) {
        _Clear_flat_map_scope_guard _Guard{this};
        _Data.keys        = _STD move(_Key_cont);
        _Data.values      = _STD move(_Mapped_cont);
        _Guard._Clearable = nullptr;
    }

    // observers
    key_compare key_comp() const {
        return _Key_compare;
    }

    value_compare value_comp() const {
        return value_compare(_Key_compare);
    }

    const key_container_type& keys() const noexcept {
        return _Data.keys;
    }

    const mapped_container_type& values() const noexcept {
        return _Data.values;
    }

    // map operations
    iterator find(const key_type& _Key_val) {
        return _Find(_Key_val);
    }

    template <class _OtherKey>
    iterator find(const _OtherKey& _Key_val)
        requires _Is_transparent_v<key_compare>
    {
        return _Find(_Key_val);
    }

    const_iterator find(const key_type& _Key_val) const {
        return _Find(_Key_val);
    }

    template <class _OtherKey>
    const_iterator find(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _Find(_Key_val);
    }

    size_type count(const key_type& _Key_val) const {
        return _Count(_Key_val);
    }

    template <class _OtherKey>
    size_type count(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _Count(_Key_val);
    }

    bool contains(const key_type& _Key_val) const {
        return _Contains(_Key_val);
    }

    template <class _OtherKey>
    bool contains(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _Contains(_Key_val);
    }

    iterator lower_bound(const key_type& _Key_val) {
        return _Lower_bound(_Key_val);
    }

    template <class _OtherKey>
    iterator lower_bound(const _OtherKey& _Key_val)
        requires _Is_transparent_v<key_compare>
    {
        return _Lower_bound(_Key_val);
    }

    const_iterator lower_bound(const key_type& _Key_val) const {
        return _Lower_bound(_Key_val);
    }

    template <class _OtherKey>
    const_iterator lower_bound(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _Lower_bound(_Key_val);
    }

    iterator upper_bound(const key_type& _Key_val) {
        return _Upper_bound(_Key_val);
    }

    template <class _OtherKey>
    iterator upper_bound(const _OtherKey& _Key_val)
        requires _Is_transparent_v<key_compare>
    {
        return _Upper_bound(_Key_val);
    }

    const_iterator upper_bound(const key_type& _Key_val) const {
        return _Upper_bound(_Key_val);
    }

    template <class _OtherKey>
    const_iterator upper_bound(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _Upper_bound(_Key_val);
    }

    pair<iterator, iterator> equal_range(const key_type& _Key_val) {
        return _Equal_range(_Key_val);
    }

    template <class _OtherKey>
    pair<iterator, iterator> equal_range(const _OtherKey& _Key_val)
        requires _Is_transparent_v<key_compare>
    {
        return _Equal_range(_Key_val);
    }

    pair<const_iterator, const_iterator> equal_range(const key_type& _Key_val) const {
        return _Equal_range(_Key_val);
    }

    template <class _OtherKey>
    pair<const_iterator, const_iterator> equal_range(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _Equal_range(_Key_val);
    }

    friend bool operator==(const _Derived& _Left, const _Derived& _Right) {
        return _RANGES equal(_Left._Data.keys, _Right._Data.keys)
            && _RANGES equal(_Left._Data.values, _Right._Data.values);
    }

    friend auto operator<=>(const _Derived& _Left, const _Derived& _Right) {
        return _STD lexicographical_compare_three_way(
            _Left.cbegin(), _Left.cend(), _Right.cbegin(), _Right.cend(), _Synth_three_way{});
    }

    friend void swap(_Derived& _Left, _Derived& _Right) noexcept {
        _Left.swap(_Right);
    }


protected:
    key_compare _Key_compare;
    containers _Data;

    template <class _Predicate>
    size_type _Erase_if(_Predicate _Pred) {
        _Clear_flat_map_scope_guard<_Flat_map_base> _Guard{this};

        auto _View           = _View_to_mutate();
        auto _Mut_first      = _View.begin();
        auto _Mut_last       = _View.end();
        const auto _Old_size = size();

        _STD _Seek_wrapped(_Mut_first, _RANGES remove_if(_View, _Pred).begin());

        erase(const_iterator{_Mut_first._Key_it, _Mut_first._Mapped_it},
            const_iterator{_Mut_last._Key_it, _Mut_last._Mapped_it});

        _Guard._Clearable = nullptr;
        return _Old_size - size();
    }

private:
    template <class _KeyTy1, class _KeyTy2>
        requires (same_as<remove_cvref_t<_KeyTy1 &&>, key_type> && same_as<remove_cvref_t<_KeyTy2 &&>, key_type>)
              || (constructible_from<key_type, _KeyTy1 &&> && constructible_from<key_type, _KeyTy2 &&>
                  && _Is_transparent_v<key_compare>)
    bool _Key_equal(_KeyTy1&& _Left, _KeyTy2&& _Right) const {
        return !_Key_compare(_STD forward<_KeyTy1>(_Left), _STD forward<_KeyTy2>(_Right))
            && !_Key_compare(_STD forward<_KeyTy2>(_Right), _STD forward<_KeyTy1>(_Left));
    }

    auto _View_to_mutate() {
        using _Mutating_iterator = _Pairing_iterator_provider<typename key_container_type::iterator,
            typename mapped_container_type::iterator, typename mapped_container_type::iterator>::_Iterator;
        return _RANGES subrange<_Mutating_iterator>{_Mutating_iterator{_Data.keys.begin(), _Data.values.begin()},
            _Mutating_iterator{_Data.keys.end(), _Data.values.end()}};
    }

    void _Sort() {
        _Clear_flat_map_scope_guard _Guard{this};
        _RANGES sort(_View_to_mutate(), value_compare(_Key_compare));
        _Guard._Clearable = nullptr;
    }

    void _Dedup() {
        _Clear_flat_map_scope_guard _Guard{this};
        auto _Sorted_view     = _View_to_mutate();
        auto _Subrange        = _RANGES unique(_Sorted_view, [this](const_reference _Left, const_reference _Right) {
            return this->_Key_equal(_Left.first, _Right.first);
        });
        auto _Remaining_count = _STD distance(_Sorted_view.begin(), _Subrange.begin());
        _Data.keys.erase(_Data.keys.begin() + _Remaining_count, _Data.keys.end());
        _Data.values.erase(_Data.values.begin() + _Remaining_count, _Data.values.end());
        _Guard._Clearable = nullptr;
    }

    void _Insert_exact(const_iterator _Position, key_type&& _Key_val, mapped_type&& _Mapped_val) {
        _Clear_flat_map_scope_guard _Guard{this};
        _Data.keys.insert(_Position._Key_it, _STD move(_Key_val));
        _Data.values.insert(_Position._Mapped_it, _STD move(_Mapped_val));
        _Guard._Clearable = nullptr;
    }

    template <bool _OverwriteIfExists, class _OtherKey, class... _MappedArgTypes>
    iterator _Emplace_hint(const_iterator _Position, _OtherKey&& _Key_val, _MappedArgTypes&&... _Args)
        requires is_constructible_v<mapped_type, _MappedArgTypes...>
              && (same_as<remove_cvref_t<_OtherKey &&>, key_type>
                  || (constructible_from<key_type, _OtherKey &&> && _Is_transparent_v<key_compare>) )
    {
        static_assert(!(_IsMulti && _OverwriteIfExists),
            "Overwriting is not supported when the container allows multiple copies of a key.");
        const const_iterator _Begin = cbegin();
        const const_iterator _End   = cend();

        bool _Insert_before_position        = false;
        bool _Insert_after_position_minus_1 = false;
        if constexpr (_IsMulti) {
            _Insert_before_position        = (_Position == _End) || !_Key_compare(*(_Position._Key_it), _Key_val);
            _Insert_after_position_minus_1 = (_Position == _Begin) || !_Key_compare(_Key_val, *(_Position._Key_it - 1));
        } else {
            _Insert_before_position        = (_Position == _End) || _Key_compare(_Key_val, *(_Position._Key_it));
            _Insert_after_position_minus_1 = (_Position == _Begin) || _Key_compare(*(_Position._Key_it - 1), _Key_val);
        }
        bool _Hint_is_accurate = _Insert_before_position && _Insert_after_position_minus_1;

        if (_Hint_is_accurate) {
            auto _Dist = _STD distance(_Begin._Key_it, _Position._Key_it);
            _Insert_exact(_Position, key_type{_STD forward<_OtherKey>(_Key_val)},
                mapped_type{_STD forward<_MappedArgTypes>(_Args)...});
            return begin() + _Dist;
        } else {
            if constexpr (_OverwriteIfExists) {
                if (_Key_equal(_Key_val, *(_Position._Key_it))) {
                    auto _Dist        = _STD distance(_Begin._Key_it, _Position._Key_it);
                    auto _It          = begin() + _Dist;
                    *(_It._Mapped_it) = mapped_type{_STD forward<_MappedArgTypes>(_Args)...};
                    return _It;
                }
            }

            _Position = lower_bound(_Key_val);
            if (_OverwriteIfExists && _Position != _End && _Key_equal(_Key_val, *(_Position._Key_it))) {
                auto _Dist        = _STD distance(_Begin._Key_it, _Position._Key_it);
                auto _It          = begin() + _Dist;
                *(_It._Mapped_it) = mapped_type{_STD forward<_MappedArgTypes>(_Args)...};
                return _It;
            } else {
                auto _Dist = _STD distance(_Begin._Key_it, _Position._Key_it);
                _Insert_exact(_Position, key_type{_STD forward<_OtherKey>(_Key_val)},
                    mapped_type{_STD forward<_MappedArgTypes>(_Args)...});
                return begin() + _Dist;
            }
        }
    }

    template <bool _NeedSorting, bool _NeedDeduping, class _InputIterator>
        requires _Is_iterator_v<_InputIterator>
    void _Insert_range(_InputIterator _First, _InputIterator _Last) {
        _Clear_flat_map_scope_guard _Guard{this};

        // Insert the new elements at the end
        size_type _OldSize = size();
        size_type _NewSize = _STD distance(_First, _Last);

        _Data.keys.reserve(_Data.keys.size() + _NewSize);
        _Data.values.reserve(_Data.values.size() + _NewSize);

        for (; _First != _Last; ++_First) {
            _Data.keys.emplace_back(_STD move(_First->first));
            _Data.values.emplace_back(_STD move(_First->second));
        }

        // Sort the newly inserted elements
        auto _Sorted_view = _View_to_mutate();
        if constexpr (_NeedSorting) {
            auto _Sorted_new_elements = _Sorted_view;
            _Sorted_new_elements.advance(_OldSize);
            _RANGES sort(_Sorted_new_elements, value_compare(_Key_compare));
        }

        // Merge the newly inserted elements with the existing elements
        _RANGES inplace_merge(_Sorted_view, _Sorted_view.begin() + _OldSize, value_compare(_Key_compare));

        if constexpr (_NeedDeduping) {
            _Dedup();
        }

        _Guard._Clearable = nullptr;
    }

    template <class _KeyTy>
    size_type _Erase_key(_KeyTy&& _Key_val) {
        const_iterator _Pos_begin = lower_bound(_STD forward<_KeyTy>(_Key_val));
        const_iterator _Pos_end   = upper_bound(_STD forward<_KeyTy>(_Key_val));
        size_type _Count          = _Pos_end - _Pos_begin;
        erase(_Pos_begin, _Pos_end);
        return _Count;
    }

    template <class _KeyTy>
    iterator _Find(const _KeyTy& _Key_val)
        requires same_as<_KeyTy, key_type> || _Is_transparent_v<key_compare>
    {
        iterator _Position = lower_bound(_Key_val);
        if (_Position != end() && _Key_equal(_Position->first, _Key_val)) {
            return _Position;
        } else {
            return end();
        }
    }

    template <class _KeyTy>
    const_iterator _Find(const _KeyTy& _Key_val) const
        requires same_as<_KeyTy, key_type> || _Is_transparent_v<key_compare>
    {
        const_iterator _Position = lower_bound(_Key_val);
        if (_Position != cend() && _Key_equal(_Position->first, _Key_val)) {
            return _Position;
        } else {
            return cend();
        }
    }

    template <class _KeyTy>
    size_type _Count(const _KeyTy& _Key_val) const
        requires same_as<_KeyTy, key_type> || _Is_transparent_v<key_compare>
    {
        return upper_bound(_Key_val) - lower_bound(_Key_val);
    }

    template <class _KeyTy>
    bool _Contains(const _KeyTy& _Key_val) const
        requires same_as<_KeyTy, key_type> || _Is_transparent_v<key_compare>
    {
        return find(_Key_val) != cend();
    }

    template <class _KeyTy>
    iterator _Lower_bound(const _KeyTy& _Key_val)
        requires same_as<_KeyTy, key_type> || _Is_transparent_v<key_compare>
    {
        auto _Key_it = _STD lower_bound(_Data.keys.cbegin(), _Data.keys.cend(), _Key_val, _Key_compare);
        auto _Dist   = _STD distance(_Data.keys.cbegin(), _Key_it);
        auto _Val_it = _Data.values.begin() + _Dist;
        return iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    template <class _KeyTy>
    const_iterator _Lower_bound(const _KeyTy& _Key_val) const
        requires same_as<_KeyTy, key_type> || _Is_transparent_v<key_compare>
    {
        auto _Key_it = _STD lower_bound(_Data.keys.cbegin(), _Data.keys.cend(), _Key_val, _Key_compare);
        auto _Dist   = _STD distance(_Data.keys.cbegin(), _Key_it);
        auto _Val_it = _Data.values.cbegin() + _Dist;
        return const_iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    template <class _KeyTy>
    iterator _Upper_bound(const _KeyTy& _Key_val)
        requires same_as<_KeyTy, key_type> || _Is_transparent_v<key_compare>
    {
        auto _Key_it = _STD upper_bound(_Data.keys.cbegin(), _Data.keys.cend(), _Key_val, _Key_compare);
        auto _Dist   = _STD distance(_Data.keys.cbegin(), _Key_it);
        auto _Val_it = _Data.values.begin() + _Dist;
        return iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    template <class _KeyTy>
    const_iterator _Upper_bound(const _KeyTy& _Key_val) const
        requires same_as<_KeyTy, key_type> || _Is_transparent_v<key_compare>
    {
        auto _Key_it = _STD upper_bound(_Data.keys.cbegin(), _Data.keys.cend(), _Key_val, _Key_compare);
        auto _Dist   = _STD distance(_Data.keys.cbegin(), _Key_it);
        auto _Val_it = _Data.values.cbegin() + _Dist;
        return const_iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    template <class _KeyTy>
    pair<iterator, iterator> _Equal_range(const _KeyTy& _Key_val)
        requires same_as<_KeyTy, key_type> || _Is_transparent_v<key_compare>
    {
        return {lower_bound(_Key_val), upper_bound(_Key_val)};
    }

    template <class _KeyTy>
    pair<const_iterator, const_iterator> _Equal_range(const _KeyTy& _Key_val) const
        requires same_as<_KeyTy, key_type> || _Is_transparent_v<key_compare>
    {
        return {lower_bound(_Key_val), upper_bound(_Key_val)};
    }
};

template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer>
class flat_map : public _Flat_map_base<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer, false,
                     flat_map<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>> {
private:
    using _MyBase = _Flat_map_base<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer, false,
        flat_map<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>>;

    using _MyBase::_Data;
    using _MyBase::_Key_compare;

public:
    using typename _MyBase::const_iterator;
    using typename _MyBase::iterator;
    using typename _MyBase::key_compare;
    using typename _MyBase::key_type;
    using typename _MyBase::mapped_type;
    using typename _MyBase::value_type;

    using _MyBase::_MyBase;
    using _MyBase::operator=;

    // [flat.map.access] Access
    _NODISCARD mapped_type& operator[](const key_type& _Key_val) {
        return this->try_emplace(_Key_val).first->second;
    }
    _NODISCARD mapped_type& operator[](key_type&& _Key_val) {
        return this->try_emplace(_STD move(_Key_val)).first->second;
    }

    template <class _OtherKey>
    _NODISCARD mapped_type& operator[](_OtherKey&& _Key_val)
        requires _Is_transparent_v<key_compare>
    {
        return this->try_emplace(_STD forward<_OtherKey>(_Key_val)).first->second;
    }

    _NODISCARD mapped_type& at(const key_type& _Key_val) {
        return _At(_Key_val);
    }

    _NODISCARD const mapped_type& at(const key_type& _Key_val) const {
        return _At(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD mapped_type& at(const _OtherKey& _Key_val)
        requires _Is_transparent_v<key_compare>
    {
        return _At(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD const mapped_type& at(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _At(_Key_val);
    }

    // [flat.map.modifiers] Modifiers
    template <class... _ArgTypes>
    pair<iterator, bool> emplace(_ArgTypes&&... _Args)
        requires is_constructible_v<value_type, _ArgTypes...>
    {
        value_type _Val(_STD forward<_ArgTypes>(_Args)...);
        return try_emplace(_STD move(_Val.first), _STD move(_Val.second));
    }

    pair<iterator, bool> insert(const value_type& _Pair_val) {
        return try_emplace(_Pair_val.first, _Pair_val.second);
    }

    pair<iterator, bool> insert(value_type&& _Pair_val) {
        return try_emplace(_STD move(_Pair_val.first), _STD move(_Pair_val.second));
    }

    template <class _PairValTy>
    pair<iterator, bool> insert(_PairValTy&& _Pair_val)
        requires is_constructible_v<value_type, _PairValTy>
    {
        return emplace(_STD forward<_PairValTy>(_Pair_val));
    }

    template <class... _MappedArgTypes>
        requires is_constructible_v<mapped_type, _MappedArgTypes&&...>
    pair<iterator, bool> try_emplace(const key_type& _Key_val, _MappedArgTypes&&... _Mapped_args) {
        return _Try_emplace(_Key_val, _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class... _MappedArgTypes>
        requires is_constructible_v<mapped_type, _MappedArgTypes&&...>
    pair<iterator, bool> try_emplace(key_type&& _Key_val, _MappedArgTypes&&... _Mapped_args) {
        return _Try_emplace(_STD move(_Key_val), _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class _OtherKey, class... _MappedArgTypes>
        requires _Is_transparent_v<key_compare> && is_constructible_v<key_type, _OtherKey>
              && is_constructible_v<mapped_type, _MappedArgTypes&&...>
              && (!is_convertible_v<_OtherKey, const_iterator>) && (!is_convertible_v<_OtherKey, iterator>)
    pair<iterator, bool> try_emplace(_OtherKey&& _Key_val, _MappedArgTypes&&... _Mapped_args) {
        return _Try_emplace(_STD forward<_OtherKey>(_Key_val), _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class... _MappedArgTypes>
    iterator try_emplace(const_iterator _Position, const key_type&& _Key_val, _MappedArgTypes&&... _Mapped_args)
        requires is_constructible_v<mapped_type, _MappedArgTypes&&...>
    {
        return this->_Emplace_hint<false>(_Position, _Key_val, _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class... _MappedArgTypes>
    iterator try_emplace(const_iterator _Position, key_type&& _Key_val, _MappedArgTypes&&... _Mapped_args)
        requires is_constructible_v<mapped_type, _MappedArgTypes&&...>
    {
        return this->_Emplace_hint<false>(
            _Position, _STD move(_Key_val), _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class _OtherKey, class... _MappedArgTypes>
    iterator try_emplace(const_iterator _Position, _OtherKey&& _Key_val, _MappedArgTypes&&... _Mapped_args)
        requires _Is_transparent_v<key_compare> && is_constructible_v<key_type, _OtherKey>
              && is_constructible_v<mapped_type, _MappedArgTypes&&...>
    {
        return this->_Emplace_hint<false>(
            _Position, _STD forward<_OtherKey>(_Key_val), _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class _MappedTy>
    pair<iterator, bool> insert_or_assign(const key_type& _Key_val, _MappedTy&& _Mapped_val)
        requires is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return _Insert_or_assign(_Key_val, _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _MappedTy>
    pair<iterator, bool> insert_or_assign(key_type&& _Key_val, _MappedTy&& _Mapped_val)
        requires is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return _Insert_or_assign(_STD move(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _OtherKey, class _MappedTy>
    pair<iterator, bool> insert_or_assign(_OtherKey&& _Key_val, _MappedTy&& _Mapped_val)
        requires _Is_transparent_v<key_compare> && is_constructible_v<key_type, _OtherKey>
              && is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return _Insert_or_assign(_STD forward<_OtherKey>(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _MappedTy>
    iterator insert_or_assign(const_iterator _Position, const key_type& _Key_val, _MappedTy&& _Mapped_val)
        requires is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return this->_Emplace_hint<true>(_Position, _Key_val, _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _MappedTy>
    iterator insert_or_assign(const_iterator _Position, key_type&& _Key_val, _MappedTy&& _Mapped_val)
        requires is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return this->_Emplace_hint<true>(_Position, _STD move(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _OtherKey, class _MappedTy>
    iterator insert_or_assign(const_iterator _Position, _OtherKey&& _Key_val, _MappedTy&& _Mapped_val)
        requires _Is_transparent_v<key_compare> && is_constructible_v<key_type, _OtherKey>
              && is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return this->_Emplace_hint<true>(
            _Position, _STD forward<_OtherKey>(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
    }

private:
    using _MyBase::_Erase_if;

    template <class _KTy, class _MTy, class _Comp, class _KeyCont, class _MappedCont, class _Pred>
    friend typename flat_map<_KTy, _MTy, _Comp, _KeyCont, _MappedCont>::size_type erase_if(
        flat_map<_KTy, _MTy, _Comp, _KeyCont, _MappedCont>&, _Pred);

    template <class _KeyTy>
    _NODISCARD mapped_type& _At(const _KeyTy& _Key_val)
        requires same_as<_KeyTy, key_type> || _Is_transparent_v<key_compare>
    {
        const auto _Position = this->find(_Key_val);
        if (_Position == this->end()) {
            _Xout_of_range("std::flat_map::at: the specified key does not exist.");
        } else {
            return _Position->second;
        }
    }

    template <class _KeyTy>
    _NODISCARD const mapped_type& _At(const _KeyTy& _Key_val) const
        requires same_as<_KeyTy, key_type> || _Is_transparent_v<key_compare>
    {
        const auto _Position = this->find(_Key_val);
        if (_Position == this->end()) {
            _Xout_of_range("std::flat_map::at: the specified key does not exist.");
        } else {
            return _Position->second;
        }
    }

    template <class _KeyTy, class... _MappedArgTypes>
    pair<iterator, bool> _Try_emplace(_KeyTy&& _Key_val, _MappedArgTypes&&... _Mapped_args) {
        auto _Key_it = _STD lower_bound(_Data.keys.begin(), _Data.keys.end(), _Key_val, _Key_compare);
        if (_Key_it != _Data.keys.end() && _Key_equal(*_Key_it, _STD forward<_KeyTy>(_Key_val))) {
            // Already exists
            return {this->begin() + _STD distance(_Data.keys.begin(), _Key_it), false};
        } else {
            // Need to insert
            auto _Index = _STD distance(_Data.keys.begin(), _Key_it);
            this->_Insert_exact(this->cbegin() + _Index, key_type{_STD forward<_KeyTy>(_Key_val)},
                mapped_type{_STD forward<_MappedArgTypes>(_Mapped_args)...});
            return {this->begin() + _Index, true};
        }
    }

    template <class _KeyTy, class _MappedTy>
    pair<iterator, bool> _Insert_or_assign(_KeyTy&& _Key_val, _MappedTy&& _Mapped_val) {
        auto _Res = _Try_emplace(_STD forward<_KeyTy>(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
        if (!_Res.second) { // Already exists
            _Res.first->second = _STD forward<_MappedTy>(_Mapped_val);
        }
        return _Res;
    }
};

template <class _KeyContainer, class _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare = less<typename _KeyContainer::value_type>>
flat_map(_KeyContainer, _MappedContainer, _Compare = _Compare()) -> flat_map<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, _Compare, _KeyContainer, _MappedContainer>;

template <class _KeyContainer, class _MappedContainer,
    _Valid_allocator_for_flat_map<_KeyContainer, _MappedContainer> _Allocator>
flat_map(_KeyContainer, _MappedContainer, _Allocator) -> flat_map<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, less<typename _KeyContainer::value_type>, _KeyContainer, _MappedContainer>;

template <class _KeyContainer, class _MappedContainer, _Valid_compare_for_container<_KeyContainer> _Compare,
    _Valid_allocator_for_flat_map<_KeyContainer, _MappedContainer> _Allocator>
flat_map(_KeyContainer, _MappedContainer, _Compare, _Allocator) -> flat_map<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, _Compare, _KeyContainer, _MappedContainer>;

template <class _KeyContainer, class _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare = less<typename _KeyContainer::value_type>>
flat_map(sorted_unique_t, _KeyContainer, _MappedContainer, _Compare = _Compare())
    -> flat_map<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <class _KeyContainer, class _MappedContainer,
    _Valid_allocator_for_flat_map<_KeyContainer, _MappedContainer> _Allocator>
flat_map(sorted_unique_t, _KeyContainer, _MappedContainer, _Allocator) -> flat_map<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, less<typename _KeyContainer::value_type>, _KeyContainer, _MappedContainer>;

template <class _KeyContainer, class _MappedContainer, _Valid_compare_for_container<_KeyContainer> _Compare,
    _Valid_allocator_for_flat_map<_KeyContainer, _MappedContainer> _Allocator>
flat_map(sorted_unique_t, _KeyContainer, _MappedContainer, _Compare, _Allocator)
    -> flat_map<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <class _InputIterator, class _Compare = less<_Guide_key_t<_InputIterator>>>
flat_map(_InputIterator, _InputIterator, _Compare = _Compare())
    -> flat_map<_Guide_key_t<_InputIterator>, _Guide_val_t<_InputIterator>, _Compare>;

template <class _InputIterator, class _Compare = less<_Guide_key_t<_InputIterator>>>
flat_map(sorted_unique_t, _InputIterator, _InputIterator, _Compare = _Compare())
    -> flat_map<_Guide_key_t<_InputIterator>, _Guide_val_t<_InputIterator>, _Compare>;

template <_RANGES input_range _Rng, class _Compare = less<_Range_key_type<_Rng>>, class _Allocator = allocator<byte>>
flat_map(from_range_t, _Rng&&, _Compare = _Compare(), _Allocator = _Allocator())
    -> flat_map<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>, _Compare,
        vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
        vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;

template <_RANGES input_range _Rng, class _Allocator>
flat_map(from_range_t, _Rng&&, _Allocator) -> flat_map<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>,
    less<_Range_key_type<_Rng>>, vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
    vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;

template <class _Key, class _Mapped, class _Compare = less<_Key>>
flat_map(initializer_list<pair<_Key, _Mapped>>, _Compare = _Compare()) -> flat_map<_Key, _Mapped, _Compare>;

template <class _Key, class _Mapped, class _Compare = less<_Key>>
flat_map(sorted_unique_t, initializer_list<pair<_Key, _Mapped>>, _Compare = _Compare())
    -> flat_map<_Key, _Mapped, _Compare>;

// Specialization of uses_allocator
template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer, class _Allocator>
struct uses_allocator<flat_map<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>, _Allocator>
    : bool_constant<uses_allocator_v<_KeyContainer, _Allocator> && uses_allocator_v<_MappedContainer, _Allocator>> {};

_EXPORT_STD template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer,
    class _Predicate>
typename flat_map<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>::size_type erase_if(
    flat_map<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>& _Cont, _Predicate _Pred) {
    return _Cont._Erase_if(_STD _Pass_fn(_Pred));
}

template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer>
class flat_multimap : public _Flat_map_base<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer, true,
                          flat_multimap<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>> {
private:
    using _MyBase = _Flat_map_base<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer, true,
        flat_multimap<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>>;

    using _MyBase::_Data;
    using _MyBase::_Key_compare;

public:
    using typename _MyBase::iterator;
    using typename _MyBase::value_type;

    using _MyBase::_MyBase;
    using _MyBase::operator=;

    // [flat.multimap.modifiers] Modifiers
    template <class... _ArgTypes>
    iterator emplace(_ArgTypes&&... _Args) {
        value_type _Val(_STD forward<_ArgTypes>(_Args)...);
        return _Emplace_key_mapped(_STD move(_Val.first), _STD move(_Val.second));
    }

    iterator insert(const value_type& _Px) {
        return _Emplace_key_mapped(_Px.first, _Px.second);
    }

    iterator insert(value_type&& _Px) {
        return _Emplace_key_mapped(_STD move(_Px.first), _STD move(_Px.second));
    }

    template <class _PairValTy>
    iterator insert(_PairValTy&& _Pair_val)
        requires is_constructible_v<value_type, _PairValTy>
    {
        return emplace(_STD forward<_PairValTy>(_Pair_val));
    }

private:
    using _MyBase::_Erase_if;

    template <class _KTy, class _MTy, class _Comp, class _KeyCont, class _MappedCont, class _Pred>
    friend typename flat_multimap<_KTy, _MTy, _Comp, _KeyCont, _MappedCont>::size_type erase_if(
        flat_multimap<_KTy, _MTy, _Comp, _KeyCont, _MappedCont>&, _Pred);

    template <class _KeyTy, class _MappedTy>
    iterator _Emplace_key_mapped(_KeyTy&& _Key_val, _MappedTy&& _Mapped_val) {
        auto _Key_it = _STD lower_bound(_Data.keys.begin(), _Data.keys.end(), _Key_val, _Key_compare);
        auto _Index  = _STD distance(_Data.keys.begin(), _Key_it);

        this->_Insert_exact(
            this->cbegin() + _Index, _STD forward<_KeyTy>(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
        return this->begin() + _Index;
    }
};

template <class _KeyContainer, class _MappedContainer, class _Compare = less<typename _KeyContainer::value_type>>
flat_multimap(_KeyContainer, _MappedContainer, _Compare = _Compare())
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <class _KeyContainer, class _MappedContainer, class _Allocator>
flat_multimap(_KeyContainer, _MappedContainer, _Allocator) -> flat_multimap<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, less<typename _KeyContainer::value_type>, _KeyContainer, _MappedContainer>;
template <class _KeyContainer, class _MappedContainer, class _Compare, class _Allocator>
flat_multimap(_KeyContainer, _MappedContainer, _Compare, _Allocator)
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <class _KeyContainer, class _MappedContainer, class _Compare = less<typename _KeyContainer::value_type>>
flat_multimap(sorted_equivalent_t, _KeyContainer, _MappedContainer, _Compare = _Compare())
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <class _KeyContainer, class _MappedContainer, class _Allocator>
flat_multimap(sorted_equivalent_t, _KeyContainer, _MappedContainer, _Allocator)
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type,
        less<typename _KeyContainer::value_type>, _KeyContainer, _MappedContainer>;
template <class _KeyContainer, class _MappedContainer, class _Compare, class _Allocator>
flat_multimap(sorted_equivalent_t, _KeyContainer, _MappedContainer, _Compare, _Allocator)
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <class _InputIterator, class _Compare = less<_Guide_key_t<_InputIterator>>>
flat_multimap(_InputIterator, _InputIterator, _Compare = _Compare())
    -> flat_multimap<_Guide_key_t<_InputIterator>, _Guide_val_t<_InputIterator>, _Compare>;

template <class _InputIterator, class _Compare = less<_Guide_key_t<_InputIterator>>>
flat_multimap(sorted_equivalent_t, _InputIterator, _InputIterator, _Compare = _Compare())
    -> flat_multimap<_Guide_key_t<_InputIterator>, _Guide_val_t<_InputIterator>, _Compare>;

template <_RANGES input_range _Rng, class _Compare = less<_Range_key_type<_Rng>>, class _Allocator = allocator<byte>>
flat_multimap(from_range_t, _Rng&&, _Compare = _Compare(), _Allocator = _Allocator())
    -> flat_multimap<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>, _Compare,
        vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
        vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;

template <_RANGES input_range _Rng, class _Allocator>
flat_multimap(from_range_t, _Rng&&, _Allocator) -> flat_multimap<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>,
    less<_Range_key_type<_Rng>>, vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
    vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;

template <class _Key, class _Mapped, class _Compare = less<_Key>>
flat_multimap(initializer_list<pair<_Key, _Mapped>>, _Compare = _Compare()) -> flat_multimap<_Key, _Mapped, _Compare>;

template <class _Key, class _Mapped, class _Compare = less<_Key>>
flat_multimap(sorted_equivalent_t, initializer_list<pair<_Key, _Mapped>>, _Compare = _Compare())
    -> flat_multimap<_Key, _Mapped, _Compare>;

// Specialization of uses_allocator
template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer, class _Allocator>
struct uses_allocator<flat_multimap<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>, _Allocator>
    : bool_constant<uses_allocator_v<_KeyContainer, _Allocator> && uses_allocator_v<_MappedContainer, _Allocator>> {};

_EXPORT_STD template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer,
    class _Predicate>
typename flat_multimap<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>::size_type erase_if(
    flat_multimap<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>& _Cont, _Predicate _Pred) {
    return _Cont._Erase_if(_STD _Pass_fn(_Pred));
}
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // ^^^ supported language mode ^^^
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _FLAT_MAP_
