// flat_map standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _FLAT_MAP_
#define _FLAT_MAP_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR
#if !_HAS_CXX23
_EMIT_STL_WARNING(STL4038, "The contents of <flat_map> are available only with C++23 or later.");
#else // ^^^ !_HAS_CXX23 / _HAS_CXX23 vvv

#include <algorithm>
#include <compare>
#include <concepts>
#include <initializer_list>
#include <type_traits>
#include <utility>
#include <vector>
#include <xmemory>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
template <class _Key, class _Mapped, class _KeyCompare>
struct _Flat_map_value_compare_provider {
    struct value_compare {
    public:
        bool operator()(pair<const _Key&, const _Mapped&> _Left, pair<const _Key&, const _Mapped&> _Right) const {
            return _Key_comparator(_Left.first, _Right.first);
        }

        value_compare(_KeyCompare _Comp) : _Key_comparator(_Comp) {}

    private:
        _KeyCompare _Key_comparator;
    };
};

template <class _KeyContainer, class _MappedContainer>
struct _Flat_map_container_provider {
    struct containers {
        _KeyContainer keys;
        _MappedContainer values;
    };
};

// Implementation

template <bool _IsUnique, class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer>
class _Flat_map_base;

template <class _KeyIter, class _MappedIter, class _MappedConvIter>
struct _Pairing_iterator_provider;

template <class _KeyIter, class _MappedIter, class _MappedConvIter>
concept _Can_unwrap_pairing_iterator =
    !conjunction_v<is_same<_Unwrapped_t<_KeyIter>, _KeyIter>, is_same<_Unwrapped_t<_MappedIter>, _MappedIter>>;

template <class _KeyIter, class _MappedIter, class _MappedConvIter>
using _Unwrapped_pairing_iterator = _Pairing_iterator_provider<_Unwrapped_t<_KeyIter>, _Unwrapped_t<_MappedIter>,
    _Unwrapped_t<_MappedConvIter>>::_Iterator;

template <class _KeyIter, class _MappedIter, class _MappedConvIter>
struct _Pairing_iterator_provider {
    class _Iterator {
    public:
        template <bool _IsUnique, class _Key, class _Mapped, class _Compare, class _KeyContainer,
            class _MappedContainer>
        friend class _Flat_map_base;

        _Iterator() = default;
        _Iterator(_KeyIter _Key_iter, _MappedIter _Mapped_iter)
            noexcept(is_nothrow_move_constructible_v<_KeyIter> && is_nothrow_move_constructible_v<_MappedIter>)
            : _Key_it(_STD move(_Key_iter)), _Mapped_it(_STD move(_Mapped_iter)) {}

        using iterator_category = input_iterator_tag;
        using iterator_concept  = random_access_iterator_tag;
        using difference_type   = ptrdiff_t;
        using value_type        = pair<iter_value_t<_KeyIter>, iter_value_t<_MappedIter>>;
        using reference         = pair<iter_reference_t<_KeyIter>, iter_reference_t<_MappedIter>>;

    private:
        using _Const_iterator = _Pairing_iterator_provider<_KeyIter, _MappedConvIter, _MappedConvIter>::_Iterator;

        class _Arrow_proxy {
        public:
            explicit _Arrow_proxy(const reference& _Rx) noexcept : _Ref{_Rx} {}

            const reference* operator->() const noexcept {
                return _STD addressof(_Ref);
            }

        private:
            reference _Ref;
        };

    public:
        using pointer = _Arrow_proxy;

        reference operator*() const {
            return reference{*_Key_it, *_Mapped_it};
        }

        friend pair<iter_rvalue_reference_t<_KeyIter>, iter_rvalue_reference_t<_MappedIter>> iter_move(
            const _Iterator& _It) {
            return {_RANGES iter_move(_It._Key_it), _RANGES iter_move(_It._Mapped_it)};
        }

        pointer operator->() const {
            return pointer{**this};
        }

        _Iterator& operator++() {
            ++_Key_it;
            ++_Mapped_it;
            return *this;
        }

        _Iterator operator++(int) {
            auto _Old = *this;
            ++*this;
            return _Old;
        }

        bool operator==(const _Iterator& _Right) const {
            return _Key_it == _Right._Key_it;
        }

        auto operator<=>(const _Iterator& _Right) const {
            return _Synth_three_way{}(_Key_it, _Right._Key_it);
        }

        _Iterator& operator--() {
            --_Key_it;
            --_Mapped_it;
            return *this;
        }

        _Iterator operator--(int) {
            auto _Old = *this;
            --*this;
            return _Old;
        }

        _Iterator& operator+=(const difference_type _Off) {
            _Key_it += static_cast<iter_difference_t<_KeyIter>>(_Off);
            _Mapped_it += static_cast<iter_difference_t<_MappedIter>>(_Off);
            return *this;
        }

        _Iterator& operator-=(const difference_type _Off) {
            _Key_it -= static_cast<iter_difference_t<_KeyIter>>(_Off);
            _Mapped_it -= static_cast<iter_difference_t<_MappedIter>>(_Off);
            return *this;
        }

        _Iterator operator+(const difference_type _Off) const {
            auto _Old = *this;
            _Old += _Off;
            return _Old;
        }

        _Iterator operator-(const difference_type _Off) const {
            auto _Old = *this;
            _Old -= _Off;
            return _Old;
        }

        reference operator[](const difference_type _Off) const {
            return *(*this + _Off);
        }

        difference_type operator-(const _Iterator& _Right) const {
            return _Key_it - _Right._Key_it;
        }

        friend _Iterator operator+(const difference_type _Off, const _Iterator& _Right) {
            return _Right + _Off;
        }

        operator _Const_iterator() const
            requires (!is_same_v<_MappedIter, _MappedConvIter>)
        {
            return _Const_iterator{_Key_it, _Mapped_it};
        }

        const _KeyIter& _Key_iterator() const noexcept {
            return _Key_it;
        }

        const _MappedIter& _Mapped_iterator() const noexcept {
            return _Mapped_it;
        }

        using _Prevent_inheriting_unwrap = _Iterator;

        friend void _Verify_range(const _Iterator& _First, const _Iterator& _Last) noexcept {
            if constexpr (_Range_verifiable_v<_KeyIter>) {
                _Verify_range(_First._Key_it, _Last._Key_it); // intentional ADL
            }

            if constexpr (_Range_verifiable_v<_MappedIter>) {
                _Verify_range(_First._Mapped_it, _Last._Mapped_it); // intentional ADL
            }

            _STL_VERIFY(_Last._Key_it - _First._Key_it == _Last._Mapped_it - _First._Mapped_it,
                "iterators from inconsistent ranges");
        }

        void _Verify_offset(const difference_type _Off) const noexcept {
            if constexpr (_Offset_verifiable_v<_KeyIter>) {
                _Key_it._Verify_offset(_Off);
            } else {
                _STL_VERIFY(_Off == 0 || _Key_it != _KeyIter(), "cannot seek value-initialized iterator");
            }

            if constexpr (_Offset_verifiable_v<_MappedIter>) {
                _Mapped_it._Verify_offset(_Off);
            } else {
                _STL_VERIFY(_Off == 0 || _Mapped_it != _MappedIter(), "cannot seek value-initialized iterator");
            }
        }

        _NODISCARD auto _Unwrapped() const
            requires _Can_unwrap_pairing_iterator<_KeyIter, _MappedIter, _MappedConvIter>
        {
            using _Unwrapped_iterator = _Unwrapped_pairing_iterator<_KeyIter, _MappedIter, _MappedConvIter>;
            return _Unwrapped_iterator{_STD _Get_unwrapped(_Key_it), _STD _Get_unwrapped(_Mapped_it)};
        }

        void _Seek_to(const _Unwrapped_pairing_iterator<_KeyIter, _MappedIter, _MappedConvIter>& _Dst)
            requires _Can_unwrap_pairing_iterator<_KeyIter, _MappedIter, _MappedConvIter>
        {
            _STD _Seek_wrapped(_Key_it, _Dst._Key_iterator());
            _STD _Seek_wrapped(_Mapped_it, _Dst._Mapped_iterator());
        }

    private:
        _KeyIter _Key_it;
        _MappedIter _Mapped_it;
    };
};

_EXPORT_STD template <class _Key, class _Mapped, class _Compare = less<_Key>, class _KeyContainer = vector<_Key>,
    class _MappedContainer = vector<_Mapped>>
class flat_map;

_EXPORT_STD template <class _Key, class _Mapped, class _Compare = less<_Key>, class _KeyContainer = vector<_Key>,
    class _MappedContainer = vector<_Mapped>>
class flat_multimap;

template <bool _IsUnique, class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer>
class _Flat_map_base {
private:
    using _Sorted_t = conditional_t<_IsUnique, sorted_unique_t, sorted_equivalent_t>;
    using _Derived  = conditional_t<_IsUnique, flat_map<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>,
         flat_multimap<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>>;

public:
    using key_type              = _Key;
    using mapped_type           = _Mapped;
    using value_type            = pair<key_type, mapped_type>;
    using key_compare           = _Compare;
    using reference             = pair<const key_type&, mapped_type&>;
    using const_reference       = pair<const key_type&, const mapped_type&>;
    using size_type             = size_t;
    using difference_type       = ptrdiff_t;
    using key_container_type    = _KeyContainer;
    using mapped_container_type = _MappedContainer;

    using iterator = _Pairing_iterator_provider<typename key_container_type::const_iterator,
        typename mapped_container_type::iterator, typename mapped_container_type::const_iterator>::_Iterator;

    using const_iterator = _Pairing_iterator_provider<typename key_container_type::const_iterator,
        typename mapped_container_type::const_iterator, typename mapped_container_type::const_iterator>::_Iterator;

    using reverse_iterator       = _STD reverse_iterator<iterator>;
    using const_reverse_iterator = _STD reverse_iterator<const_iterator>;

    static_assert(is_same_v<key_type, typename key_container_type::value_type>,
        "key_type should be the element type of key_container_type");
    static_assert(is_same_v<mapped_type, typename mapped_container_type::value_type>,
        "mapped_type should be the element type of mapped_container_type");
    static_assert(!_Is_vector_bool<key_container_type> && !_Is_vector_bool<mapped_container_type>,
        "vector<bool, A> cannot be adapted because it is not a sequence container.");

    using value_compare = _Flat_map_value_compare_provider<key_type, mapped_type, key_compare>::value_compare;
    using containers    = _Flat_map_container_provider<key_container_type, mapped_container_type>::containers;

public:
    // [flat.map.cons] Constructors
    explicit _Flat_map_base(const key_compare& _Comp) : _Key_compare(_Comp), _Data() {}
    _Flat_map_base() : _Flat_map_base(key_compare()) {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    explicit _Flat_map_base(const _Allocator& _Alloc) : _Flat_map_base(key_compare(), _Alloc) {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(const key_compare& _Comp, const _Allocator& _Alloc)
        : _Key_compare(_Comp), _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc),
                                   .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc)} {}

    _Flat_map_base(
        key_container_type _Key_cont, mapped_container_type _Mapped_cont, const key_compare& _Comp = key_compare())
        : _Key_compare(_Comp), _Data{.keys = _STD move(_Key_cont), .values = _STD move(_Mapped_cont)} {
        _Sort();
        if constexpr (_IsUnique) {
            _Dedup();
        }
    }

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(
        const key_container_type& _Key_cont, const mapped_container_type& _Mapped_cont, const _Allocator& _Alloc)
        : _Flat_map_base(_Sorted_t(), _Key_cont, _Mapped_cont, _Alloc) {
        _Sort();
        if constexpr (_IsUnique) {
            _Dedup();
        }
    }

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(const key_container_type& _Key_cont, const mapped_container_type& _Mapped_cont,
        const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Sorted_t(), _Key_cont, _Mapped_cont, _Comp, _Alloc) {
        _Sort();
        if constexpr (_IsUnique) {
            _Dedup();
        }
    }

    _Flat_map_base(_Sorted_t, key_container_type _Key_cont, mapped_container_type _Mapped_cont,
        const key_compare& _Comp = key_compare())
        : _Key_compare(_Comp), _Data{.keys = _STD move(_Key_cont), .values = _STD move(_Mapped_cont)} {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_Sorted_t, const key_container_type& _Key_cont, const mapped_container_type& _Mapped_cont,
        const _Allocator& _Alloc)
        : _Key_compare(key_compare()),
          _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc, _Key_cont),
              .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc, _Mapped_cont)} {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_Sorted_t, const key_container_type& _Key_cont, const mapped_container_type& _Mapped_cont,
        const key_compare& _Comp, const _Allocator& _Alloc)
        : _Key_compare(_Comp),
          _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc, _Key_cont),
              .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc, _Mapped_cont)} {}

    template <_Iterator_for_container _InputIterator>
    _Flat_map_base(_InputIterator _First, _InputIterator _Last, const key_compare& _Comp = key_compare())
        : _Flat_map_base(_Comp) {
        insert(_First, _Last);
    }

    template <_Iterator_for_container _InputIterator,
        _Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_InputIterator _First, _InputIterator _Last, const _Allocator& _Alloc) : _Flat_map_base(_Alloc) {
        insert(_First, _Last);
    }

    template <_Iterator_for_container _InputIterator,
        _Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_InputIterator _First, _InputIterator _Last, const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Comp, _Alloc) {
        insert(_First, _Last);
    }

    template <_Container_compatible_range<value_type> _Rng>
    _Flat_map_base(from_range_t _From_range, _Rng&& _Range)
        : _Flat_map_base(_From_range, _STD forward<_Rng>(_Range), key_compare()) {}

    template <_Container_compatible_range<value_type> _Rng,
        _Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(from_range_t _From_range, _Rng&& _Range, const _Allocator& _Alloc)
        : _Flat_map_base(_From_range, _STD forward<_Rng>(_Range), key_compare(), _Alloc) {}

    template <_Container_compatible_range<value_type> _Rng>
    _Flat_map_base(from_range_t, _Rng&& _Range, const key_compare& _Comp) : _Flat_map_base(_Comp) {
        insert_range(_STD forward<_Rng>(_Range));
    }

    template <_Container_compatible_range<value_type> _Rng,
        _Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(from_range_t, _Rng&& _Range, const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Comp, _Alloc) {
        insert_range(_STD forward<_Rng>(_Range));
    }

    template <_Iterator_for_container _InputIterator>
    _Flat_map_base(
        _Sorted_t _Tag, _InputIterator _First, _InputIterator _Last, const key_compare& _Comp = key_compare())
        : _Flat_map_base(_Comp) {
        insert(_Tag, _First, _Last);
    }

    template <_Iterator_for_container _InputIterator,
        _Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(
        _Sorted_t _Tag, _InputIterator _First, _InputIterator _Last, const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Comp, _Alloc) {
        insert(_Tag, _First, _Last);
    }

    template <_Iterator_for_container _InputIterator,
        _Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_Sorted_t _Tag, _InputIterator _First, _InputIterator _Last, const _Allocator& _Alloc)
        : _Flat_map_base(_Tag, _First, _Last, key_compare(), _Alloc) {}

    _Flat_map_base(initializer_list<value_type> _Ilist, const key_compare& _Comp = key_compare())
        : _Flat_map_base(_Ilist.begin(), _Ilist.end(), _Comp) {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(initializer_list<value_type> _Ilist, const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Ilist.begin(), _Ilist.end(), _Comp, _Alloc) {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(initializer_list<value_type> _Ilist, const _Allocator& _Alloc)
        : _Flat_map_base(_Ilist, key_compare(), _Alloc) {}

    _Flat_map_base(_Sorted_t _Tag, initializer_list<value_type> _Ilist, const key_compare& _Comp = key_compare())
        : _Flat_map_base(_Tag, _Ilist.begin(), _Ilist.end(), _Comp) {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(
        _Sorted_t _Tag, initializer_list<value_type> _Ilist, const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Tag, _Ilist.begin(), _Ilist.end(), _Comp, _Alloc) {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_Sorted_t _Tag, initializer_list<value_type> _Ilist, const _Allocator& _Alloc)
        : _Flat_map_base(_Tag, _Ilist, key_compare(), _Alloc) {}

    // Copy constructors
    _Flat_map_base(const _Flat_map_base& _Other) : _Key_compare(_Other._Key_compare), _Data(_Other._Data) {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(const _Flat_map_base& _Other, const _Allocator& _Alloc)
        : _Key_compare(_Other._Key_compare),
          _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc, _Other._Data.keys),
              .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc, _Other._Data.values)} {}

    // Move constructors
    _Flat_map_base(_Flat_map_base&& _Other)
        noexcept(is_nothrow_copy_constructible_v<key_compare> && is_nothrow_move_constructible_v<key_compare>
                 && is_nothrow_move_constructible_v<key_container_type>
                 && is_nothrow_move_constructible_v<mapped_container_type>)
        : _Key_compare(_Other._Key_compare), _Data(_STD move(_Other).extract()) {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_Flat_map_base&& _Other, const _Allocator& _Alloc)
        : _Key_compare(_Other._Key_compare), _Data{_Other._Extract_using_allocator(_Alloc)} {}

    // Assignment
    _Flat_map_base& operator=(const _Flat_map_base& _Other) {
        _Clear_guard _Guard{this};
        _Key_compare   = _Other._Key_compare;
        _Data          = _Other._Data;
        _Guard._Target = nullptr;
        return *this;
    }

    _Flat_map_base& operator=(_Flat_map_base&& _Other) noexcept(
        is_nothrow_copy_assignable_v<key_compare> && is_nothrow_move_assignable_v<key_compare>
        && is_nothrow_move_assignable_v<key_container_type> && is_nothrow_move_assignable_v<mapped_container_type>) {
        _Clear_guard _Guard{this};
        _Key_compare   = _Other._Key_compare;
        _Data          = _STD move(_Other).extract();
        _Guard._Target = nullptr;
        return *this;
    }

    // [container.reqmts] iterators
    _NODISCARD iterator begin() noexcept {
        _STL_INTERNAL_STATIC_ASSERT(random_access_iterator<iterator>);
        return iterator{_STD cbegin(_Data.keys), _Data.values.begin()};
    }

    _NODISCARD const_iterator begin() const noexcept {
        _STL_INTERNAL_STATIC_ASSERT(random_access_iterator<const_iterator>);
        _STL_INTERNAL_STATIC_ASSERT(convertible_to<iterator, const_iterator>);
        return const_iterator{_STD cbegin(_Data.keys), _Data.values.begin()};
    }

    _NODISCARD iterator end() noexcept {
        return iterator{_STD cend(_Data.keys), _Data.values.end()};
    }

    _NODISCARD const_iterator end() const noexcept {
        return const_iterator{_STD cend(_Data.keys), _Data.values.end()};
    }

    _NODISCARD reverse_iterator rbegin() noexcept {
        return _STD make_reverse_iterator(end());
    }

    _NODISCARD const_reverse_iterator rbegin() const noexcept {
        return _STD make_reverse_iterator(end());
    }

    _NODISCARD reverse_iterator rend() noexcept {
        return _STD make_reverse_iterator(begin());
    }

    _NODISCARD const_reverse_iterator rend() const noexcept {
        return _STD make_reverse_iterator(begin());
    }

    _NODISCARD const_iterator cbegin() const noexcept {
        return const_iterator{_STD cbegin(_Data.keys), _STD cbegin(_Data.values)};
    }

    _NODISCARD const_iterator cend() const noexcept {
        return const_iterator{_STD cend(_Data.keys), _STD cend(_Data.values)};
    }

    _NODISCARD const_reverse_iterator crbegin() const noexcept {
        return _STD make_reverse_iterator(cend());
    }

    _NODISCARD const_reverse_iterator crend() const noexcept {
        return _STD make_reverse_iterator(cbegin());
    }

    void swap(_Derived& _Other) noexcept {
        auto& _Other_base = static_cast<_Flat_map_base&>(_Other);
        _RANGES swap(_Key_compare, _Other_base._Key_compare);
        _RANGES swap(_Data.keys, _Other_base._Data.keys);
        _RANGES swap(_Data.values, _Other_base._Data.values);
    }

    // [container.reqmts] clear
    void clear() noexcept {
        _Data.keys.clear();
        _Data.values.clear();
    }

    // [flat.map.capacity] Capacity
    _NODISCARD_EMPTY_MEMBER bool empty() const noexcept {
        return _Data.keys.empty();
    }

    _NODISCARD size_type size() const noexcept {
        return _Data.keys.size();
    }

    _NODISCARD size_type max_size() const noexcept {
        return _STD min(_Data.keys.max_size(), _Data.values.max_size());
    }

    template <class... _ArgTypes>
    iterator emplace_hint(const_iterator _Position, _ArgTypes&&... _Args)
        requires is_constructible_v<value_type, _ArgTypes...>
    {
        value_type _Val(_STD forward<_ArgTypes>(_Args)...);
        return _Emplace_hint<false>(_Position, _STD move(_Val.first), _STD move(_Val.second));
    }

    iterator insert(const_iterator _Position, const value_type& _Pair_val) {
        return emplace_hint(_Position, _Pair_val);
    }

    iterator insert(const_iterator _Position, value_type&& _Pair_val) {
        return emplace_hint(_Position, _STD move(_Pair_val));
    }

    template <class _PairValTy>
    iterator insert(const_iterator _Position, _PairValTy&& _Pair_val)
        requires is_constructible_v<value_type, _PairValTy>
    {
        return emplace_hint(_Position, _STD forward<_PairValTy>(_Pair_val));
    }

    template <_Iterator_for_container _InputIterator>
    void insert(_InputIterator _First, _InputIterator _Last) {
        _Insert_range<true, _IsUnique>(_First, _Last);
    }

    template <_Iterator_for_container _InputIterator>
    void insert(_Sorted_t, _InputIterator _First, _InputIterator _Last) {
        _Insert_range<false, _IsUnique>(_First, _Last);
    }

    template <_Container_compatible_range<value_type> _Rng>
    void insert_range(_Rng&& _Range) {
        _Insert_range<true, _IsUnique>(_RANGES begin(_Range), _RANGES end(_Range));
    }

    void insert(initializer_list<value_type> _Ilist) {
        insert(_Ilist.begin(), _Ilist.end());
    }

    void insert(_Sorted_t _Tag, initializer_list<value_type> _Ilist) {
        insert(_Tag, _Ilist.begin(), _Ilist.end());
    }

    iterator erase(iterator _Position) {
        return erase(static_cast<const_iterator>(_Position));
    }

    iterator erase(const_iterator _Position) {
        _Clear_guard _Guard{this};
        auto _Key_it   = _Data.keys.erase(_Position._Key_it);
        auto _Val_it   = _Data.values.erase(_Position._Mapped_it);
        _Guard._Target = nullptr;
        return iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    iterator erase(const_iterator _First, const_iterator _Last) {
        _Clear_guard _Guard{this};
        auto _Key_it   = _Data.keys.erase(_First._Key_it, _Last._Key_it);
        auto _Val_it   = _Data.values.erase(_First._Mapped_it, _Last._Mapped_it);
        _Guard._Target = nullptr;
        return iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    size_type erase(const key_type& _Key_val) {
        return _Erase_key(_Key_val);
    }

    template <class _OtherKey>
        requires _Is_transparent_v<key_compare> && (!is_convertible_v<_OtherKey, iterator>)
              && (!is_convertible_v<_OtherKey, const_iterator>)
    size_type erase(_OtherKey&& _Key_val) {
        return _Erase_key(_STD forward<_OtherKey>(_Key_val));
    }

    containers extract() && {
        _Clear_guard _Guard{this};
        return _STD move(_Data);
    }

    template <class _Allocator>
    containers _Extract_using_allocator(const _Allocator& _Alloc) {
        _Clear_guard _Guard{this};
        return containers{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc, _STD move(_Data.keys)),
            .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc, _STD move(_Data.values))};
    }

    void replace(key_container_type&& _Key_cont, mapped_container_type&& _Mapped_cont) {
        _Clear_guard _Guard{this};
        _Data.keys     = _STD move(_Key_cont);
        _Data.values   = _STD move(_Mapped_cont);
        _Guard._Target = nullptr;
    }

    // observers
    key_compare key_comp() const {
        return _Key_compare;
    }

    value_compare value_comp() const {
        return value_compare(_Key_compare);
    }

    const key_container_type& keys() const noexcept {
        return _Data.keys;
    }

    const mapped_container_type& values() const noexcept {
        return _Data.values;
    }

    // map operations
    _NODISCARD iterator find(const key_type& _Key_val) {
        return _Find(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD iterator find(const _OtherKey& _Key_val)
        requires _Is_transparent_v<key_compare>
    {
        return _Find(_Key_val);
    }

    _NODISCARD const_iterator find(const key_type& _Key_val) const {
        return _Find(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD const_iterator find(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _Find(_Key_val);
    }

    _NODISCARD size_type count(const key_type& _Key_val) const {
        return _Count(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD size_type count(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _Count(_Key_val);
    }

    _NODISCARD bool contains(const key_type& _Key_val) const {
        return _Contains(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD bool contains(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _Contains(_Key_val);
    }

    _NODISCARD iterator lower_bound(const key_type& _Key_val) {
        return _Lower_bound(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD iterator lower_bound(const _OtherKey& _Key_val)
        requires _Is_transparent_v<key_compare>
    {
        return _Lower_bound(_Key_val);
    }

    _NODISCARD const_iterator lower_bound(const key_type& _Key_val) const {
        return _Lower_bound(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD const_iterator lower_bound(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _Lower_bound(_Key_val);
    }

    _NODISCARD iterator upper_bound(const key_type& _Key_val) {
        return _Upper_bound(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD iterator upper_bound(const _OtherKey& _Key_val)
        requires _Is_transparent_v<key_compare>
    {
        return _Upper_bound(_Key_val);
    }

    _NODISCARD const_iterator upper_bound(const key_type& _Key_val) const {
        return _Upper_bound(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD const_iterator upper_bound(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _Upper_bound(_Key_val);
    }

    _NODISCARD pair<iterator, iterator> equal_range(const key_type& _Key_val) {
        return _Equal_range(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD pair<iterator, iterator> equal_range(const _OtherKey& _Key_val)
        requires _Is_transparent_v<key_compare>
    {
        return _Equal_range(_Key_val);
    }

    _NODISCARD pair<const_iterator, const_iterator> equal_range(const key_type& _Key_val) const {
        return _Equal_range(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD pair<const_iterator, const_iterator> equal_range(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _Equal_range(_Key_val);
    }

    _NODISCARD friend bool operator==(const _Derived& _Left, const _Derived& _Right) {
        auto& _Left_base  = static_cast<const _Flat_map_base&>(_Left);
        auto& _Right_base = static_cast<const _Flat_map_base&>(_Right);
        return _RANGES equal(_Left_base._Data.keys, _Right_base._Data.keys)
            && _RANGES equal(_Left_base._Data.values, _Right_base._Data.values);
    }

    _NODISCARD friend auto operator<=>(const _Derived& _Left, const _Derived& _Right) {
        return _STD lexicographical_compare_three_way(_STD _Get_unwrapped(_STD cbegin(_Left)),
            _STD _Get_unwrapped(_STD cend(_Left)), _STD _Get_unwrapped(_STD cbegin(_Right)),
            _STD _Get_unwrapped(_STD cend(_Right)), _Synth_three_way{});
    }

    friend void swap(_Derived& _Left, _Derived& _Right) noexcept {
        _Left.swap(_Right);
    }


protected:
    key_compare _Key_compare;
    containers _Data;

    template <class _Predicate>
    size_type _Erase_if(_Predicate _Pred) {
        auto _View           = _View_to_mutate();
        auto _Mut_first      = _View.begin();
        auto _Mut_last       = _View.end();
        const auto _Old_size = size();

        _Clear_guard<_Flat_map_base> _Guard{this};

        _STD _Seek_wrapped(_Mut_first, _RANGES remove_if(_View, _Pred).begin());
        (void) _Data.keys.erase(_Mut_first._Key_it, _Mut_last._Key_it);
        (void) _Data.values.erase(_Mut_first._Mapped_it, _Mut_last._Mapped_it);

        _Guard._Target = nullptr;
        return _Old_size - size();
    }

    template <bool _OverwriteIfExists, class _OtherKey, class... _MappedArgTypes>
    iterator _Emplace_hint(const const_iterator _Position, _OtherKey&& _Key_val, _MappedArgTypes&&... _Args) {
        _STL_INTERNAL_STATIC_ASSERT(
            is_constructible_v<mapped_type, _MappedArgTypes...>
            && (is_same_v<remove_cvref_t<_OtherKey>, key_type>
                || (is_constructible_v<key_type, _OtherKey> && _Is_transparent_v<key_compare>) ));
        static_assert(_IsUnique || !_OverwriteIfExists,
            "Overwriting is not supported when the container allows multiple copies of a key.");
        const const_iterator _Begin = cbegin();
        const const_iterator _End   = cend();

        const weak_ordering _Hint_order = [&] {
            if constexpr (_IsUnique) {
                if (_Position == _End || _Key_compare(_Key_val, *_Position._Key_it)) {
                    if (_Position == _Begin || _Key_compare(*_STD prev(_Position._Key_it), _Key_val)) {
                        return weak_ordering::equivalent;
                    } else {
                        return weak_ordering::greater;
                    }
                }
            } else {
                if (_Position == _End || !_Key_compare(*_Position._Key_it, _Key_val)) {
                    if (_Position == _Begin || !_Key_compare(_Key_val, *_STD prev(_Position._Key_it))) {
                        return weak_ordering::equivalent;
                    } else {
                        return weak_ordering::greater;
                    }
                }
            }
            return weak_ordering::less;
        }();

        if (_Hint_order == weak_ordering::equivalent) {
            const auto _Dist = _Position._Key_it - _Begin._Key_it;
            if constexpr (_IsUnique) {
                if (_Position != _Begin && !_Key_compare(*_STD prev(_Position._Key_it), _Key_val)) {
                    return begin() + _Dist;
                }
            }
            {
                key_type _Key_to_insert(_STD forward<_OtherKey>(_Key_val));
                mapped_type _Mapped_to_insert(_STD forward<_MappedArgTypes>(_Args)...);
                _Insert_exact(_Position, _STD move(_Key_to_insert), _STD move(_Mapped_to_insert));
            }
            return begin() + _Dist;
        }

        const auto _New_position = _Hint_order == weak_ordering::less ? _STD as_const(*this).lower_bound(_Key_val)
                                                                      : _STD as_const(*this).upper_bound(_Key_val);
        if constexpr (_IsUnique) {
            if (_Hint_order == weak_ordering::less) {
                if (_New_position != _End && !_Key_compare(_Key_val, *_New_position._Key_it)) {
                    const auto _Dist = _New_position._Key_it - _Begin._Key_it;
                    auto _It         = begin() + _Dist;
                    if constexpr (_OverwriteIfExists) {
                        *_It._Mapped_it = mapped_type(_STD forward<_MappedArgTypes>(_Args)...);
                    }
                    return _It;
                }
            } else {
                if (_New_position != _Begin && !_Key_compare(*_STD prev(_New_position._Key_it), _Key_val)) {
                    const auto _Dist = _STD prev(_New_position._Key_it) - _Begin._Key_it;
                    auto _It         = begin() + _Dist;
                    if constexpr (_OverwriteIfExists) {
                        *_It._Mapped_it = mapped_type(_STD forward<_MappedArgTypes>(_Args)...);
                    }
                    return _It;
                }
            }
        }

        const auto _Dist = _New_position - _Begin;
        {
            key_type _Key_to_insert(_STD forward<_OtherKey>(_Key_val));
            mapped_type _Mapped_to_insert(_STD forward<_MappedArgTypes>(_Args)...);
            _Insert_exact(_New_position, _STD move(_Key_to_insert), _STD move(_Mapped_to_insert));
        }
        return begin() + _Dist;
    }

    void _Insert_exact(const_iterator _Position, key_type&& _Key_val, mapped_type&& _Mapped_val) {
        _Clear_guard _Guard{this};
        _Data.keys.insert(_Position._Key_it, _STD move(_Key_val));
        _Data.values.insert(_Position._Mapped_it, _STD move(_Mapped_val));
        _Guard._Target = nullptr;
    }

    template <class _KeyTy1, class _KeyTy2>
    bool _Key_equal(_KeyTy1&& _Left, _KeyTy2&& _Right) const {
        _STL_INTERNAL_STATIC_ASSERT(
            (is_same_v<remove_cvref_t<_KeyTy1>, key_type> && is_same_v<remove_cvref_t<_KeyTy2>, key_type>)
            || (is_constructible_v<key_type, _KeyTy1> && is_constructible_v<key_type, _KeyTy2>
                && _Is_transparent_v<key_compare>) );
        return !_Key_compare(_STD forward<_KeyTy1>(_Left), _STD forward<_KeyTy2>(_Right))
            && !_Key_compare(_STD forward<_KeyTy2>(_Right), _STD forward<_KeyTy1>(_Left));
    }

private:
    auto _View_to_mutate() {
        using _Mutating_iterator = _Pairing_iterator_provider<typename key_container_type::iterator,
            typename mapped_container_type::iterator, typename mapped_container_type::iterator>::_Iterator;
        return _RANGES subrange<_Mutating_iterator>{_Mutating_iterator{_Data.keys.begin(), _Data.values.begin()},
            _Mutating_iterator{_Data.keys.end(), _Data.values.end()}};
    }

    void _Sort() {
        _Clear_guard _Guard{this};
        _RANGES sort(_View_to_mutate(), value_compare(_Key_compare));
        _Guard._Target = nullptr;
    }

    void _Dedup() {
        _Clear_guard _Guard{this};
        auto _Sorted_view = _View_to_mutate();
        auto _Subrange    = _RANGES unique(_Sorted_view, [this](const_reference _Left, const_reference _Right) {
            return this->_Key_equal(_Left.first, _Right.first);
        });
        const auto _Remaining_count = _Subrange.begin() - _Sorted_view.begin();
        _Data.keys.erase(_Data.keys.begin() + static_cast<_RANGES range_difference_t<_KeyContainer>>(_Remaining_count),
            _Data.keys.end());
        _Data.values.erase(
            _Data.values.begin() + static_cast<_RANGES range_difference_t<_MappedContainer>>(_Remaining_count),
            _Data.values.end());
        _Guard._Target = nullptr;
    }

    template <bool _NeedSorting, bool _NeedDeduping, class _InputIterator, class _Sentinel>
    void _Insert_range(_InputIterator _First, _Sentinel _Last) {
        _Clear_guard _Guard{this};

        const auto _Old_distance = static_cast<difference_type>(size());

        // Insert the new elements at the end
        for (; _First != _Last; ++_First) {
            value_type _Val = *_First;
            if constexpr (_Has_guaranteed_push_back<_KeyContainer>) {
                _Data.keys.push_back(_STD move(_Val.first));
            } else {
                _Data.keys.insert(_Data.keys.end(), _STD move(_Val.first));
            }

            if constexpr (_Has_guaranteed_push_back<_MappedContainer>) {
                _Data.values.push_back(_STD move(_Val.second));
            } else {
                _Data.values.insert(_Data.values.end(), _STD move(_Val.second));
            }
        }

        // Sort the newly inserted elements
        auto _Sorted_view = _View_to_mutate();
        if constexpr (_NeedSorting) {
            auto _Sorted_new_elements = _Sorted_view;
            _Sorted_new_elements.advance(_Old_distance);
            _RANGES sort(_Sorted_new_elements, value_compare(_Key_compare));
        }

        // Merge the newly inserted elements with the existing elements
        _RANGES inplace_merge(_Sorted_view, _Sorted_view.begin() + _Old_distance, value_compare(_Key_compare));

        if constexpr (_NeedDeduping) {
            _Dedup();
        }

        _Guard._Target = nullptr;
    }

    template <class _KeyTy>
    size_type _Erase_key(_KeyTy&& _Key_val) {
        const auto _Equal_pos = equal_range(_STD forward<_KeyTy>(_Key_val));
        const auto _Count     = static_cast<size_type>(_Equal_pos.second - _Equal_pos.first);
        erase(_Equal_pos.first, _Equal_pos.second);
        return _Count;
    }

    template <class _KeyTy>
    _NODISCARD iterator _Find(const _KeyTy& _Key_val) {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        iterator _Position = lower_bound(_Key_val);
        if (_Position != end() && !_Key_compare(_Key_val, _Position->first)) {
            return _Position;
        } else {
            return end();
        }
    }

    template <class _KeyTy>
    _NODISCARD const_iterator _Find(const _KeyTy& _Key_val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        const_iterator _Position = lower_bound(_Key_val);
        if (_Position != cend() && !_Key_compare(_Key_val, _Position->first)) {
            return _Position;
        } else {
            return cend();
        }
    }

    template <class _KeyTy>
    _NODISCARD size_type _Count(const _KeyTy& _Key_val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        return upper_bound(_Key_val) - lower_bound(_Key_val);
    }

    template <class _KeyTy>
    _NODISCARD bool _Contains(const _KeyTy& _Key_val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        return find(_Key_val) != cend();
    }

    template <class _KeyTy>
    _NODISCARD iterator _Lower_bound(const _KeyTy& _Key_val) {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        const auto _Key_unchecked_begin = _STD _Get_unwrapped(_STD cbegin(_Data.keys));
        const auto _Key_unchecked_it =
            _STD lower_bound(_Key_unchecked_begin, _STD _Get_unwrapped(_STD cend(_Data.keys)), _Key_val, _Key_compare);
        const auto _Dist = _Key_unchecked_it - _Key_unchecked_begin;

        auto _Key_it = _STD cbegin(_Data.keys);
        _STD _Seek_wrapped(_Key_it, _Key_unchecked_it);
        auto _Val_it = _Data.values.begin() + static_cast<_RANGES range_difference_t<_MappedContainer>>(_Dist);
        return iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    template <class _KeyTy>
    _NODISCARD const_iterator _Lower_bound(const _KeyTy& _Key_val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        const auto _Key_unchecked_begin = _STD _Get_unwrapped(_STD cbegin(_Data.keys));
        const auto _Key_unchecked_it =
            _STD lower_bound(_Key_unchecked_begin, _STD _Get_unwrapped(_STD cend(_Data.keys)), _Key_val, _Key_compare);
        const auto _Dist = _Key_unchecked_it - _Key_unchecked_begin;

        auto _Key_it = _STD cbegin(_Data.keys);
        _STD _Seek_wrapped(_Key_it, _Key_unchecked_it);
        auto _Val_it =
            _STD cbegin(_Data.values) + static_cast<_RANGES range_difference_t<const _MappedContainer>>(_Dist);
        return const_iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    template <class _KeyTy>
    _NODISCARD iterator _Upper_bound(const _KeyTy& _Key_val) {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        const auto _Key_unchecked_begin = _STD _Get_unwrapped(_STD cbegin(_Data.keys));
        const auto _Key_unchecked_it =
            _STD upper_bound(_Key_unchecked_begin, _STD _Get_unwrapped(_STD cend(_Data.keys)), _Key_val, _Key_compare);
        const auto _Dist = _Key_unchecked_it - _Key_unchecked_begin;

        auto _Key_it = _STD cbegin(_Data.keys);
        _STD _Seek_wrapped(_Key_it, _Key_unchecked_it);
        auto _Val_it = _Data.values.begin() + static_cast<_RANGES range_difference_t<_MappedContainer>>(_Dist);
        return iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    template <class _KeyTy>
    _NODISCARD const_iterator _Upper_bound(const _KeyTy& _Key_val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        const auto _Key_unchecked_begin = _STD _Get_unwrapped(_STD cbegin(_Data.keys));
        const auto _Key_unchecked_it =
            _STD upper_bound(_Key_unchecked_begin, _STD _Get_unwrapped(_STD cend(_Data.keys)), _Key_val, _Key_compare);
        const auto _Dist = _Key_unchecked_it - _Key_unchecked_begin;

        auto _Key_it = _STD cbegin(_Data.keys);
        _STD _Seek_wrapped(_Key_it, _Key_unchecked_it);
        auto _Val_it =
            _STD cbegin(_Data.values) + static_cast<_RANGES range_difference_t<const _MappedContainer>>(_Dist);
        return const_iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    template <class _KeyTy>
    _NODISCARD pair<iterator, iterator> _Equal_range(const _KeyTy& _Key_val) {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        return {lower_bound(_Key_val), upper_bound(_Key_val)};
    }

    template <class _KeyTy>
    _NODISCARD pair<const_iterator, const_iterator> _Equal_range(const _KeyTy& _Key_val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        return {lower_bound(_Key_val), upper_bound(_Key_val)};
    }
};

_EXPORT_STD template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer>
class flat_map : public _Flat_map_base<true, _Key, _Mapped, _Compare, _KeyContainer, _MappedContainer> {
private:
    using _MyBase = _Flat_map_base<true, _Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>;

    using _MyBase::_Data;
    using _MyBase::_Key_compare;

public:
    using typename _MyBase::const_iterator;
    using typename _MyBase::iterator;
    using typename _MyBase::key_compare;
    using typename _MyBase::key_type;
    using typename _MyBase::mapped_type;
    using typename _MyBase::value_type;

    using _MyBase::_MyBase;
    using _MyBase::clear;
    using _MyBase::insert;

#if 1 // TRANSITION, P2582R1 (MSVC, Clang, EDG)
    template <_Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
    flat_map(const flat_map& _Other, const _Allocator& _Al) : _MyBase(_Other, _Al) {}

    template <_Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
    flat_map(flat_map&& _Other, const _Allocator& _Al) : _MyBase(_STD move(_Other), _Al) {}
#endif // ^^^ workaround ^^^

    flat_map& operator=(initializer_list<value_type> _Ilist) {
        clear();
        insert(_Ilist.begin(), _Ilist.end());
        return *this;
    }

    // [flat.map.access] Access
    mapped_type& operator[](const key_type& _Key_val)
        requires is_default_constructible_v<mapped_type>
    {
        return this->try_emplace(_Key_val).first->second;
    }
    mapped_type& operator[](key_type&& _Key_val)
        requires is_default_constructible_v<mapped_type>
    {
        return this->try_emplace(_STD move(_Key_val)).first->second;
    }

    template <class _OtherKey>
    mapped_type& operator[](_OtherKey&& _Key_val)
        requires _Is_transparent_v<key_compare> && is_constructible_v<key_type, _OtherKey>
              && is_default_constructible_v<mapped_type>
    {
        return this->try_emplace(_STD forward<_OtherKey>(_Key_val)).first->second;
    }

    _NODISCARD mapped_type& at(const key_type& _Key_val) {
        return _At(_Key_val);
    }

    _NODISCARD const mapped_type& at(const key_type& _Key_val) const {
        return _At(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD mapped_type& at(const _OtherKey& _Key_val)
        requires _Is_transparent_v<key_compare>
    {
        return _At(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD const mapped_type& at(const _OtherKey& _Key_val) const
        requires _Is_transparent_v<key_compare>
    {
        return _At(_Key_val);
    }

    // [flat.map.modifiers] Modifiers
    template <class... _ArgTypes>
    pair<iterator, bool> emplace(_ArgTypes&&... _Args)
        requires is_constructible_v<value_type, _ArgTypes...>
    {
        value_type _Val(_STD forward<_ArgTypes>(_Args)...);
        return try_emplace(_STD move(_Val.first), _STD move(_Val.second));
    }

    pair<iterator, bool> insert(const value_type& _Pair_val) {
        return try_emplace(_Pair_val.first, _Pair_val.second);
    }

    pair<iterator, bool> insert(value_type&& _Pair_val) {
        return try_emplace(_STD move(_Pair_val.first), _STD move(_Pair_val.second));
    }

    template <class _PairValTy>
    pair<iterator, bool> insert(_PairValTy&& _Pair_val)
        requires is_constructible_v<value_type, _PairValTy>
    {
        return emplace(_STD forward<_PairValTy>(_Pair_val));
    }

    template <class... _MappedArgTypes>
        requires is_constructible_v<mapped_type, _MappedArgTypes&&...>
    pair<iterator, bool> try_emplace(const key_type& _Key_val, _MappedArgTypes&&... _Mapped_args) {
        return _Try_emplace(_Key_val, _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class... _MappedArgTypes>
        requires is_constructible_v<mapped_type, _MappedArgTypes&&...>
    pair<iterator, bool> try_emplace(key_type&& _Key_val, _MappedArgTypes&&... _Mapped_args) {
        return _Try_emplace(_STD move(_Key_val), _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class _OtherKey, class... _MappedArgTypes>
        requires _Is_transparent_v<key_compare> && is_constructible_v<key_type, _OtherKey>
              && is_constructible_v<mapped_type, _MappedArgTypes...> && (!is_convertible_v<_OtherKey, const_iterator>)
              && (!is_convertible_v<_OtherKey, iterator>)
    pair<iterator, bool> try_emplace(_OtherKey&& _Key_val, _MappedArgTypes&&... _Mapped_args) {
        return _Try_emplace(_STD forward<_OtherKey>(_Key_val), _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class... _MappedArgTypes>
    iterator try_emplace(const_iterator _Position, const key_type& _Key_val, _MappedArgTypes&&... _Mapped_args)
        requires is_constructible_v<mapped_type, _MappedArgTypes...>
    {
        return this->template _Emplace_hint<false>(_Position, _Key_val, _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class... _MappedArgTypes>
    iterator try_emplace(const_iterator _Position, key_type&& _Key_val, _MappedArgTypes&&... _Mapped_args)
        requires is_constructible_v<mapped_type, _MappedArgTypes&&...>
    {
        return this->template _Emplace_hint<false>(
            _Position, _STD move(_Key_val), _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class _OtherKey, class... _MappedArgTypes>
    iterator try_emplace(const_iterator _Position, _OtherKey&& _Key_val, _MappedArgTypes&&... _Mapped_args)
        requires _Is_transparent_v<key_compare> && is_constructible_v<key_type, _OtherKey>
              && is_constructible_v<mapped_type, _MappedArgTypes&&...>
    {
        return this->template _Emplace_hint<false>(
            _Position, _STD forward<_OtherKey>(_Key_val), _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class _MappedTy>
    pair<iterator, bool> insert_or_assign(const key_type& _Key_val, _MappedTy&& _Mapped_val)
        requires is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return _Insert_or_assign(_Key_val, _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _MappedTy>
    pair<iterator, bool> insert_or_assign(key_type&& _Key_val, _MappedTy&& _Mapped_val)
        requires is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return _Insert_or_assign(_STD move(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _OtherKey, class _MappedTy>
    pair<iterator, bool> insert_or_assign(_OtherKey&& _Key_val, _MappedTy&& _Mapped_val)
        requires _Is_transparent_v<key_compare> && is_constructible_v<key_type, _OtherKey>
              && is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return _Insert_or_assign(_STD forward<_OtherKey>(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _MappedTy>
    iterator insert_or_assign(const_iterator _Position, const key_type& _Key_val, _MappedTy&& _Mapped_val)
        requires is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return this->template _Emplace_hint<true>(_Position, _Key_val, _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _MappedTy>
    iterator insert_or_assign(const_iterator _Position, key_type&& _Key_val, _MappedTy&& _Mapped_val)
        requires is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return this->template _Emplace_hint<true>(_Position, _STD move(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _OtherKey, class _MappedTy>
    iterator insert_or_assign(const_iterator _Position, _OtherKey&& _Key_val, _MappedTy&& _Mapped_val)
        requires _Is_transparent_v<key_compare> && is_constructible_v<key_type, _OtherKey>
              && is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return this->template _Emplace_hint<true>(
            _Position, _STD forward<_OtherKey>(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
    }

private:
    using _MyBase::_Emplace_hint;
    using _MyBase::_Erase_if;
    using _MyBase::_Insert_exact;
    using _MyBase::_Key_equal;

    template <class _KTy, class _MTy, class _Comp, class _KeyCont, class _MappedCont, class _Pred>
    friend typename flat_map<_KTy, _MTy, _Comp, _KeyCont, _MappedCont>::size_type erase_if(
        flat_map<_KTy, _MTy, _Comp, _KeyCont, _MappedCont>&, _Pred);

    template <class _KeyTy>
    _NODISCARD mapped_type& _At(const _KeyTy& _Key_val) {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        const auto _Position = this->find(_Key_val);
        if (_Position == this->end()) {
            _Xout_of_range("std::flat_map::at: the specified key does not exist.");
        }

        return _Position->second;
    }

    template <class _KeyTy>
    _NODISCARD const mapped_type& _At(const _KeyTy& _Key_val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Is_transparent_v<key_compare>);
        const auto _Position = this->find(_Key_val);
        if (_Position == this->end()) {
            _Xout_of_range("std::flat_map::at: the specified key does not exist.");
        }

        return _Position->second;
    }

    template <class _KeyTy, class... _MappedArgTypes>
    pair<iterator, bool> _Try_emplace(_KeyTy&& _Key_val, _MappedArgTypes&&... _Mapped_args) {
        auto _Key_it = _STD lower_bound(_Data.keys.begin(), _Data.keys.end(), _Key_val, _Key_compare);
        if (_Key_it != _Data.keys.end() && !_Key_compare(_STD forward<_KeyTy>(_Key_val), *_Key_it)) {
            // Already exists
            return {this->begin() + (_Key_it - _Data.keys.begin()), false};
        }

        // Need to insert
        const auto _Index = _Key_it - _Data.keys.begin();
        {
            key_type _Key_to_insert(_STD forward<_KeyTy>(_Key_val));
            mapped_type _Mapped_to_insert(_STD forward<_MappedArgTypes>(_Mapped_args)...);
            this->_Insert_exact(_STD cbegin(*this) + _Index, _STD move(_Key_to_insert), _STD move(_Mapped_to_insert));
        }
        return {this->begin() + _Index, true};
    }

    template <class _KeyTy, class _MappedTy>
    pair<iterator, bool> _Insert_or_assign(_KeyTy&& _Key_val, _MappedTy&& _Mapped_val) {
        auto _Res = _Try_emplace(_STD forward<_KeyTy>(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
        if (!_Res.second) { // Already exists
            _Res.first->second = _STD forward<_MappedTy>(_Mapped_val);
        }
        return _Res;
    }
};

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare = less<typename _KeyContainer::value_type>>
flat_map(_KeyContainer, _MappedContainer, _Compare = _Compare()) -> flat_map<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, _Compare, _KeyContainer, _MappedContainer>;

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
flat_map(_KeyContainer, _MappedContainer, _Allocator) -> flat_map<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, less<typename _KeyContainer::value_type>, _KeyContainer, _MappedContainer>;

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare,
    _Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
flat_map(_KeyContainer, _MappedContainer, _Compare, _Allocator) -> flat_map<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, _Compare, _KeyContainer, _MappedContainer>;

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare = less<typename _KeyContainer::value_type>>
flat_map(sorted_unique_t, _KeyContainer, _MappedContainer, _Compare = _Compare())
    -> flat_map<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
flat_map(sorted_unique_t, _KeyContainer, _MappedContainer, _Allocator) -> flat_map<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, less<typename _KeyContainer::value_type>, _KeyContainer, _MappedContainer>;

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare,
    _Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
flat_map(sorted_unique_t, _KeyContainer, _MappedContainer, _Compare, _Allocator)
    -> flat_map<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <_Iterator_for_container _InputIterator,
    _Not_allocator_for_container _Compare = less<_Guide_key_t<_InputIterator>>>
flat_map(_InputIterator, _InputIterator, _Compare = _Compare())
    -> flat_map<_Guide_key_t<_InputIterator>, _Guide_val_t<_InputIterator>, _Compare>;

template <_Iterator_for_container _InputIterator,
    _Not_allocator_for_container _Compare = less<_Guide_key_t<_InputIterator>>>
flat_map(sorted_unique_t, _InputIterator, _InputIterator, _Compare = _Compare())
    -> flat_map<_Guide_key_t<_InputIterator>, _Guide_val_t<_InputIterator>, _Compare>;

#ifdef __cpp_lib_byte
// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Rng, _Not_allocator_for_container _Compare = less<_Range_key_type<_Rng>>,
    class _Allocator = allocator<byte>, enable_if_t<_Allocator_for_container<_Allocator>, int> = 0>
flat_map(from_range_t, _Rng&&, _Compare = _Compare(), _Allocator = _Allocator())
    -> flat_map<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>, _Compare,
        vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
        vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;
#else // ^^^ defined(__cpp_lib_byte) / !defined(__cpp_lib_byte) vvv
template <_RANGES input_range _Rng, _Not_allocator_for_container _Compare = less<_Range_key_type<_Rng>>>
flat_map(from_range_t, _Rng&&, _Compare = _Compare()) -> flat_map<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>,
    _Compare, vector<_Range_key_type<_Rng>>, vector<_Range_mapped_type<_Rng>>>;

// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Rng, _Not_allocator_for_container _Compare, class _Allocator,
    enable_if_t<_Allocator_for_container<_Allocator>, int> = 0>
flat_map(from_range_t, _Rng&&, _Compare, _Allocator) -> flat_map<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>,
    _Compare, vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
    vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;
#endif // ^^^ !defined(__cpp_lib_byte) ^^^

// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Rng, class _Allocator, enable_if_t<_Allocator_for_container<_Allocator>, int> = 0>
flat_map(from_range_t, _Rng&&, _Allocator) -> flat_map<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>,
    less<_Range_key_type<_Rng>>, vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
    vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;

template <class _Key, class _Mapped, _Not_allocator_for_container _Compare = less<_Key>>
flat_map(initializer_list<pair<_Key, _Mapped>>, _Compare = _Compare()) -> flat_map<_Key, _Mapped, _Compare>;

template <class _Key, class _Mapped, _Not_allocator_for_container _Compare = less<_Key>>
flat_map(sorted_unique_t, initializer_list<pair<_Key, _Mapped>>, _Compare = _Compare())
    -> flat_map<_Key, _Mapped, _Compare>;

// Specialization of uses_allocator
template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer, class _Allocator>
struct uses_allocator<flat_map<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>, _Allocator>
    : bool_constant<uses_allocator_v<_KeyContainer, _Allocator> && uses_allocator_v<_MappedContainer, _Allocator>> {};

_EXPORT_STD template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer,
    class _Predicate>
flat_map<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>::size_type erase_if(
    flat_map<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>& _Cont, _Predicate _Pred) {
    return _Cont._Erase_if(_STD _Pass_fn(_Pred));
}

_EXPORT_STD template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer>
class flat_multimap : public _Flat_map_base<false, _Key, _Mapped, _Compare, _KeyContainer, _MappedContainer> {
private:
    using _MyBase = _Flat_map_base<false, _Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>;

    using _MyBase::_Data;
    using _MyBase::_Key_compare;

public:
    using typename _MyBase::iterator;
    using typename _MyBase::value_type;

    using _MyBase::_MyBase;
    using _MyBase::clear;
    using _MyBase::insert;

#if 1 // TRANSITION, P2582R1 (MSVC, Clang, EDG)
    template <_Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
    flat_multimap(const flat_multimap& _Other, const _Allocator& _Al) : _MyBase(_Other, _Al) {}

    template <_Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
    flat_multimap(flat_multimap&& _Other, const _Allocator& _Al) : _MyBase(_STD move(_Other), _Al) {}
#endif // ^^^ workaround ^^^

    flat_multimap& operator=(initializer_list<value_type> _Ilist) {
        clear();
        insert(_Ilist.begin(), _Ilist.end());
        return *this;
    }

    // [flat.multimap.modifiers] Modifiers
    template <class... _ArgTypes>
    iterator emplace(_ArgTypes&&... _Args)
        requires is_constructible_v<value_type, _ArgTypes...>
    {
        value_type _Val(_STD forward<_ArgTypes>(_Args)...);
        return _Emplace_key_mapped(_STD move(_Val.first), _STD move(_Val.second));
    }

    iterator insert(const value_type& _Px) {
        return _Emplace_key_mapped(_Px.first, _Px.second);
    }

    iterator insert(value_type&& _Px) {
        return _Emplace_key_mapped(_STD move(_Px.first), _STD move(_Px.second));
    }

    template <class _PairValTy>
    iterator insert(_PairValTy&& _Pair_val)
        requires is_constructible_v<value_type, _PairValTy>
    {
        return emplace(_STD forward<_PairValTy>(_Pair_val));
    }

private:
    using _MyBase::_Emplace_hint;
    using _MyBase::_Erase_if;
    using _MyBase::_Insert_exact;
    using _MyBase::_Key_equal;

    template <class _KTy, class _MTy, class _Comp, class _KeyCont, class _MappedCont, class _Pred>
    friend typename flat_multimap<_KTy, _MTy, _Comp, _KeyCont, _MappedCont>::size_type erase_if(
        flat_multimap<_KTy, _MTy, _Comp, _KeyCont, _MappedCont>&, _Pred);

    template <class _KeyTy, class _MappedTy>
    iterator _Emplace_key_mapped(_KeyTy&& _Key_val, _MappedTy&& _Mapped_val) {
        const auto _Key_it = _STD upper_bound(_Data.keys.begin(), _Data.keys.end(), _Key_val, _Key_compare);
        const auto _Index  = _Key_it - _Data.keys.begin();

        {
            _Key _Key_to_insert(_STD forward<_KeyTy>(_Key_val));
            _Mapped _Mapped_to_insert(_STD forward<_MappedTy>(_Mapped_val));
            this->_Insert_exact(_STD cbegin(*this) + _Index, _STD move(_Key_to_insert), _STD move(_Mapped_to_insert));
        }
        return this->begin() + _Index;
    }
};

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare = less<typename _KeyContainer::value_type>>
flat_multimap(_KeyContainer, _MappedContainer, _Compare = _Compare())
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
flat_multimap(_KeyContainer, _MappedContainer, _Allocator) -> flat_multimap<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, less<typename _KeyContainer::value_type>, _KeyContainer, _MappedContainer>;
template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare,
    _Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
flat_multimap(_KeyContainer, _MappedContainer, _Compare, _Allocator)
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare = less<typename _KeyContainer::value_type>>
flat_multimap(sorted_equivalent_t, _KeyContainer, _MappedContainer, _Compare = _Compare())
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
flat_multimap(sorted_equivalent_t, _KeyContainer, _MappedContainer, _Allocator)
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type,
        less<typename _KeyContainer::value_type>, _KeyContainer, _MappedContainer>;
template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare,
    _Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
flat_multimap(sorted_equivalent_t, _KeyContainer, _MappedContainer, _Compare, _Allocator)
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <_Iterator_for_container _InputIterator,
    _Not_allocator_for_container _Compare = less<_Guide_key_t<_InputIterator>>>
flat_multimap(_InputIterator, _InputIterator, _Compare = _Compare())
    -> flat_multimap<_Guide_key_t<_InputIterator>, _Guide_val_t<_InputIterator>, _Compare>;

template <_Iterator_for_container _InputIterator,
    _Not_allocator_for_container _Compare = less<_Guide_key_t<_InputIterator>>>
flat_multimap(sorted_equivalent_t, _InputIterator, _InputIterator, _Compare = _Compare())
    -> flat_multimap<_Guide_key_t<_InputIterator>, _Guide_val_t<_InputIterator>, _Compare>;

#ifdef __cpp_lib_byte
// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Rng, _Not_allocator_for_container _Compare = less<_Range_key_type<_Rng>>,
    class _Allocator = allocator<byte>, enable_if_t<_Allocator_for_container<_Allocator>, int> = 0>
flat_multimap(from_range_t, _Rng&&, _Compare = _Compare(), _Allocator = _Allocator())
    -> flat_multimap<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>, _Compare,
        vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
        vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;
#else // ^^^ defined(__cpp_lib_byte) / !defined(__cpp_lib_byte) vvv
template <_RANGES input_range _Rng, _Not_allocator_for_container _Compare = less<_Range_key_type<_Rng>>>
flat_multimap(from_range_t, _Rng&&, _Compare = _Compare()) -> flat_multimap<_Range_key_type<_Rng>,
    _Range_mapped_type<_Rng>, _Compare, vector<_Range_key_type<_Rng>>, vector<_Range_mapped_type<_Rng>>>;

// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Rng, _Not_allocator_for_container _Compare, class _Allocator,
    enable_if_t<_Allocator_for_container<_Allocator>, int> = 0>
flat_multimap(from_range_t, _Rng&&, _Compare, _Allocator)
    -> flat_multimap<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>, _Compare,
        vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
        vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;
#endif // ^^^ !defined(__cpp_lib_byte) ^^^

// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Rng, class _Allocator, enable_if_t<_Allocator_for_container<_Allocator>, int> = 0>
flat_multimap(from_range_t, _Rng&&, _Allocator) -> flat_multimap<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>,
    less<_Range_key_type<_Rng>>, vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
    vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;

template <class _Key, class _Mapped, _Not_allocator_for_container _Compare = less<_Key>>
flat_multimap(initializer_list<pair<_Key, _Mapped>>, _Compare = _Compare()) -> flat_multimap<_Key, _Mapped, _Compare>;

template <class _Key, class _Mapped, _Not_allocator_for_container _Compare = less<_Key>>
flat_multimap(sorted_equivalent_t, initializer_list<pair<_Key, _Mapped>>, _Compare = _Compare())
    -> flat_multimap<_Key, _Mapped, _Compare>;

// Specialization of uses_allocator
template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer, class _Allocator>
struct uses_allocator<flat_multimap<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>, _Allocator>
    : bool_constant<uses_allocator_v<_KeyContainer, _Allocator> && uses_allocator_v<_MappedContainer, _Allocator>> {};

_EXPORT_STD template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer,
    class _Predicate>
flat_multimap<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>::size_type erase_if(
    flat_multimap<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>& _Cont, _Predicate _Pred) {
    return _Cont._Erase_if(_STD _Pass_fn(_Pred));
}
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // ^^^ _HAS_CXX23 ^^^
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _FLAT_MAP_
