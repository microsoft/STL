// flat_map standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _FLAT_MAP_
#define _FLAT_MAP_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR
#if !_HAS_CXX23
_EMIT_STL_WARNING(STL4038, "The contents of <flat_map> are available only with C++23 or later.");
#else // ^^^ !_HAS_CXX23 / _HAS_CXX23 vvv

#include <algorithm>
#include <compare>
#include <concepts>
#include <initializer_list>
#include <type_traits>
#include <utility>
#include <vector>
#include <xmemory>
#include <xutility>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

// TRANSITION, non-_Ugly attribute tokens
#pragma push_macro("msvc")
#undef msvc

_STD_BEGIN
// Implementation

template <bool _IsUnique, class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer>
class _Flat_map_base;

template <class _KeyIter, class _MappedIter, class _MappedConvIter>
struct _Pairing_iterator_provider;

template <class _KeyIter, class _MappedIter, class _MappedConvIter>
concept _Can_unwrap_pairing_iterator =
    !conjunction_v<is_same<_Unwrapped_t<_KeyIter>, _KeyIter>, is_same<_Unwrapped_t<_MappedIter>, _MappedIter>>;

template <class _KeyIter, class _MappedIter, class _MappedConvIter>
using _Unwrapped_pairing_iterator = _Pairing_iterator_provider<_Unwrapped_t<_KeyIter>, _Unwrapped_t<_MappedIter>,
    _Unwrapped_t<_MappedConvIter>>::_Iterator;

template <class _KeyIter, class _MappedIter, class _MappedConvIter>
struct _Pairing_iterator_provider {
    class _Iterator {
    public:
        template <bool _IsUnique, class _Key, class _Mapped, class _Compare, class _KeyContainer,
            class _MappedContainer>
        friend class _Flat_map_base;

        _Iterator() = default;
        _Iterator(_KeyIter _Key_iter, _MappedIter _Mapped_iter)
            noexcept(is_nothrow_move_constructible_v<_KeyIter> && is_nothrow_move_constructible_v<_MappedIter>)
            : _Key_it(_STD move(_Key_iter)), _Mapped_it(_STD move(_Mapped_iter)) {}

        using iterator_category = input_iterator_tag;
        using iterator_concept  = random_access_iterator_tag;
        using difference_type   = ptrdiff_t;
        using value_type        = pair<iter_value_t<_KeyIter>, iter_value_t<_MappedIter>>;
        using reference         = pair<iter_reference_t<_KeyIter>, iter_reference_t<_MappedIter>>;

    private:
        using _Const_iterator = _Pairing_iterator_provider<_KeyIter, _MappedConvIter, _MappedConvIter>::_Iterator;

        class _Arrow_proxy {
        public:
            explicit _Arrow_proxy(const reference& _Rx) noexcept : _Ref{_Rx} {}

            _NODISCARD const reference* operator->() const noexcept {
                return _STD addressof(_Ref);
            }

        private:
            reference _Ref;
        };

    public:
        using pointer = _Arrow_proxy;

        _NODISCARD reference operator*() const {
            return reference{*_Key_it, *_Mapped_it};
        }

        _NODISCARD friend pair<iter_rvalue_reference_t<_KeyIter>, iter_rvalue_reference_t<_MappedIter>> iter_move(
            const _Iterator& _It) {
            return {_RANGES iter_move(_It._Key_it), _RANGES iter_move(_It._Mapped_it)};
        }

        _NODISCARD pointer operator->() const {
            return pointer{**this};
        }

        _Iterator& operator++() {
            ++_Key_it;
            ++_Mapped_it;
            return *this;
        }

        _Iterator operator++(int) {
            auto _Old = *this;
            ++*this;
            return _Old;
        }

        _NODISCARD bool operator==(const _Iterator& _Right) const {
            return _Key_it == _Right._Key_it;
        }

        _NODISCARD auto operator<=>(const _Iterator& _Right) const {
            return _Synth_three_way{}(_Key_it, _Right._Key_it);
        }

        _Iterator& operator--() {
            --_Key_it;
            --_Mapped_it;
            return *this;
        }

        _Iterator operator--(int) {
            auto _Old = *this;
            --*this;
            return _Old;
        }

        _Iterator& operator+=(const difference_type _Off) {
            _Key_it += static_cast<iter_difference_t<_KeyIter>>(_Off);
            _Mapped_it += static_cast<iter_difference_t<_MappedIter>>(_Off);
            return *this;
        }

        _Iterator& operator-=(const difference_type _Off) {
            _Key_it -= static_cast<iter_difference_t<_KeyIter>>(_Off);
            _Mapped_it -= static_cast<iter_difference_t<_MappedIter>>(_Off);
            return *this;
        }

        _NODISCARD _Iterator operator+(const difference_type _Off) const {
            auto _Old = *this;
            _Old += _Off;
            return _Old;
        }

        _NODISCARD _Iterator operator-(const difference_type _Off) const {
            auto _Old = *this;
            _Old -= _Off;
            return _Old;
        }

        _NODISCARD reference operator[](const difference_type _Off) const {
            return *(*this + _Off);
        }

        _NODISCARD difference_type operator-(const _Iterator& _Right) const {
            return _Key_it - _Right._Key_it;
        }

        _NODISCARD friend _Iterator operator+(const difference_type _Off, const _Iterator& _Right) {
            return _Right + _Off;
        }

        _NODISCARD operator _Const_iterator() const
            requires (!is_same_v<_MappedIter, _MappedConvIter>)
        {
            return _Const_iterator{_Key_it, _Mapped_it};
        }

        _NODISCARD const _KeyIter& _Key_iterator() const noexcept {
            return _Key_it;
        }

        _NODISCARD const _MappedIter& _Mapped_iterator() const noexcept {
            return _Mapped_it;
        }

        using _Prevent_inheriting_unwrap = _Iterator;

        friend void _Verify_range(const _Iterator& _First, const _Iterator& _Last) noexcept {
            if constexpr (_Range_verifiable_v<_KeyIter>) {
                _Verify_range(_First._Key_it, _Last._Key_it); // intentional ADL
            }

            if constexpr (_Range_verifiable_v<_MappedIter>) {
                _Verify_range(_First._Mapped_it, _Last._Mapped_it); // intentional ADL
            }

            _STL_VERIFY(_Last._Key_it - _First._Key_it == _Last._Mapped_it - _First._Mapped_it,
                "iterators from inconsistent ranges");
        }

        void _Verify_offset(const difference_type _Off) const noexcept {
            if constexpr (_Offset_verifiable_v<_KeyIter>) {
                _Key_it._Verify_offset(_Off);
            } else {
                _STL_VERIFY(_Off == 0 || _Key_it != _KeyIter(), "cannot seek value-initialized iterator");
            }

            if constexpr (_Offset_verifiable_v<_MappedIter>) {
                _Mapped_it._Verify_offset(_Off);
            } else {
                _STL_VERIFY(_Off == 0 || _Mapped_it != _MappedIter(), "cannot seek value-initialized iterator");
            }
        }

        _NODISCARD auto _Unwrapped() const
            requires _Can_unwrap_pairing_iterator<_KeyIter, _MappedIter, _MappedConvIter>
        {
            using _Unwrapped_iterator = _Unwrapped_pairing_iterator<_KeyIter, _MappedIter, _MappedConvIter>;
            return _Unwrapped_iterator{_STD _Get_unwrapped(_Key_it), _STD _Get_unwrapped(_Mapped_it)};
        }

        void _Seek_to(const _Unwrapped_pairing_iterator<_KeyIter, _MappedIter, _MappedConvIter>& _Dst)
            requires _Can_unwrap_pairing_iterator<_KeyIter, _MappedIter, _MappedConvIter>
        {
            _STD _Seek_wrapped(_Key_it, _Dst._Key_iterator());
            _STD _Seek_wrapped(_Mapped_it, _Dst._Mapped_iterator());
        }

    private:
        _KeyIter _Key_it;
        _MappedIter _Mapped_it;
    };
};

template <bool _IsNoexcept, class _Containers>
struct _NODISCARD _Flat_map_swap_clear_guard {
    // Invariant: (_Target1 == nullptr) == (_Target2 == nullptr)
    _Containers* _Target1;
    _Containers* _Target2;

    _Flat_map_swap_clear_guard& operator=(const _Flat_map_swap_clear_guard&) = delete;

    void _Dismiss() noexcept {
        _Target1 = nullptr;
        _Target2 = nullptr;
    }

    ~_Flat_map_swap_clear_guard() {
        if (_Target1) {
            _Target1->keys.clear();
            _Target1->values.clear();
            _Target2->keys.clear();
            _Target2->values.clear();
        }
    }
};
template <class _Containers>
struct _NODISCARD _Flat_map_swap_clear_guard<true, _Containers> {
    constexpr explicit _Flat_map_swap_clear_guard(_Containers*, _Containers*) noexcept {}

    _Flat_map_swap_clear_guard& operator=(const _Flat_map_swap_clear_guard&) = delete;

    void _Dismiss() noexcept {}
};

_EXPORT_STD template <class _Key, class _Mapped, class _Compare = less<_Key>, class _KeyContainer = vector<_Key>,
    class _MappedContainer = vector<_Mapped>>
class flat_map;

_EXPORT_STD template <class _Key, class _Mapped, class _Compare = less<_Key>, class _KeyContainer = vector<_Key>,
    class _MappedContainer = vector<_Mapped>>
class flat_multimap;

template <bool _IsUnique, class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer>
class _Flat_map_base {
private:
    using _Sorted_t = conditional_t<_IsUnique, sorted_unique_t, sorted_equivalent_t>;
    using _Derived  = conditional_t<_IsUnique, flat_map<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>,
         flat_multimap<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>>;

    static constexpr const char* _Msg_not_sorted = _IsUnique ? "Keys were not sorted-unique!" : "Keys were not sorted!";

public:
    using key_type              = _Key;
    using mapped_type           = _Mapped;
    using value_type            = pair<key_type, mapped_type>;
    using key_compare           = _Compare;
    using reference             = pair<const key_type&, mapped_type&>;
    using const_reference       = pair<const key_type&, const mapped_type&>;
    using size_type             = size_t;
    using difference_type       = ptrdiff_t;
    using key_container_type    = _KeyContainer;
    using mapped_container_type = _MappedContainer;

    using iterator = _Pairing_iterator_provider<typename key_container_type::const_iterator,
        typename mapped_container_type::iterator, typename mapped_container_type::const_iterator>::_Iterator;

    using const_iterator = _Pairing_iterator_provider<typename key_container_type::const_iterator,
        typename mapped_container_type::const_iterator, typename mapped_container_type::const_iterator>::_Iterator;

    using reverse_iterator       = _STD reverse_iterator<iterator>;
    using const_reverse_iterator = _STD reverse_iterator<const_iterator>;

    static_assert(is_same_v<key_type, typename key_container_type::value_type>,
        "key_type and key_container_type::value_type must be the same. "
        "(N5014 [flat.map.overview]/8, [flat.multimap.overview]/8)");
    static_assert(is_same_v<mapped_type, typename mapped_container_type::value_type>,
        "mapped_type and mapped_container_type::value_type must be the same. "
        "(N5014 [flat.map.overview]/8, [flat.multimap.overview]/8)");
    static_assert(!_Is_vector_bool<key_container_type>,
        "key_container_type cannot be vector<bool> because it is not a sequence container. "
        "(N5014 [flat.map.overview]/7, [flat.multimap.overview]/7)");
    static_assert(!_Is_vector_bool<mapped_container_type>,
        "mapped_container_type cannot be vector<bool> because it is not a sequence container. "
        "(N5014 [flat.map.overview]/7, [flat.multimap.overview]/7)");
    static_assert(random_access_iterator<typename key_container_type::const_iterator>,
        "key_container_type must support random-access iterators in order to be adapted. "
        "(N5014 [flat.map.overview]/7, [flat.multimap.overview]/7)");
    static_assert(random_access_iterator<typename mapped_container_type::const_iterator>,
        "mapped_container_type must support random-access iterators in order to be adapted. "
        "(N5014 [flat.map.overview]/7, [flat.multimap.overview]/7)");

    struct value_compare {
    public:
        _NODISCARD bool operator()(const_reference _Left, const_reference _Right) const {
            return _Key_comparator(_Left.first, _Right.first);
        }

        value_compare(key_compare _Comp) : _Key_comparator(_Comp) {}

    private:
        key_compare _Key_comparator;
    };

    struct containers {
        key_container_type keys;
        mapped_container_type values;
    };

    // [flat.map.cons] Constructors
    explicit _Flat_map_base(const key_compare& _Comp) : _Data(), _Key_compare(_Comp) {}
    _Flat_map_base() : _Flat_map_base(key_compare()) {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    explicit _Flat_map_base(const _Allocator& _Alloc) : _Flat_map_base(key_compare(), _Alloc) {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(const key_compare& _Comp, const _Allocator& _Alloc)
        : _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc),
              .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc)},
          _Key_compare(_Comp) {}

    _Flat_map_base(
        key_container_type _Key_cont, mapped_container_type _Mapped_cont, const key_compare& _Comp = key_compare())
        : _Data{.keys = _STD move(_Key_cont), .values = _STD move(_Mapped_cont)}, _Key_compare(_Comp) {
        _STL_ASSERT(_Data.keys.size() == _Data.values.size(), "key_cont.size() != mapped_cont.size()");
        _Sort_and_erase_dupes_if_not_multi();
    }

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(
        const key_container_type& _Key_cont, const mapped_container_type& _Mapped_cont, const _Allocator& _Alloc)
        : _Flat_map_base(_Key_cont, _Mapped_cont, key_compare(), _Alloc) {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(const key_container_type& _Key_cont, const mapped_container_type& _Mapped_cont,
        const key_compare& _Comp, const _Allocator& _Alloc)
        : _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc, _Key_cont),
              .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc, _Mapped_cont)},
          _Key_compare(_Comp) {
        _STL_ASSERT(_Data.keys.size() == _Data.values.size(), "key_cont.size() != mapped_cont.size()");
        _Sort_and_erase_dupes_if_not_multi();
    }

    _Flat_map_base(_Sorted_t, key_container_type _Key_cont, mapped_container_type _Mapped_cont,
        const key_compare& _Comp = key_compare())
        : _Data{.keys = _STD move(_Key_cont), .values = _STD move(_Mapped_cont)}, _Key_compare(_Comp) {
        _STL_ASSERT(_Data.keys.size() == _Data.values.size(), "key_cont.size() != mapped_cont.size()");
        _STL_ASSERT(_Is_sorted_and_unique(), _Msg_not_sorted);
    }

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_Sorted_t _Tag, const key_container_type& _Key_cont, const mapped_container_type& _Mapped_cont,
        const _Allocator& _Alloc)
        : _Flat_map_base(_Tag, _Key_cont, _Mapped_cont, key_compare(), _Alloc) {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_Sorted_t, const key_container_type& _Key_cont, const mapped_container_type& _Mapped_cont,
        const key_compare& _Comp, const _Allocator& _Alloc)
        : _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc, _Key_cont),
              .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc, _Mapped_cont)},
          _Key_compare(_Comp) {
        _STL_ASSERT(_Data.keys.size() == _Data.values.size(), "key_cont.size() != mapped_cont.size()");
        _STL_ASSERT(_Is_sorted_and_unique(), _Msg_not_sorted);
    }

    template <_Iterator_for_container _InputIterator>
    _Flat_map_base(const _InputIterator _First, const _InputIterator _Last, const key_compare& _Comp = key_compare())
        : _Flat_map_base(_Comp) {
        insert(_First, _Last);
    }

    template <_Iterator_for_container _InputIterator,
        _Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(const _InputIterator _First, const _InputIterator _Last, const _Allocator& _Alloc)
        : _Flat_map_base(_Alloc) {
        insert(_First, _Last);
    }

    template <_Iterator_for_container _InputIterator,
        _Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(
        const _InputIterator _First, const _InputIterator _Last, const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Comp, _Alloc) {
        insert(_First, _Last);
    }

    template <_Container_compatible_range<value_type> _Rng>
    _Flat_map_base(from_range_t _From_range, _Rng&& _Range)
        : _Flat_map_base(_From_range, _STD forward<_Rng>(_Range), key_compare()) {}

    template <_Container_compatible_range<value_type> _Rng,
        _Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(from_range_t _From_range, _Rng&& _Range, const _Allocator& _Alloc)
        : _Flat_map_base(_From_range, _STD forward<_Rng>(_Range), key_compare(), _Alloc) {}

    template <_Container_compatible_range<value_type> _Rng>
    _Flat_map_base(from_range_t, _Rng&& _Range, const key_compare& _Comp) : _Flat_map_base(_Comp) {
        insert_range(_STD forward<_Rng>(_Range));
    }

    template <_Container_compatible_range<value_type> _Rng,
        _Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(from_range_t, _Rng&& _Range, const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Comp, _Alloc) {
        insert_range(_STD forward<_Rng>(_Range));
    }

    template <_Iterator_for_container _InputIterator>
    _Flat_map_base(
        _Sorted_t, const _InputIterator _First, const _InputIterator _Last, const key_compare& _Comp = key_compare())
        : _Flat_map_base(_Comp) {
        _Insert_range<false>(_First, _Last);
    }

    template <_Iterator_for_container _InputIterator,
        _Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_Sorted_t, const _InputIterator _First, const _InputIterator _Last, const key_compare& _Comp,
        const _Allocator& _Alloc)
        : _Flat_map_base(_Comp, _Alloc) {
        _Insert_range<false>(_First, _Last);
    }

    template <_Iterator_for_container _InputIterator,
        _Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_Sorted_t _Tag, const _InputIterator _First, const _InputIterator _Last, const _Allocator& _Alloc)
        : _Flat_map_base(_Tag, _First, _Last, key_compare(), _Alloc) {}

    _Flat_map_base(const initializer_list<value_type> _Ilist, const key_compare& _Comp = key_compare())
        : _Flat_map_base(_Ilist.begin(), _Ilist.end(), _Comp) {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(const initializer_list<value_type> _Ilist, const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Ilist.begin(), _Ilist.end(), _Comp, _Alloc) {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(const initializer_list<value_type> _Ilist, const _Allocator& _Alloc)
        : _Flat_map_base(_Ilist, key_compare(), _Alloc) {}

    _Flat_map_base(_Sorted_t _Tag, const initializer_list<value_type> _Ilist, const key_compare& _Comp = key_compare())
        : _Flat_map_base(_Tag, _Ilist.begin(), _Ilist.end(), _Comp) {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(
        _Sorted_t _Tag, const initializer_list<value_type> _Ilist, const key_compare& _Comp, const _Allocator& _Alloc)
        : _Flat_map_base(_Tag, _Ilist.begin(), _Ilist.end(), _Comp, _Alloc) {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_Sorted_t _Tag, const initializer_list<value_type> _Ilist, const _Allocator& _Alloc)
        : _Flat_map_base(_Tag, _Ilist, key_compare(), _Alloc) {}

    // Copy constructors
    _Flat_map_base(const _Flat_map_base& _Other) : _Data(_Other._Data), _Key_compare(_Other._Key_compare) {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(const _Flat_map_base& _Other, const _Allocator& _Alloc)
        : _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc, _Other._Data.keys),
              .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc, _Other._Data.values)},
          _Key_compare(_Other._Key_compare) {}

    // Move constructors
    _Flat_map_base(_Flat_map_base&& _Other)
        noexcept(is_nothrow_copy_constructible_v<key_compare> && is_nothrow_move_constructible_v<key_container_type>
                 && is_nothrow_move_constructible_v<mapped_container_type>)
        : _Data(_STD move(_Other).extract()),
          _Key_compare(_Other._Key_compare) // intentionally copy comparator, see LWG-2227
    {}

    template <_Usable_allocator_for<key_container_type, mapped_container_type> _Allocator>
    _Flat_map_base(_Flat_map_base&& _Other, const _Allocator& _Alloc)
        : _Data{_STD move(_Other)._Extract_using_allocator(_Alloc)},
          _Key_compare(_Other._Key_compare) // intentionally copy comparator, see LWG-2227
    {}

    // Assignment
    _Flat_map_base& operator=(const _Flat_map_base& _Other) {
        _Clear_guard _Guard{this};
        _Data          = _Other._Data;
        _Key_compare   = _Other._Key_compare;
        _Guard._Target = nullptr;
        return *this;
    }

    _Flat_map_base& operator=(_Flat_map_base&& _Other)
        noexcept(is_nothrow_copy_assignable_v<key_compare> && is_nothrow_move_assignable_v<key_container_type>
                 && is_nothrow_move_assignable_v<mapped_container_type>) {

        if (this != _STD addressof(_Other)) {
            _Clear_guard _Guard{this};
            _Clear_guard _Always_clear{_STD addressof(_Other)};
            _Data          = _STD move(_Other._Data);
            _Key_compare   = _Other._Key_compare; // intentionally copy comparator, see LWG-2227
            _Guard._Target = nullptr;
        }
        return *this;
    }

    // [container.reqmts] iterators
    _NODISCARD iterator begin() noexcept {
        _STL_INTERNAL_STATIC_ASSERT(random_access_iterator<iterator>);
        return iterator{_STD cbegin(_Data.keys), _Data.values.begin()};
    }

    _NODISCARD const_iterator begin() const noexcept {
        _STL_INTERNAL_STATIC_ASSERT(random_access_iterator<const_iterator>);
        _STL_INTERNAL_STATIC_ASSERT(convertible_to<iterator, const_iterator>);
        return const_iterator{_STD cbegin(_Data.keys), _Data.values.begin()};
    }

    _NODISCARD iterator end() noexcept {
        return iterator{_STD cend(_Data.keys), _Data.values.end()};
    }

    _NODISCARD const_iterator end() const noexcept {
        return const_iterator{_STD cend(_Data.keys), _Data.values.end()};
    }

    _NODISCARD reverse_iterator rbegin() noexcept {
        return _STD make_reverse_iterator(end());
    }

    _NODISCARD const_reverse_iterator rbegin() const noexcept {
        return _STD make_reverse_iterator(end());
    }

    _NODISCARD reverse_iterator rend() noexcept {
        return _STD make_reverse_iterator(begin());
    }

    _NODISCARD const_reverse_iterator rend() const noexcept {
        return _STD make_reverse_iterator(begin());
    }

    _NODISCARD const_iterator cbegin() const noexcept {
        return const_iterator{_STD cbegin(_Data.keys), _STD cbegin(_Data.values)};
    }

    _NODISCARD const_iterator cend() const noexcept {
        return const_iterator{_STD cend(_Data.keys), _STD cend(_Data.values)};
    }

    _NODISCARD const_reverse_iterator crbegin() const noexcept {
        return _STD make_reverse_iterator(cend());
    }

    _NODISCARD const_reverse_iterator crend() const noexcept {
        return _STD make_reverse_iterator(cbegin());
    }

    void swap(_Derived& _Other)
        noexcept(is_nothrow_swappable_v<_KeyContainer> && is_nothrow_swappable_v<_MappedContainer>
                 && is_nothrow_swappable_v<key_compare>) {
        constexpr bool _Is_noexcept = is_nothrow_swappable_v<_KeyContainer> && is_nothrow_swappable_v<_MappedContainer>
                                   && is_nothrow_swappable_v<key_compare>;
        auto& _Other_base = static_cast<_Flat_map_base&>(_Other);
        _Flat_map_swap_clear_guard<_Is_noexcept, containers> _Guard{
            _STD addressof(_Data), _STD addressof(_Other_base._Data)};
        _RANGES swap(_Data.keys, _Other_base._Data.keys);
        _RANGES swap(_Data.values, _Other_base._Data.values);
        _RANGES swap(_Key_compare, _Other_base._Key_compare);
        _Guard._Dismiss();
    }

    // [container.reqmts] clear
    void clear() noexcept {
        _Data.keys.clear();
        _Data.values.clear();
    }

    // [flat.map.capacity] Capacity
    _NODISCARD_EMPTY_MEMBER bool empty() const noexcept {
        return _Data.keys.empty();
    }

    _NODISCARD size_type size() const noexcept {
        return _Data.keys.size();
    }

    _NODISCARD size_type max_size() const noexcept {
        return _STD min(_Data.keys.max_size(), _Data.values.max_size());
    }

    // [flat.map.modifiers] Modifiers
    template <class... _ArgTypes>
    auto emplace(_ArgTypes&&... _Args)
        requires is_constructible_v<value_type, _ArgTypes...>
    {
        value_type _Val(_STD forward<_ArgTypes>(_Args)...);
        return _Try_emplace(_STD move(_Val.first), _STD move(_Val.second));
    }

    auto insert(const value_type& _Pair_val) {
        return _Try_emplace(_Pair_val.first, _Pair_val.second);
    }

    auto insert(value_type&& _Pair_val) {
        return _Try_emplace(_STD move(_Pair_val.first), _STD move(_Pair_val.second));
    }

    template <class _PairValTy>
    auto insert(_PairValTy&& _Pair_val)
        requires is_constructible_v<value_type, _PairValTy>
    {
        return emplace(_STD forward<_PairValTy>(_Pair_val));
    }

    template <class... _ArgTypes>
    iterator emplace_hint(const const_iterator _Position, _ArgTypes&&... _Args)
        requires is_constructible_v<value_type, _ArgTypes...>
    {
        value_type _Val(_STD forward<_ArgTypes>(_Args)...);
        return _Emplace_hint<false>(_Position, _STD move(_Val.first), _STD move(_Val.second));
    }

    iterator insert(const const_iterator _Position, const value_type& _Pair_val) {
        return emplace_hint(_Position, _Pair_val);
    }

    iterator insert(const const_iterator _Position, value_type&& _Pair_val) {
        return emplace_hint(_Position, _STD move(_Pair_val));
    }

    template <class _PairValTy>
    iterator insert(const const_iterator _Position, _PairValTy&& _Pair_val)
        requires is_constructible_v<value_type, _PairValTy>
    {
        return emplace_hint(_Position, _STD forward<_PairValTy>(_Pair_val));
    }

    template <_Iterator_for_container _InputIterator>
    void insert(const _InputIterator _First, const _InputIterator _Last) {
        _Insert_range<true>(_First, _Last);
    }

    template <_Iterator_for_container _InputIterator>
    void insert(_Sorted_t, const _InputIterator _First, const _InputIterator _Last) {
        _Insert_range<false>(_First, _Last);
    }

    template <_Container_compatible_range<value_type> _Rng>
    void insert_range(_Rng&& _Range) {
        _Insert_range<true>(_RANGES begin(_Range), _RANGES end(_Range));
    }

    template <_Container_compatible_range<value_type> _Rng>
    void insert_range(_Sorted_t, _Rng&& _Range) {
        _Insert_range<false>(_RANGES begin(_Range), _RANGES end(_Range));
    }

    void insert(const initializer_list<value_type> _Ilist) {
        _Insert_range<true>(_Ilist.begin(), _Ilist.end());
    }

    void insert(_Sorted_t, const initializer_list<value_type> _Ilist) {
        _Insert_range<false>(_Ilist.begin(), _Ilist.end());
    }

    iterator erase(const iterator _Position) {
        return erase(static_cast<const_iterator>(_Position));
    }

    iterator erase(const const_iterator _Position) {
        _Clear_guard _Guard{this};
        auto _Key_it   = _Data.keys.erase(_Position._Key_it);
        auto _Val_it   = _Data.values.erase(_Position._Mapped_it);
        _Guard._Target = nullptr;
        return iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    iterator erase(const const_iterator _First, const const_iterator _Last) {
        _Clear_guard _Guard{this};
        auto _Key_it   = _Data.keys.erase(_First._Key_it, _Last._Key_it);
        auto _Val_it   = _Data.values.erase(_First._Mapped_it, _Last._Mapped_it);
        _Guard._Target = nullptr;
        return iterator{_STD move(_Key_it), _STD move(_Val_it)};
    }

    size_type erase(const key_type& _Key_val) {
        return _Erase_key(_Key_val);
    }

    template <class _OtherKey>
        requires _Transparent<key_compare> && (!is_convertible_v<_OtherKey, iterator>)
              && (!is_convertible_v<_OtherKey, const_iterator>)
    size_type erase(_OtherKey&& _Key_val) {
        return _Erase_key(_STD forward<_OtherKey>(_Key_val));
    }

    _NODISCARD containers extract() && noexcept(
        is_nothrow_move_constructible_v<key_container_type>
        && is_nothrow_move_constructible_v<mapped_container_type>) /* strengthened */ {
        // always clears the container (N5014 [flat.map.modifiers]/34 and [flat.multimap.overview]/4)
        _Clear_guard _Always_clear{this};
        return _STD move(_Data);
    }

    template <class _Allocator>
    _NODISCARD containers _Extract_using_allocator(const _Allocator& _Alloc) && {
        _Clear_guard _Always_clear{this};
        return containers{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc, _STD move(_Data.keys)),
            .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc, _STD move(_Data.values))};
    }

    void replace(key_container_type&& _Key_cont, mapped_container_type&& _Mapped_cont) {
        _STL_ASSERT(_Key_cont.size() == _Mapped_cont.size(), "key_cont.size() != mapped_cont.size()");
        _STL_ASSERT(_Is_sorted_and_unique(_Key_cont), _Msg_not_sorted);
        _Clear_guard _Guard{this};
        _Data.keys     = _STD move(_Key_cont);
        _Data.values   = _STD move(_Mapped_cont);
        _Guard._Target = nullptr;
    }

    // observers
    _NODISCARD key_compare key_comp() const {
        return _Key_compare;
    }

    _NODISCARD value_compare value_comp() const {
        return value_compare{_Key_compare};
    }

    _NODISCARD const key_container_type& keys() const noexcept {
        return _Data.keys;
    }

    _NODISCARD const mapped_container_type& values() const noexcept {
        return _Data.values;
    }

    // map operations
    _NODISCARD iterator find(const key_type& _Key_val) {
        return _Find(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD iterator find(const _OtherKey& _Key_val)
        requires _Transparent<key_compare>
    {
        return _Find(_Key_val);
    }

    _NODISCARD const_iterator find(const key_type& _Key_val) const {
        return _Find(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD const_iterator find(const _OtherKey& _Key_val) const
        requires _Transparent<key_compare>
    {
        return _Find(_Key_val);
    }

    _NODISCARD size_type count(const key_type& _Key_val) const {
        return _Count(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD size_type count(const _OtherKey& _Key_val) const
        requires _Transparent<key_compare>
    {
        return _Count(_Key_val);
    }

    _NODISCARD bool contains(const key_type& _Key_val) const {
        return _Contains(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD bool contains(const _OtherKey& _Key_val) const
        requires _Transparent<key_compare>
    {
        return _Contains(_Key_val);
    }

    _NODISCARD iterator lower_bound(const key_type& _Key_val) {
        return _Lower_bound(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD iterator lower_bound(const _OtherKey& _Key_val)
        requires _Transparent<key_compare>
    {
        return _Lower_bound(_Key_val);
    }

    _NODISCARD const_iterator lower_bound(const key_type& _Key_val) const {
        return _Lower_bound(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD const_iterator lower_bound(const _OtherKey& _Key_val) const
        requires _Transparent<key_compare>
    {
        return _Lower_bound(_Key_val);
    }

    _NODISCARD iterator upper_bound(const key_type& _Key_val) {
        return _Upper_bound(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD iterator upper_bound(const _OtherKey& _Key_val)
        requires _Transparent<key_compare>
    {
        return _Upper_bound(_Key_val);
    }

    _NODISCARD const_iterator upper_bound(const key_type& _Key_val) const {
        return _Upper_bound(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD const_iterator upper_bound(const _OtherKey& _Key_val) const
        requires _Transparent<key_compare>
    {
        return _Upper_bound(_Key_val);
    }

    _NODISCARD pair<iterator, iterator> equal_range(const key_type& _Key_val) {
        return _Equal_range(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD pair<iterator, iterator> equal_range(const _OtherKey& _Key_val)
        requires _Transparent<key_compare>
    {
        return _Equal_range(_Key_val);
    }

    _NODISCARD pair<const_iterator, const_iterator> equal_range(const key_type& _Key_val) const {
        return _Equal_range(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD pair<const_iterator, const_iterator> equal_range(const _OtherKey& _Key_val) const
        requires _Transparent<key_compare>
    {
        return _Equal_range(_Key_val);
    }

    _NODISCARD friend bool operator==(const _Derived& _Left, const _Derived& _Right) {
        return _STD equal(_STD _Get_unwrapped(_STD cbegin(_Left)), _STD _Get_unwrapped(_STD cend(_Left)),
            _STD _Get_unwrapped(_STD cbegin(_Right)), _STD _Get_unwrapped(_STD cend(_Right)));
    }

    _NODISCARD friend auto operator<=>(const _Derived& _Left, const _Derived& _Right) {
        return _STD lexicographical_compare_three_way(_STD _Get_unwrapped(_STD cbegin(_Left)),
            _STD _Get_unwrapped(_STD cend(_Left)), _STD _Get_unwrapped(_STD cbegin(_Right)),
            _STD _Get_unwrapped(_STD cend(_Right)), _Synth_three_way{});
    }

    friend void swap(_Derived& _Left, _Derived& _Right) noexcept(noexcept(_Left.swap(_Right))) {
        _Left.swap(_Right);
    }


protected:
    containers _Data;
    _MSVC_NO_UNIQUE_ADDRESS key_compare _Key_compare;

    _NODISCARD auto _Pass_key_comp() const noexcept {
        return _STD _Pass_fn(_Key_compare);
    }

    template <class _OtherKey, class... _MappedArgTypes>
    _NODISCARD conditional_t<_IsUnique, pair<iterator, bool>, iterator> _Try_emplace(
        _OtherKey&& _Key_val, _MappedArgTypes&&... _Mapped_args) {
        _STL_INTERNAL_STATIC_ASSERT(is_constructible_v<mapped_type, _MappedArgTypes...>);
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<remove_cvref_t<_OtherKey>, key_type>
                                    || (is_constructible_v<key_type, _OtherKey> && _Transparent<key_compare>) );

        const auto _Key_it = _RANGES upper_bound(_Data.keys, _Key_val, _Pass_key_comp());
        const auto _Index  = _RANGES distance(_Data.keys.begin(), _Key_it);
        if constexpr (_IsUnique) {
            if (_Key_it != _Data.keys.begin()
                && !_Key_compare(*_RANGES prev(_Key_it), _STD forward<_OtherKey>(_Key_val))) {
                // Previous element is equivalent to key, no insert needed
                return {this->begin() + (_Index - 1), false};
            }
        }

        // Need to insert
        key_type _Key_to_insert(_STD forward<_OtherKey>(_Key_val));
        mapped_type _Mapped_to_insert(_STD forward<_MappedArgTypes>(_Mapped_args)...);
        _Insert_exact(_STD cbegin(*this) + _Index, _STD move(_Key_to_insert), _STD move(_Mapped_to_insert));

        if constexpr (_IsUnique) {
            return {this->begin() + _Index, true};
        } else {
            return this->begin() + _Index;
        }
    }

    template <bool _OverwriteIfExists, class _OtherKey, class... _MappedArgTypes>
    _NODISCARD iterator _Emplace_hint(
        const const_iterator _Position, _OtherKey&& _Key_val, _MappedArgTypes&&... _Args) {
        _STL_INTERNAL_STATIC_ASSERT(is_constructible_v<mapped_type, _MappedArgTypes...>);
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<remove_cvref_t<_OtherKey>, key_type>
                                    || (is_constructible_v<key_type, _OtherKey> && _Transparent<key_compare>) );

        // Overwriting is not supported when the container allows multiple copies of a key.
        _STL_INTERNAL_STATIC_ASSERT(_IsUnique || !_OverwriteIfExists);

        const const_iterator _Begin = cbegin();
        const const_iterator _End   = cend();

        const weak_ordering _Hint_order = [&] {
            if constexpr (_IsUnique) {
                if (_Position == _End || _Key_compare(_Key_val, *_Position._Key_it)) {
                    if (_Position == _Begin || _Key_compare(*_STD prev(_Position._Key_it), _Key_val)) {
                        return weak_ordering::equivalent;
                    } else {
                        return weak_ordering::greater;
                    }
                }
            } else {
                if (_Position == _End || !_Key_compare(*_Position._Key_it, _Key_val)) {
                    if (_Position == _Begin || !_Key_compare(_Key_val, *_STD prev(_Position._Key_it))) {
                        return weak_ordering::equivalent;
                    } else {
                        return weak_ordering::greater;
                    }
                }
            }
            return weak_ordering::less;
        }();

        if (_Hint_order == weak_ordering::equivalent) {
            const auto _Dist = _Position._Key_it - _Begin._Key_it;
            {
                key_type _Key_to_insert(_STD forward<_OtherKey>(_Key_val));
                mapped_type _Mapped_to_insert(_STD forward<_MappedArgTypes>(_Args)...);
                _Insert_exact(_Position, _STD move(_Key_to_insert), _STD move(_Mapped_to_insert));
            }
            return begin() + _Dist;
        }

        const auto _New_position = _Hint_order == weak_ordering::less ? _STD as_const(*this).lower_bound(_Key_val)
                                                                      : _STD as_const(*this).upper_bound(_Key_val);
        if constexpr (_IsUnique) {
            if (_Hint_order == weak_ordering::less) {
                if (_New_position != _End && !_Key_compare(_Key_val, *_New_position._Key_it)) {
                    const auto _Dist = _New_position._Key_it - _Begin._Key_it;
                    const auto _It   = begin() + _Dist;
                    if constexpr (_OverwriteIfExists) {
                        *_It._Mapped_it = mapped_type(_STD forward<_MappedArgTypes>(_Args)...);
                    }
                    return _It;
                }
            } else {
                if (_New_position != _Begin && !_Key_compare(*_STD prev(_New_position._Key_it), _Key_val)) {
                    const auto _Dist = _STD prev(_New_position._Key_it) - _Begin._Key_it;
                    const auto _It   = begin() + _Dist;
                    if constexpr (_OverwriteIfExists) {
                        *_It._Mapped_it = mapped_type(_STD forward<_MappedArgTypes>(_Args)...);
                    }
                    return _It;
                }
            }
        }

        const auto _Dist = _New_position - _Begin;
        {
            key_type _Key_to_insert(_STD forward<_OtherKey>(_Key_val));
            mapped_type _Mapped_to_insert(_STD forward<_MappedArgTypes>(_Args)...);
            _Insert_exact(_New_position, _STD move(_Key_to_insert), _STD move(_Mapped_to_insert));
        }
        return begin() + _Dist;
    }

    void _Insert_exact(const const_iterator _Position, key_type&& _Key_val, mapped_type&& _Mapped_val) {
        _Clear_guard _Guard{this};
        _Data.keys.insert(_Position._Key_it, _STD move(_Key_val));
        _Data.values.insert(_Position._Mapped_it, _STD move(_Mapped_val));
        _Guard._Target = nullptr;
    }

    template <class _KeyTy1, class _KeyTy2>
    _NODISCARD bool _Key_equal(_KeyTy1&& _Left, _KeyTy2&& _Right) const {
        _STL_INTERNAL_STATIC_ASSERT(
            (is_same_v<remove_cvref_t<_KeyTy1>, key_type> && is_same_v<remove_cvref_t<_KeyTy2>, key_type>)
            || (is_constructible_v<key_type, _KeyTy1> && is_constructible_v<key_type, _KeyTy2>
                && _Transparent<key_compare>) );
        return !_Key_compare(_STD forward<_KeyTy1>(_Left), _STD forward<_KeyTy2>(_Right))
            && !_Key_compare(_STD forward<_KeyTy2>(_Right), _STD forward<_KeyTy1>(_Left));
    }

private:
    // FIXME, typename is an EDG workaround
    template <class _KTy, class _MTy, class _Comp, class _KeyCont, class _MappedCont, class _Pred>
    friend typename flat_map<_KTy, _MTy, _Comp, _KeyCont, _MappedCont>::size_type erase_if(
        flat_map<_KTy, _MTy, _Comp, _KeyCont, _MappedCont>&, _Pred);
    template <class _KTy, class _MTy, class _Comp, class _KeyCont, class _MappedCont, class _Pred>
    friend typename flat_multimap<_KTy, _MTy, _Comp, _KeyCont, _MappedCont>::size_type erase_if(
        flat_multimap<_KTy, _MTy, _Comp, _KeyCont, _MappedCont>&, _Pred);

    template <class _Predicate>
    _NODISCARD size_type _Erase_if(_Predicate _Pred) {
        auto _View           = _View_to_mutate();
        auto _Mut_first      = _View.begin();
        const auto _Mut_last = _View.end();
        const auto _Old_size = size();

        _Clear_guard _Guard{this};

        _STD _Seek_wrapped(_Mut_first, _RANGES remove_if(_View, _Pred).begin());
        _Data.keys.erase(_Mut_first._Key_it, _Mut_last._Key_it);
        _Data.values.erase(_Mut_first._Mapped_it, _Mut_last._Mapped_it);

        _Guard._Target = nullptr;
        return _Old_size - size();
    }

    _NODISCARD auto _View_to_mutate() {
        using _Mutating_iterator = _Pairing_iterator_provider<typename key_container_type::iterator,
            typename mapped_container_type::iterator, typename mapped_container_type::iterator>::_Iterator;
        return _RANGES subrange<_Mutating_iterator>{_Mutating_iterator{_Data.keys.begin(), _Data.values.begin()},
            _Mutating_iterator{_Data.keys.end(), _Data.values.end()}};
    }

public:
    _NODISCARD bool _Is_sorted_and_unique() const {
        return _Is_sorted_and_unique(_Data.keys);
    }

private:
    _NODISCARD bool _Is_sorted_and_unique(
        const key_container_type::const_iterator _It, const key_container_type::const_iterator _End) const {
        if constexpr (_IsUnique) {
            // sorted-unique
            auto _Negated = [this](const key_type& _Lhs, const key_type& _Rhs) { return !_Key_compare(_Lhs, _Rhs); };
            return _STD adjacent_find(_It, _End, _Negated) == _End;
        } else {
            return _STD is_sorted(_It, _End, _Pass_key_comp());
        }
    }

    _NODISCARD bool _Is_sorted_and_unique(const key_container_type& _Cont) const {
        return _Is_sorted_and_unique(_Cont.begin(), _Cont.end());
    }

    void _Sort_and_erase_dupes_if_not_multi() {
        _Clear_guard _Guard{this};

        // O(N) if already sorted.
        const auto _Begin_unsorted =
            _STD is_sorted_until(_STD cbegin(_Data.keys), _STD cend(_Data.keys), _Pass_key_comp());
        const difference_type _Num_sorted = _Begin_unsorted - _STD cbegin(_Data.keys);

        auto _View                        = _View_to_mutate();
        const auto _Begin                 = _STD begin(_View);
        const auto _Begin_unsorted_values = _Begin + _Num_sorted;
        const auto _End                   = _STD end(_View);

        _RANGES sort(_Begin_unsorted_values, _End, value_compare{_Key_compare});
        _RANGES inplace_merge(_Begin, _Begin_unsorted_values, _End, value_compare{_Key_compare});

        _Erase_dupes_if_not_multi();

        _STL_INTERNAL_CHECK(_Is_sorted_and_unique());

        _Guard._Target = nullptr;
    }

    void _Erase_dupes_if_not_multi() {
        if constexpr (_IsUnique) {
            auto _Sorted_view    = _View_to_mutate();
            const auto _Subrange = _RANGES unique(_Sorted_view, [this](const_reference _Left, const_reference _Right) {
                return this->_Key_equal(_Left.first, _Right.first);
            });
            const auto _Remaining_count = _Subrange.begin() - _Sorted_view.begin();
            _Data.keys.erase(
                _Data.keys.begin() + static_cast<_RANGES range_difference_t<_KeyContainer>>(_Remaining_count),
                _Data.keys.end());
            _Data.values.erase(
                _Data.values.begin() + static_cast<_RANGES range_difference_t<_MappedContainer>>(_Remaining_count),
                _Data.values.end());
        }
    }

    template <bool _NeedSorting, class _InputIterator, class _Sentinel>
    void _Insert_range(_InputIterator _First, const _Sentinel _Last) {
        _Clear_guard _Guard{this};

        const auto _Old_distance = static_cast<difference_type>(size());

        // Insert the new elements at the end
        for (; _First != _Last; ++_First) {
            value_type _Val = *_First;
            if constexpr (_Has_guaranteed_push_back<_KeyContainer>) {
                _Data.keys.push_back(_STD move(_Val.first));
            } else {
                _Data.keys.insert(_Data.keys.end(), _STD move(_Val.first));
            }

            if constexpr (_Has_guaranteed_push_back<_MappedContainer>) {
                _Data.values.push_back(_STD move(_Val.second));
            } else {
                _Data.values.insert(_Data.values.end(), _STD move(_Val.second));
            }
        }

        // Sort the newly inserted elements
        auto _Sorted_view = _View_to_mutate();
        if constexpr (_NeedSorting) {
            auto _Sorted_new_elements = _Sorted_view;
            _Sorted_new_elements.advance(_Old_distance);
            _RANGES sort(_Sorted_new_elements, value_compare{_Key_compare});
        } else {
            _STL_ASSERT(_Is_sorted_and_unique(
                            _Data.keys.begin() + static_cast<key_container_type::difference_type>(_Old_distance),
                            _Data.keys.end()),
                _Msg_not_sorted);
        }

        // Merge the newly inserted elements with the existing elements
        _RANGES inplace_merge(_Sorted_view, _Sorted_view.begin() + _Old_distance, value_compare{_Key_compare});

        _Erase_dupes_if_not_multi();
        _STL_INTERNAL_CHECK(_Is_sorted_and_unique());

        _Guard._Target = nullptr;
    }

    template <class _KeyTy>
    _NODISCARD size_type _Erase_key(_KeyTy&& _Key_val) {
        const auto _Equal_pos = equal_range(_STD forward<_KeyTy>(_Key_val));
        const auto _Count     = static_cast<size_type>(_Equal_pos.second - _Equal_pos.first);
        erase(_Equal_pos.first, _Equal_pos.second);
        return _Count;
    }

    template <class _SelfTy, class _KeyTy>
    _NODISCARD auto _Find(this _SelfTy& _Self, const _KeyTy& _Key_val) {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Transparent<key_compare>);
        const auto _Position = _Self.lower_bound(_Key_val);
        if (_Position != _Self.end() && !_Self._Key_compare(_Key_val, _Position->first)) {
            return _Position;
        } else {
            return _Self.end();
        }
    }

    template <class _KeyTy>
    _NODISCARD size_type _Count(const _KeyTy& _Key_val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Transparent<key_compare>);
        return upper_bound(_Key_val) - lower_bound(_Key_val);
    }

    template <class _KeyTy>
    _NODISCARD bool _Contains(const _KeyTy& _Key_val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Transparent<key_compare>);
        return find(_Key_val) != cend();
    }

    template <class _SelfTy, class _KeyTy, class _BoundFn>
    _NODISCARD auto _Find_bound(this _SelfTy& _Self, const _KeyTy& _Key_val, _BoundFn _Bound_fun) {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Transparent<key_compare>);
        const auto _Key_unchecked_begin = _STD _Get_unwrapped(_STD cbegin(_Self._Data.keys));
        const auto _Key_unchecked_it    = _Bound_fun(
            _Key_unchecked_begin, _STD _Get_unwrapped(_STD cend(_Self._Data.keys)), _Key_val, _Self._Pass_key_comp());
        const auto _Dist = _Key_unchecked_it - _Key_unchecked_begin;

        auto _Key_it = _STD cbegin(_Self._Data.keys);
        _STD _Seek_wrapped(_Key_it, _Key_unchecked_it);
        auto _Val_it =
            _STD begin(_Self._Data.values) + static_cast<_RANGES range_difference_t<mapped_container_type>>(_Dist);

        using _Maybe_const_iter = conditional_t<is_const_v<_SelfTy>, const_iterator, iterator>;
        return _Maybe_const_iter{_STD move(_Key_it), _STD move(_Val_it)};
    }

    template <class _SelfTy, class _KeyTy>
    _NODISCARD auto _Lower_bound(this _SelfTy& _Self, const _KeyTy& _Key_val) {
        return _Self._Find_bound(_Key_val, _RANGES lower_bound);
    }

    template <class _SelfTy, class _KeyTy>
    _NODISCARD auto _Upper_bound(this _SelfTy& _Self, const _KeyTy& _Key_val) {
        return _Self._Find_bound(_Key_val, _RANGES upper_bound);
    }

    template <class _SelfTy, class _KeyTy>
    _NODISCARD auto _Equal_range(this _SelfTy& _Self, const _KeyTy& _Key_val) {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Transparent<key_compare>);
        return pair{_Self.lower_bound(_Key_val), _Self.upper_bound(_Key_val)};
    }
};

_EXPORT_STD template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer>
class flat_map : public _Flat_map_base<true, _Key, _Mapped, _Compare, _KeyContainer, _MappedContainer> {
private:
    using _Mybase = _Flat_map_base<true, _Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>;

public:
    using _Mybase::_Mybase;
    flat_map(const flat_map&) = default;
    flat_map(flat_map&&)      = default;

    using typename _Mybase::const_iterator;
    using typename _Mybase::iterator;
    using typename _Mybase::key_compare;
    using typename _Mybase::key_type;
    using typename _Mybase::mapped_type;
    using typename _Mybase::value_type;

#if 1 // TRANSITION, P2582R1 (MSVC, Clang, EDG)
    template <_Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
    flat_map(const flat_map& _Other, const _Allocator& _Al) : _Mybase(_Other, _Al) {}

    template <_Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
    flat_map(flat_map&& _Other, const _Allocator& _Al) : _Mybase(_STD move(_Other), _Al) {}
#endif // ^^^ workaround ^^^

    flat_map& operator=(const initializer_list<value_type> _Ilist) {
        this->clear();
        this->insert(_Ilist.begin(), _Ilist.end());
        return *this;
    }

    flat_map& operator=(const flat_map&) = default;
    flat_map& operator=(flat_map&&)      = default;

    // [flat.map.access] Access
    mapped_type& operator[](const key_type& _Key_val)
        requires is_default_constructible_v<mapped_type>
    {
        return this->try_emplace(_Key_val).first->second;
    }
    mapped_type& operator[](key_type&& _Key_val)
        requires is_default_constructible_v<mapped_type>
    {
        return this->try_emplace(_STD move(_Key_val)).first->second;
    }

    template <class _OtherKey>
    mapped_type& operator[](_OtherKey&& _Key_val)
        requires _Transparent<key_compare> && is_constructible_v<key_type, _OtherKey>
              && is_default_constructible_v<mapped_type>
    {
        return this->try_emplace(_STD forward<_OtherKey>(_Key_val)).first->second;
    }

    _NODISCARD mapped_type& at(const key_type& _Key_val) {
        return _At(_Key_val);
    }

    _NODISCARD const mapped_type& at(const key_type& _Key_val) const {
        return _At(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD mapped_type& at(const _OtherKey& _Key_val)
        requires _Transparent<key_compare>
    {
        return _At(_Key_val);
    }

    template <class _OtherKey>
    _NODISCARD const mapped_type& at(const _OtherKey& _Key_val) const
        requires _Transparent<key_compare>
    {
        return _At(_Key_val);
    }

    // [flat.map.modifiers] Modifiers
    template <class... _MappedArgTypes>
        requires is_constructible_v<mapped_type, _MappedArgTypes&&...>
    pair<iterator, bool> try_emplace(const key_type& _Key_val, _MappedArgTypes&&... _Mapped_args) {
        return this->_Try_emplace(_Key_val, _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class... _MappedArgTypes>
        requires is_constructible_v<mapped_type, _MappedArgTypes&&...>
    pair<iterator, bool> try_emplace(key_type&& _Key_val, _MappedArgTypes&&... _Mapped_args) {
        return this->_Try_emplace(_STD move(_Key_val), _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class _OtherKey, class... _MappedArgTypes>
        requires _Transparent<key_compare> && is_constructible_v<key_type, _OtherKey>
              && is_constructible_v<mapped_type, _MappedArgTypes...> && (!is_convertible_v<_OtherKey, const_iterator>)
              && (!is_convertible_v<_OtherKey, iterator>)
    pair<iterator, bool> try_emplace(_OtherKey&& _Key_val, _MappedArgTypes&&... _Mapped_args) {
        return this->_Try_emplace(_STD forward<_OtherKey>(_Key_val), _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class... _MappedArgTypes>
    iterator try_emplace(const const_iterator _Position, const key_type& _Key_val, _MappedArgTypes&&... _Mapped_args)
        requires is_constructible_v<mapped_type, _MappedArgTypes...>
    {
        return this->template _Emplace_hint<false>(_Position, _Key_val, _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class... _MappedArgTypes>
    iterator try_emplace(const const_iterator _Position, key_type&& _Key_val, _MappedArgTypes&&... _Mapped_args)
        requires is_constructible_v<mapped_type, _MappedArgTypes&&...>
    {
        return this->template _Emplace_hint<false>(
            _Position, _STD move(_Key_val), _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class _OtherKey, class... _MappedArgTypes>
    iterator try_emplace(const const_iterator _Position, _OtherKey&& _Key_val, _MappedArgTypes&&... _Mapped_args)
        requires _Transparent<key_compare> && is_constructible_v<key_type, _OtherKey>
              && is_constructible_v<mapped_type, _MappedArgTypes&&...>
    {
        return this->template _Emplace_hint<false>(
            _Position, _STD forward<_OtherKey>(_Key_val), _STD forward<_MappedArgTypes>(_Mapped_args)...);
    }

    template <class _MappedTy>
    pair<iterator, bool> insert_or_assign(const key_type& _Key_val, _MappedTy&& _Mapped_val)
        requires is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return _Insert_or_assign(_Key_val, _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _MappedTy>
    pair<iterator, bool> insert_or_assign(key_type&& _Key_val, _MappedTy&& _Mapped_val)
        requires is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return _Insert_or_assign(_STD move(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _OtherKey, class _MappedTy>
    pair<iterator, bool> insert_or_assign(_OtherKey&& _Key_val, _MappedTy&& _Mapped_val)
        requires _Transparent<key_compare> && is_constructible_v<key_type, _OtherKey>
              && is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return _Insert_or_assign(_STD forward<_OtherKey>(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _MappedTy>
    iterator insert_or_assign(const const_iterator _Position, const key_type& _Key_val, _MappedTy&& _Mapped_val)
        requires is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return this->template _Emplace_hint<true>(_Position, _Key_val, _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _MappedTy>
    iterator insert_or_assign(const const_iterator _Position, key_type&& _Key_val, _MappedTy&& _Mapped_val)
        requires is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return this->template _Emplace_hint<true>(_Position, _STD move(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
    }

    template <class _OtherKey, class _MappedTy>
    iterator insert_or_assign(const const_iterator _Position, _OtherKey&& _Key_val, _MappedTy&& _Mapped_val)
        requires _Transparent<key_compare> && is_constructible_v<key_type, _OtherKey>
              && is_assignable_v<mapped_type&, _MappedTy> && is_constructible_v<mapped_type, _MappedTy>
    {
        return this->template _Emplace_hint<true>(
            _Position, _STD forward<_OtherKey>(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
    }

private:
    template <class _SelfTy, class _KeyTy>
    _NODISCARD auto& _At(this _SelfTy& _Self, const _KeyTy& _Key_val) {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Transparent<key_compare>);
        const auto _Position = _Self.find(_Key_val);
        if (_Position == _Self.end()) {
            _Xout_of_range("invalid flat_map key");
        }

        return _Position->second;
    }

    template <class _KeyTy, class _MappedTy>
    _NODISCARD pair<iterator, bool> _Insert_or_assign(_KeyTy&& _Key_val, _MappedTy&& _Mapped_val) {
        auto _Res = this->_Try_emplace(_STD forward<_KeyTy>(_Key_val), _STD forward<_MappedTy>(_Mapped_val));
        if (!_Res.second) { // Already exists
            _Res.first->second = _STD forward<_MappedTy>(_Mapped_val);
        }
        return _Res;
    }
};

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare = less<typename _KeyContainer::value_type>>
flat_map(_KeyContainer, _MappedContainer, _Compare = _Compare()) -> flat_map<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, _Compare, _KeyContainer, _MappedContainer>;

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
flat_map(_KeyContainer, _MappedContainer, _Allocator) -> flat_map<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, less<typename _KeyContainer::value_type>, _KeyContainer, _MappedContainer>;

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare,
    _Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
flat_map(_KeyContainer, _MappedContainer, _Compare, _Allocator) -> flat_map<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, _Compare, _KeyContainer, _MappedContainer>;

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare = less<typename _KeyContainer::value_type>>
flat_map(sorted_unique_t, _KeyContainer, _MappedContainer, _Compare = _Compare())
    -> flat_map<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
flat_map(sorted_unique_t, _KeyContainer, _MappedContainer, _Allocator) -> flat_map<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, less<typename _KeyContainer::value_type>, _KeyContainer, _MappedContainer>;

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare,
    _Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
flat_map(sorted_unique_t, _KeyContainer, _MappedContainer, _Compare, _Allocator)
    -> flat_map<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <_Iterator_for_container _InputIterator,
    _Not_allocator_for_container _Compare = less<_Guide_key_t<_InputIterator>>>
flat_map(_InputIterator, _InputIterator, _Compare = _Compare())
    -> flat_map<_Guide_key_t<_InputIterator>, _Guide_val_t<_InputIterator>, _Compare>;

template <_Iterator_for_container _InputIterator,
    _Not_allocator_for_container _Compare = less<_Guide_key_t<_InputIterator>>>
flat_map(sorted_unique_t, _InputIterator, _InputIterator, _Compare = _Compare())
    -> flat_map<_Guide_key_t<_InputIterator>, _Guide_val_t<_InputIterator>, _Compare>;

#ifdef __cpp_lib_byte
// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Rng, _Not_allocator_for_container _Compare = less<_Range_key_type<_Rng>>,
    class _Allocator = allocator<byte>, enable_if_t<_Allocator_for_container<_Allocator>, int> = 0>
flat_map(from_range_t, _Rng&&, _Compare = _Compare(), _Allocator = _Allocator())
    -> flat_map<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>, _Compare,
        vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
        vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;
#else // ^^^ defined(__cpp_lib_byte) / !defined(__cpp_lib_byte) vvv
template <_RANGES input_range _Rng, _Not_allocator_for_container _Compare = less<_Range_key_type<_Rng>>>
flat_map(from_range_t, _Rng&&, _Compare = _Compare()) -> flat_map<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>,
    _Compare, vector<_Range_key_type<_Rng>>, vector<_Range_mapped_type<_Rng>>>;

// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Rng, _Not_allocator_for_container _Compare, class _Allocator,
    enable_if_t<_Allocator_for_container<_Allocator>, int> = 0>
flat_map(from_range_t, _Rng&&, _Compare, _Allocator) -> flat_map<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>,
    _Compare, vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
    vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;
#endif // ^^^ !defined(__cpp_lib_byte) ^^^

// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Rng, class _Allocator, enable_if_t<_Allocator_for_container<_Allocator>, int> = 0>
flat_map(from_range_t, _Rng&&, _Allocator) -> flat_map<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>,
    less<_Range_key_type<_Rng>>, vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
    vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;

template <class _Key, class _Mapped, _Not_allocator_for_container _Compare = less<_Key>>
flat_map(initializer_list<pair<_Key, _Mapped>>, _Compare = _Compare()) -> flat_map<_Key, _Mapped, _Compare>;

template <class _Key, class _Mapped, _Not_allocator_for_container _Compare = less<_Key>>
flat_map(sorted_unique_t, initializer_list<pair<_Key, _Mapped>>, _Compare = _Compare())
    -> flat_map<_Key, _Mapped, _Compare>;

// Specialization of uses_allocator
template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer, class _Allocator>
struct uses_allocator<flat_map<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>, _Allocator>
    : bool_constant<uses_allocator_v<_KeyContainer, _Allocator> && uses_allocator_v<_MappedContainer, _Allocator>> {};

_EXPORT_STD template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer,
    class _Predicate>
flat_map<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>::size_type erase_if(
    flat_map<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>& _Cont, _Predicate _Pred) {
    return _Cont._Erase_if(_STD _Pass_fn(_Pred));
}

_EXPORT_STD template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer>
class flat_multimap : public _Flat_map_base<false, _Key, _Mapped, _Compare, _KeyContainer, _MappedContainer> {
private:
    using _Mybase = _Flat_map_base<false, _Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>;

public:
    using typename _Mybase::value_type;

    using _Mybase::_Mybase;
    flat_multimap(const flat_multimap&) = default;
    flat_multimap(flat_multimap&&)      = default;

#if 1 // TRANSITION, P2582R1 (MSVC, Clang, EDG)
    template <_Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
    flat_multimap(const flat_multimap& _Other, const _Allocator& _Al) : _Mybase(_Other, _Al) {}

    template <_Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
    flat_multimap(flat_multimap&& _Other, const _Allocator& _Al) : _Mybase(_STD move(_Other), _Al) {}
#endif // ^^^ workaround ^^^

    flat_multimap& operator=(const initializer_list<value_type> _Ilist) {
        this->clear();
        this->insert(_Ilist.begin(), _Ilist.end());
        return *this;
    }

    flat_multimap& operator=(const flat_multimap&) = default;
    flat_multimap& operator=(flat_multimap&&)      = default;
};

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare = less<typename _KeyContainer::value_type>>
flat_multimap(_KeyContainer, _MappedContainer, _Compare = _Compare())
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
flat_multimap(_KeyContainer, _MappedContainer, _Allocator) -> flat_multimap<typename _KeyContainer::value_type,
    typename _MappedContainer::value_type, less<typename _KeyContainer::value_type>, _KeyContainer, _MappedContainer>;
template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare,
    _Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
flat_multimap(_KeyContainer, _MappedContainer, _Compare, _Allocator)
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare = less<typename _KeyContainer::value_type>>
flat_multimap(sorted_equivalent_t, _KeyContainer, _MappedContainer, _Compare = _Compare())
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
flat_multimap(sorted_equivalent_t, _KeyContainer, _MappedContainer, _Allocator)
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type,
        less<typename _KeyContainer::value_type>, _KeyContainer, _MappedContainer>;
template <_Not_allocator_for_container _KeyContainer, _Not_allocator_for_container _MappedContainer,
    _Valid_compare_for_container<_KeyContainer> _Compare,
    _Usable_allocator_for<_KeyContainer, _MappedContainer> _Allocator>
flat_multimap(sorted_equivalent_t, _KeyContainer, _MappedContainer, _Compare, _Allocator)
    -> flat_multimap<typename _KeyContainer::value_type, typename _MappedContainer::value_type, _Compare, _KeyContainer,
        _MappedContainer>;

template <_Iterator_for_container _InputIterator,
    _Not_allocator_for_container _Compare = less<_Guide_key_t<_InputIterator>>>
flat_multimap(_InputIterator, _InputIterator, _Compare = _Compare())
    -> flat_multimap<_Guide_key_t<_InputIterator>, _Guide_val_t<_InputIterator>, _Compare>;

template <_Iterator_for_container _InputIterator,
    _Not_allocator_for_container _Compare = less<_Guide_key_t<_InputIterator>>>
flat_multimap(sorted_equivalent_t, _InputIterator, _InputIterator, _Compare = _Compare())
    -> flat_multimap<_Guide_key_t<_InputIterator>, _Guide_val_t<_InputIterator>, _Compare>;

#ifdef __cpp_lib_byte
// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Rng, _Not_allocator_for_container _Compare = less<_Range_key_type<_Rng>>,
    class _Allocator = allocator<byte>, enable_if_t<_Allocator_for_container<_Allocator>, int> = 0>
flat_multimap(from_range_t, _Rng&&, _Compare = _Compare(), _Allocator = _Allocator())
    -> flat_multimap<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>, _Compare,
        vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
        vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;
#else // ^^^ defined(__cpp_lib_byte) / !defined(__cpp_lib_byte) vvv
template <_RANGES input_range _Rng, _Not_allocator_for_container _Compare = less<_Range_key_type<_Rng>>>
flat_multimap(from_range_t, _Rng&&, _Compare = _Compare()) -> flat_multimap<_Range_key_type<_Rng>,
    _Range_mapped_type<_Rng>, _Compare, vector<_Range_key_type<_Rng>>, vector<_Range_mapped_type<_Rng>>>;

// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Rng, _Not_allocator_for_container _Compare, class _Allocator,
    enable_if_t<_Allocator_for_container<_Allocator>, int> = 0>
flat_multimap(from_range_t, _Rng&&, _Compare, _Allocator)
    -> flat_multimap<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>, _Compare,
        vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
        vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;
#endif // ^^^ !defined(__cpp_lib_byte) ^^^

// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Rng, class _Allocator, enable_if_t<_Allocator_for_container<_Allocator>, int> = 0>
flat_multimap(from_range_t, _Rng&&, _Allocator) -> flat_multimap<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>,
    less<_Range_key_type<_Rng>>, vector<_Range_key_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_key_type<_Rng>>>,
    vector<_Range_mapped_type<_Rng>, _Rebind_alloc_t<_Allocator, _Range_mapped_type<_Rng>>>>;

template <class _Key, class _Mapped, _Not_allocator_for_container _Compare = less<_Key>>
flat_multimap(initializer_list<pair<_Key, _Mapped>>, _Compare = _Compare()) -> flat_multimap<_Key, _Mapped, _Compare>;

template <class _Key, class _Mapped, _Not_allocator_for_container _Compare = less<_Key>>
flat_multimap(sorted_equivalent_t, initializer_list<pair<_Key, _Mapped>>, _Compare = _Compare())
    -> flat_multimap<_Key, _Mapped, _Compare>;

// Specialization of uses_allocator
template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer, class _Allocator>
struct uses_allocator<flat_multimap<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>, _Allocator>
    : bool_constant<uses_allocator_v<_KeyContainer, _Allocator> && uses_allocator_v<_MappedContainer, _Allocator>> {};

_EXPORT_STD template <class _Key, class _Mapped, class _Compare, class _KeyContainer, class _MappedContainer,
    class _Predicate>
flat_multimap<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>::size_type erase_if(
    flat_multimap<_Key, _Mapped, _Compare, _KeyContainer, _MappedContainer>& _Cont, _Predicate _Pred) {
    return _Cont._Erase_if(_STD _Pass_fn(_Pred));
}
_STD_END

// TRANSITION, non-_Ugly attribute tokens
#pragma pop_macro("msvc")

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // ^^^ _HAS_CXX23 ^^^
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _FLAT_MAP_
