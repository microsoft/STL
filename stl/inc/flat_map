#pragma once

#include <initializer_list>
#include <compare>
#include <concepts>
#include <cstdint>
#include <type_traits>
#include <utility>
#include <vector>

_STD_BEGIN

template <class Key, class T, class Compare = less<Key>, class KeyContainer = vector<Key>, class MappedContainer = vector<T>> requires same_as<Key, typename KeyContainer::value_type> && same_as<T, typename MappedContainer::value_type>
class flat_map;

struct sorted_unique_t { explicit sorted_unique_t() = default; };
inline constexpr sorted_unique_t sorted_unique {};

// Implementation

template <class Key, class T, class Compare, class KeyContainer, class MappedContainer> requires same_as<Key, typename KeyContainer::value_type> && same_as<T, typename MappedContainer::value_type>
class flat_map {
    public:
    using key_type = Key;
    using mapped_type = T;
    using value_type = pair<key_type, mapped_type>;
    using key_compare = Compare;
    using reference = pair<const key_type&, mapped_type&>;
    using const_reference = pair<const key_type&, const mapped_type&>;
    using size_type = size_t;
    using difference_type = ptrdiff_t;
    using key_container_type = KeyContainer;
    using mapped_container_type = MappedContainer;
    using iterator = typename key_container_type::iterator;
    using const_iterator = typename key_container_type::const_iterator;
    using reverse_iterator = _STD reverse_iterator<iterator>;
    using const_reverse_iterator = _STD reverse_iterator<const_iterator>;

    class value_compare {
        public:
        value_compare(key_compare _Comp) : _Key_compare_for_val(_Comp) {}

        bool operator () (const_reference _X, const_reference _Y) const {
            return _Key_compare_for_val(_X.first, _Y.first);
        }

        private:
        key_compare _Key_compare_for_val;
    };

    struct containers {
        key_container_type keys;
        mapped_container_type values;
    };

    // 24.6.8.3 construct / copy / destroy
    explicit flat_map(const key_compare& _Comp) : _Key_compare(_Comp) {}
    flat_map(): flat_map(key_compare()) {}

    // observers
    key_compare key_comp() const {
        return _Key_compare;
    }

    value_compare value_comp() const {
        return value_compare(_Key_compare);
    }

    const key_container_type& keys() const noexcept {
        return _Data.keys;
    }

    const mapped_container_type& values() const noexcept {
        return _Data.values;
    }

    private:
    key_compare _Key_compare;
    containers _Data;
};

_STD_END
