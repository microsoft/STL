// flat_map standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _FLAT_MAP_
#define _FLAT_MAP_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR

#include <algorithm>
#include <compare>
#include <concepts>
#include <cstdint>
#include <initializer_list>
#include <memory>
#include <ranges>
#include <type_traits>
#include <utility>
#include <vector>
#include <xmemory>
#include <xutility>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN

template <class Key, class T, class Compare = less<Key>, class KeyContainer = vector<Key>,
    class MappedContainer = vector<T>>
    requires same_as<Key, typename KeyContainer::value_type> && same_as<T, typename MappedContainer::value_type>
class flat_map;

struct sorted_unique_t {
    explicit sorted_unique_t() = default;
};
inline constexpr sorted_unique_t sorted_unique{};

template <class _Alloc, class _Key_container, class _Mapped_container>
concept _Valid_Allocator_for_flat_map =
    _STD uses_allocator_v<_Key_container, _Alloc> && _STD uses_allocator_v<_Mapped_container, _Alloc>;

template <class _Compare>
concept _Compare_is_transparent = requires { typename _Compare::is_transparent; };

template <class _Key, class _T, class _Key_compare>
struct _Flat_value_compare {
    struct value_compare {
    public:
        bool operator()(_STD pair<const _Key&, const _T&> _X, _STD pair<const _Key&, const _T&> _Y) const {
            return _Key_compare_for_val(_X.first, _Y.first);
        }

        value_compare(_Key_compare _Comp) : _Key_compare_for_val(_Comp) {}

    private:
        _Key_compare _Key_compare_for_val;
    };
};

template <class _Key_container, class _Mapped_container>
struct _Flat_Container {
    struct container {
        _Key_container keys;
        _Mapped_container values;
    };
};

template <class _Ty>
struct _NODISCARD _Clear_flat_map_scope_guard {
    _Ty* _Clearable;
    _Clear_flat_map_scope_guard(_Ty* _Clearable) : _Clearable(_Clearable) {}

    ~_Clear_flat_map_scope_guard() {
        if (_Clearable) {
            _Clearable->clear();
        }
    }
};

// Implementation

template <class _KeyContainer, class _MappedContainer, bool _IsConst>
class _Flat_map_iterator_Impl {
public:
    using _Key_iterator_t    = typename _KeyContainer::const_iterator;
    using _Mapped_iterator_t = _STD conditional_t<_IsConst, typename _MappedContainer::const_iterator, typename _MappedContainer::iterator>;
    class type {
    public:
        template <class Key, class T, class Compare, class KeyContainer, class MappedContainer> requires same_as<Key, typename KeyContainer::value_type> && same_as<T, typename MappedContainer::value_type>
        friend class flat_map;
        type() = default;
        type(_Key_iterator_t _Key_it, _Mapped_iterator_t _Mapped_it) : _Key_it(_Key_it), _Mapped_it(_Mapped_it) {}
        // Copy-constructible
        type(const type&) = default;
        // Copy-assignable
        type& operator=(const type&) = default;
        // Move-assignable
        type& operator=(type&&) = default;
        // Swappable
        // Destructible
        ~type() = default;

        using iterator_category = input_iterator_tag;
        using iterator_concept  = random_access_iterator_tag;
        using difference_type   = ptrdiff_t;
        using value_type        = _STD pair<_STD iter_value_t<_Key_iterator_t>, _STD iter_value_t<_Mapped_iterator_t>>;

    private:
        class _Arrow_Proxy: public _STD pair<_STD iter_const_reference_t<_Key_iterator_t>, _STD iter_reference_t<_Mapped_iterator_t>> {
        public:
            using _STD pair<_STD iter_const_reference_t<_Key_iterator_t>, _STD iter_reference_t<_Mapped_iterator_t>>::pair;
            _Arrow_Proxy* operator->() noexcept {
                return this;
            }
        };

    public:
        using pointer           = _Arrow_Proxy;
        using reference         = _STD pair<_STD iter_const_reference_t<_Key_iterator_t>, _STD iter_reference_t<_Mapped_iterator_t>>;

        reference operator*() const {
            return reference {*_Key_it, *_Mapped_it};
        }

        pointer operator->() const {
            return pointer {*_Key_it, *_Mapped_it};
        }

        type& operator++() {
            ++_Key_it;
            ++_Mapped_it;
            return *this;
        }

        type operator++(int) {
            type _Tmp = *this;
            ++*this;
            return _Tmp;
        }

        bool operator==(const type& _Right) const {
            return _Key_it == _Right._Key_it;
        }

        auto operator<=>(const type& _Right) const {
            return _Key_it <=> _Right._Key_it;
        }

        type& operator--() {
            --_Key_it;
            --_Mapped_it;
            return *this;
        }

        type operator--(int) {
            type _Tmp = *this;
            --*this;
            return _Tmp;
        }

        type& operator+=(difference_type _Off) {
            _Key_it += _Off;
            _Mapped_it += _Off;
            return *this;
        }

        type& operator-=(difference_type _Off) {
            _Key_it -= _Off;
            _Mapped_it -= _Off;
            return *this;
        }

        type operator+(difference_type _Off) const {
            type _Tmp = *this;
            return _Tmp += _Off;
        }

        type operator-(difference_type _Off) const {
            type _Tmp = *this;
            return _Tmp -= _Off;
        }

        reference operator[](difference_type _Off) const {
            return *(*this + _Off);
        }

        difference_type operator-(const type& _Right) const {
            return _Key_it - _Right._Key_it;
        }

        friend type operator+(difference_type _Off, const type& _Right);

        template <bool _Val = _IsConst, _STD enable_if_t<!_Val, int> = 0>
        operator typename _Flat_map_iterator_Impl<_KeyContainer, _MappedContainer, true>::type () const {
            return typename _Flat_map_iterator_Impl<_KeyContainer, _MappedContainer, true>::type {_Key_it, _Mapped_it};
        }

    private:
        _Key_iterator_t _Key_it;
        _Mapped_iterator_t _Mapped_it;
    };

    static_assert(_STD swappable<type>);
};

template <class _KeyContainer, class _MappedContainer, bool _IsConst>
_EXPORT_STD typename _Flat_map_iterator_Impl<_KeyContainer, _MappedContainer, _IsConst>::type operator+(
    typename _Flat_map_iterator_Impl<_KeyContainer, _MappedContainer, _IsConst>::type::difference_type _Off,
    const typename _Flat_map_iterator_Impl<_KeyContainer, _MappedContainer, _IsConst>::type& _Right) {
    return _Right + _Off;
}

_EXPORT_STD
template <class Key, class T, class Compare, class KeyContainer, class MappedContainer>
    requires same_as<Key, typename KeyContainer::value_type> && same_as<T, typename MappedContainer::value_type>
class flat_map {
public:
    using key_type               = Key;
    using mapped_type            = T;
    using value_type             = pair<key_type, mapped_type>;
    using key_compare            = Compare;
    using reference              = pair<const key_type&, mapped_type&>;
    using const_reference        = pair<const key_type&, const mapped_type&>;
    using size_type              = size_t;
    using difference_type        = ptrdiff_t;
    using key_container_type     = KeyContainer;
    using mapped_container_type  = MappedContainer;
    using iterator               = typename _STD _Flat_map_iterator_Impl<key_container_type, mapped_container_type, false>::type;
    using const_iterator         = typename _STD _Flat_map_iterator_Impl<key_container_type, mapped_container_type, true>::type;
    using reverse_iterator       = _STD reverse_iterator<iterator>;
    using const_reverse_iterator = _STD reverse_iterator<const_iterator>;

    static_assert(_STD random_access_iterator<iterator>);
    static_assert(_STD convertible_to<iterator, const_iterator>);

    using value_compare = typename _STD _Flat_value_compare<key_type, mapped_type, key_compare>::value_compare;
    using containers    = typename _STD _Flat_Container<key_container_type, mapped_container_type>::container;

private:
    template <class T> requires same_as<remove_cvref_t<T>, flat_map>
    using _Maybe_const_iterator_t = _STD conditional_t<_STD is_const_v<_STD remove_reference_t<T>>, const_iterator, iterator>;

public:
    // [flat.map.cons] Constructors
    explicit flat_map(const key_compare& _Comp) : _Key_compare(_Comp), _Data() {}
    flat_map() : flat_map(key_compare()) {}

    template <_Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    explicit flat_map(const Allocator& _Alloc) : flat_map(key_compare(), _Alloc) {}

    template <_Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    explicit flat_map(const key_compare& _Comp, const Allocator& _Alloc)
        : _Key_compare(_Comp), _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc),
                                   .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc)} {}

    flat_map(key_container_type _Key_cont, mapped_container_type _Mapped_cont)
        : flat_map(sorted_unique_t(), _Key_cont, _Mapped_cont) {
        _SortAndDedup();
    }

    template <_Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    flat_map(const key_container_type& _Key_cont, const mapped_container_type& _Mapped_cont, const Allocator& _Alloc)
        : flat_map(sorted_unique_t(), _Key_cont, _Mapped_cont, _Alloc) {
        _SortAndDedup();
    }

    flat_map(sorted_unique_t _Sorted_unique, key_container_type _Key_cont, mapped_container_type _Mapped_cont)
        : _Key_compare(key_compare()), _Data{.keys = _STD move(_Key_cont), .values = _STD move(_Mapped_cont)} {}

    template <_Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    flat_map(sorted_unique_t _Sorted_unique, const key_container_type& _Key_cont,
        const mapped_container_type& _Mapped_cont, const Allocator& _Alloc)
        : _Key_compare(key_compare()),
          _Data{.keys = _STD make_obj_using_allocator<key_container_type>(_Alloc, _Key_cont),
              .values = _STD make_obj_using_allocator<mapped_container_type>(_Alloc, _Mapped_cont)} {}

    template <class _InputIterator> requires _Is_iterator_v<_InputIterator>
    flat_map(_InputIterator _First, _InputIterator _Last, const key_compare& _Comp = key_compare()) : flat_map(_Comp) {
        insert(_First, _Last);
    }

    template <class _InputIterator,
        _Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
        requires _Is_iterator_v<_InputIterator>
    flat_map(_InputIterator _First, _InputIterator _Last, const key_compare& _Comp, const Allocator& _Alloc)
        : flat_map(_Comp, _Alloc) {
        insert(_First, _Last);
    }

    template <_Container_compatible_range<value_type> R>
    flat_map(_STD from_range_t _From_range, R&& _Range)
        : flat_map(_From_range, _STD forward<R>(_Range), key_compare()) {}

    template <_Container_compatible_range<value_type> R,
        _Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    flat_map(_STD from_range_t _From_range, R&& _Range, const Allocator& _Alloc)
        : flat_map(_From_range, _STD forward<R>(_Range), key_compare(), _Alloc) {}

    template <_Container_compatible_range<value_type> R>
    flat_map(_STD from_range_t _From_range, R&& _Range, const key_compare& _Comp) : flat_map(_Comp) {
        insert_range(_STD forward<R>(_Range));
    }

    template <_Container_compatible_range<value_type> R,
        _Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    flat_map(_STD from_range_t _From_range, R&& _Range, const key_compare& _Comp, const Allocator& _Alloc)
        : flat_map(_Comp, _Alloc) {
        insert_range(_STD forward<R>(_Range));
    }

    template <class _InputIterator> requires _Is_iterator_v<_InputIterator>
    flat_map(sorted_unique_t _S, _InputIterator _First, _InputIterator _Last, const key_compare& _Comp = key_compare())
        : flat_map(_Comp) {
        insert(_S, _First, _Last);
    }

    template <class _InputIterator,
        _Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
        requires _Is_iterator_v<_InputIterator>
    flat_map(sorted_unique_t _S, _InputIterator _First, _InputIterator _Last, const key_compare& _Comp,
        const Allocator& _Alloc)
        : flat_map(_Comp, _Alloc) {
        insert(_S, _First, _Last);
    }

    template <class _InputIterator,
        _Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
        requires _Is_iterator_v<_InputIterator>
    flat_map(sorted_unique_t _S, _InputIterator _First, _InputIterator _Last, const Allocator& _Alloc)
        : flat_map(_S, _First, _Last, key_compare(), _Alloc) {}

    flat_map(initializer_list<value_type> _I, const key_compare& _Comp = key_compare())
        : flat_map(_I.begin(), _I.end(), _Comp) {}

    template <_Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    flat_map(initializer_list<value_type> _I, const key_compare& _Comp, const Allocator& _Alloc)
        : flat_map(_I.begin(), _I.end(), _Comp, _Alloc) {}

    template <_Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    flat_map(initializer_list<value_type> _I, const Allocator& _Alloc) : flat_map(_I, key_compare(), _Alloc) {}

    flat_map(sorted_unique_t _S, initializer_list<value_type> _I, const key_compare& _Comp = key_compare())
        : flat_map(_S, _I.begin(), _I.end(), _Comp) {}

    template <_Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    flat_map(sorted_unique_t _S, initializer_list<value_type> _I, const key_compare& _Comp, const Allocator& _Alloc)
        : flat_map(_S, _I.begin(), _I.end(), _Comp, _Alloc) {}

    template <_Valid_Allocator_for_flat_map<key_container_type, mapped_container_type> Allocator>
    flat_map(sorted_unique_t _S, initializer_list<value_type> _I, const Allocator& _Alloc)
        : flat_map(_S, _I, key_compare(), _Alloc) {}

    flat_map& operator=(initializer_list<value_type> _I) {
        clear();
        insert(_I.begin(), _I.end());
        return *this;
    }

    // [container.reqmts] iterators
    _NODISCARD iterator begin() noexcept {
        return iterator { _Data.keys.cbegin(), _Data.values.begin() };
    }

    _NODISCARD const_iterator begin() const noexcept {
        return const_iterator { _Data.keys.cbegin(), _Data.values.begin() };
    }

    _NODISCARD iterator end() noexcept {
        return iterator { _Data.keys.cend(), _Data.values.end() };
    }

    _NODISCARD const_iterator end() const noexcept {
        return const_iterator { _Data.keys.cend(), _Data.values.end() };
    }

    _NODISCARD reverse_iterator rbegin() noexcept {
        return _STD make_reverse_iterator(end());
    }

    _NODISCARD const_reverse_iterator rbegin() const noexcept {
        return _STD make_reverse_iterator(end());
    }

    _NODISCARD reverse_iterator rend() noexcept {
        return _STD make_reverse_iterator(begin());
    }

    _NODISCARD const_reverse_iterator rend() const noexcept {
        return _STD make_reverse_iterator(begin());
    }

    _NODISCARD const_iterator cbegin() const noexcept {
        return const_iterator {_Data.keys.cbegin(), _Data.values.cbegin()};
    }

    _NODISCARD const_iterator cend() const noexcept {
        return const_iterator {_Data.keys.cend(), _Data.values.cend()};
    }

    _NODISCARD const_reverse_iterator crbegin() const noexcept {
        return _STD make_reverse_iterator(cend());
    }

    _NODISCARD const_reverse_iterator crend() const noexcept {
        return _STD make_reverse_iterator(cbegin());
    }

    // [container.reqmts] clear
    void clear() noexcept {
        _Data.keys.clear();
        _Data.values.clear();
    }

    // [flat.map.capacity] Capacity
    _NODISCARD_EMPTY_MEMBER bool empty() const noexcept {
        return _Data.keys.empty();
    }

    _NODISCARD size_type size() const noexcept {
        return _Data.keys.size();
    }

    _NODISCARD size_type max_size() const noexcept {
        return _STD min(_Data.keys.max_size(), _Data.values.max_size());
    }

    // [flat.map.access] Access
    _NODISCARD mapped_type& operator[](const key_type& _Key); // TODO: implement
    _NODISCARD mapped_type& operator[](key_type&& _Key); // TODO: implement
    template <class _C>
    _NODISCARD mapped_type& operator[](_C&& _Key)
        requires _Compare_is_transparent<key_compare>; // TODO: implement

    _NODISCARD mapped_type& at(const key_type& _Key); // TODO: implement
    _NODISCARD const mapped_type& at(const key_type& _Key) const; // TODO: implement
    template <class _C>
    _NODISCARD mapped_type& at(const _C& _Key)
        requires _Compare_is_transparent<key_compare>; // TODO: implement
    template <class _C>
    _NODISCARD const mapped_type& at(const _C& _Key) const
        requires _Compare_is_transparent<key_compare>; // TODO: implement

    // [flat.map.modifiers] Modifiers
    template <class... _Args_t>
    _STD pair<iterator, bool> emplace(_Args_t&&... _Args) requires _STD is_constructible_v<value_type, _Args_t...> {
        value_type _Val(_STD forward<_Args_t>(_Args)...);
        auto _Key_It = _STD lower_bound(_Data.keys.begin(), _Data.keys.end(), _Val.first, _Key_compare);
        iterator _It = begin() + _STD distance(_Data.keys.begin(), _Key_It);

        if(_It != end() && _Key_equal(*(_It._Key_it), _Val.first)) {
            // Already exists
            return _STD make_pair(_It, false);
        }
        else{
            // Need to insert
            auto _Index = _STD distance(begin(), _It);
            _Insert_exact(_It, _STD move(_Val));
            // Note: Consider _It invalidated by the insert operation
            return _STD make_pair(begin() + _Index, true);
        }
    }

    template <class... _Args_t>
    iterator emplace_hint(const_iterator _Position, _Args_t&&... _Args) requires _STD is_constructible_v<value_type, _Args_t...> {
        value_type _Val(_STD forward<_Args_t>(_Args)...);

        const const_iterator _Begin = cbegin();
        const const_iterator _End = cend();

        // Adjust _Position
        if(_Position == _End || !_Key_compare(*(_Position._Key_it), _Val.first)) {
            // _Val should be inserted at or before _Position
            if(_Position == _Begin || !_Key_compare(_Val.first, *((_Position - 1)._Key_it))){
                // _Val should be inserted at or after _Position
                // The hint _Position is accurate
            }
            else{
                auto _Key_Position = _STD upper_bound(_Data.keys.cbegin(), _Position._Key_it, _Val.first, _Key_compare);
                auto _Distance = _STD distance(_Data.keys.cbegin(), _Key_Position);
                _Position = _Begin + _Distance;
            }
        }
        else{
            auto _Key_Position = _STD lower_bound(_Position._Key_it + 1, _Data.keys.cend(), _Val.first, _Key_compare);
            auto _Distance = _STD distance(_Data.keys.cbegin(), _Key_Position);
            _Position = _Begin + _Distance;
        }

        bool _Should_insert = false;
        if(_Position == _End){
            _Should_insert = true;
        }
        else if(_Key_equal(*(_Position._Key_it), _Val.first)){
            _Should_insert = false;
        }
        else{
            _Should_insert = true;
        }

        auto _Distance = _STD distance(_Begin, _Position);
        if(_Should_insert){
            _Insert_exact(_Position, _STD move(_Val));
        }
        // Consider _Position invalidated by the insert operation
        return begin() + _Distance;
    }

    template <class _V>
    _STD pair<iterator, bool> insert(_V&& _X) requires (same_as<_STD remove_cvref_t<_V&&>, value_type> || constructible_from<value_type, _V&&>) {
        return emplace(_STD forward<_V>(_X));
    }

    template <class _V>
    iterator insert(const_iterator _Position, _V&& _X) requires (same_as<_STD remove_cvref_t<_V&&>, value_type> || constructible_from<value_type, _V&&>) {
        return emplace_hint(_Position, _STD forward<_V>(_X));
    }

    // observers
    key_compare key_comp() const {
        return _Key_compare;
    }

    value_compare value_comp() const {
        return value_compare(_Key_compare);
    }

    const key_container_type& keys() const noexcept {
        return _Data.keys;
    }

    const mapped_container_type& values() const noexcept {
        return _Data.values;
    }

    // map operations
    iterator lower_bound(const key_type& _X) {
        auto _Key_it = _STD lower_bound(_Data.keys.begin(), _Data.keys.end(), _X, _Key_compare);
        auto _Dist = _STD distance(_Data.keys.begin(), _Key_it);
        auto _Val_it = _Data.values.begin() + _Dist;
        return iterator { _STD move(_Key_it), _STD move(_Val_it) };
    }

    const_iterator lower_bound(const key_type& _X) const {
        auto _Key_it = _STD lower_bound(_Data.keys.cbegin(), _Data.keys.cend(), _X, _Key_compare);
        auto _Dist = _STD distance(_Data.keys.cbegin(), _Key_it);
        auto _Val_it = _Data.values.cbegin() + _Dist;
        return const_iterator { _STD move(_Key_it), _STD move(_Val_it) };
    }

private:
    key_compare _Key_compare;
    containers _Data;

    bool _Key_equal(const Key& _X, const Key& _Y) const {
        return !_Key_compare(_X, _Y) && !_Key_compare(_Y, _X);
    }

    void _SortAndDedup() {
        _Clear_flat_map_scope_guard _Guard { this };
        auto _Zip_view = _RANGES views::zip(_Data.keys, _Data.values);
        _RANGES sort(_Zip_view, value_compare(_Key_compare));

        auto _Subrange        = _RANGES unique(_Zip_view, [this](const_reference _X, const_reference _Y) { return this->_Key_equal(_X.first, _Y.first); });
        auto _Remaining_count = _STD distance(_Zip_view.begin(), _Subrange.begin());

        _Data.keys.erase(_Data.keys.begin() + _Remaining_count, _Data.keys.end());
        _Data.values.erase(_Data.values.begin() + _Remaining_count, _Data.values.end());
        _Guard._Clearable = nullptr;
    }

    void _Insert_exact(const_iterator _Position, value_type&& _Val){
        _Clear_flat_map_scope_guard _Guard { this };
        _Data.keys.insert(_Position._Key_it, _STD move(_Val.first));
        _Data.values.insert(_Position._Mapped_it, _STD move(_Val.second));
        _Guard._Clearable = nullptr;
    }
};

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _FLAT_MAP_
