// stacktrace standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _STACKSTRACE_
#define _STACKSTRACE_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR

#if !_HAS_CXX23
#pragma message("The contents of <stacktrace> are available only with C++23 or later.")
#else // ^^^ !_HAS_CXX23 / _HAS_CXX23 vvv

#include <cstdint>
#include <string>
#include <type_traits>
#include <vector>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

using _Stacktrace_string_fill_callback = size_t (*)(char*, size_t, void* _Context);

using _Stacktrace_string_fill = size_t (*)(size_t, void* _String, void* _Context, _Stacktrace_string_fill_callback);

inline size_t _Stacktrace_string_fill_impl(
    const size_t _Size, void* const _String, void* const _Context, const _Stacktrace_string_fill_callback _Callback) {
    if (_Callback) {
        struct _Stacktrace_string_fill_op {
            size_t operator()(char* _Data, size_t _Size) {
                return _Callback(_Data, _Size, _Context);
            }

            _Stacktrace_string_fill_callback _Callback;
            void* _Context;
        };

        static_cast<_STD string*>(_String)->resize_and_overwrite(
            _Size, _Stacktrace_string_fill_op{_Callback, _Context});
        return static_cast<_STD string*>(_String)->size();
    } else {
        return static_cast<_STD string*>(_String)->capacity();
    }
}

_EXTERN_C
unsigned short __stdcall __std_stacktrace_capture(unsigned long _FramesToSkip, unsigned long _FramesToCapture,
    void** _BackTrace, unsigned long* _BackTraceHash) noexcept;

// Some of these exports may throw (They would propagate bad_alloc potentially thrown from string::resize_and_overwrite)

// clang-format off
void __stdcall __std_stacktrace_address_to_string(
    const void* _Address, void* _Str, _Stacktrace_string_fill) noexcept(false);

void __stdcall __std_stacktrace_description(
    const void* _Address, void* _Str, _Stacktrace_string_fill) noexcept(false);

void __stdcall __std_stacktrace_source_file(
    const void* _Address, void* _Str, _Stacktrace_string_fill) noexcept(false);

[[nodiscard]] unsigned __stdcall __std_stacktrace_source_line(const void* _Address) noexcept;

void __stdcall __std_stacktrace_to_string(const void* _Addresses, size_t _Size, void* _Str,
    _Stacktrace_string_fill) noexcept(false);
// clang-format on
_END_EXTERN_C

_STD_BEGIN
class stacktrace_entry {
public:
    using native_handle_type = void*;

    constexpr stacktrace_entry() noexcept                        = default;
    constexpr stacktrace_entry(const stacktrace_entry&) noexcept = default;
    constexpr stacktrace_entry& operator=(const stacktrace_entry&) noexcept = default;

    ~stacktrace_entry() = default;

    [[nodiscard]] constexpr native_handle_type native_handle() const noexcept {
        return _Address;
    }

    [[nodiscard]] constexpr explicit operator bool() const noexcept {
        return _Address != nullptr;
    }

    [[nodiscard]] string description() const {
        string _Result;
        __std_stacktrace_description(_Address, &_Result, _Stacktrace_string_fill_impl);
        return _Result;
    }

    [[nodiscard]] string source_file() const {
        string _Result;
        __std_stacktrace_source_file(_Address, &_Result, _Stacktrace_string_fill_impl);
        return _Result;
    }

    [[nodiscard]] uint_least32_t source_line() const {
        return __std_stacktrace_source_line(_Address);
    }

    [[nodiscard]] friend constexpr bool operator==(const stacktrace_entry&, const stacktrace_entry&) noexcept = default;

    [[nodiscard]] friend constexpr strong_ordering operator<=>(
        const stacktrace_entry&, const stacktrace_entry&) noexcept = default;

private:
    void* _Address = nullptr;
};

template <class _Al>
class basic_stacktrace {
private:
    using _Frames_t = vector<stacktrace_entry, _Al>;

public:
    using value_type             = stacktrace_entry;
    using const_reference        = const value_type&;
    using reference              = value_type&;
    using const_iterator         = typename _Frames_t::const_iterator;
    using iterator               = const_iterator;
    using reverse_iterator       = _STD reverse_iterator<iterator>;
    using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
    using difference_type        = ptrdiff_t;
    using size_type              = size_t;
    using allocator_type         = _Al;

    [[nodiscard]] static basic_stacktrace current(const allocator_type& _Alloc = allocator_type()) noexcept {
        basic_stacktrace _Result(_Internal_t{}, _Max_frames, _Alloc);
        _Result._Frames.resize(__std_stacktrace_capture(0, static_cast<unsigned long>(_Max_frames),
            reinterpret_cast<void**>(_Result._Frames.data()), &_Result._Hash));
        return _Result;
    }

    [[nodiscard]] static basic_stacktrace current(
        size_type _Skip, const allocator_type& _Alloc = allocator_type()) noexcept {
        basic_stacktrace _Result(_Internal_t{}, _Max_frames, _Alloc);
        _Result._Frames.resize(__std_stacktrace_capture(static_cast<unsigned long>(_Skip),
            static_cast<unsigned long>(_Max_frames), reinterpret_cast<void**>(_Result._Frames.data()), &_Result._Hash));
        return _Result;
    }

    [[nodiscard]] static basic_stacktrace current(
        size_type _Skip, size_type _Max_depth, const allocator_type& _Alloc = allocator_type()) noexcept {
        basic_stacktrace _Result(_Internal_t{}, _Max_depth, _Alloc);
        _Result._Frames.resize(__std_stacktrace_capture(static_cast<unsigned long>(_Skip),
            static_cast<unsigned long>(_Max_depth), reinterpret_cast<void**>(_Result._Frames.data()), &_Result._Hash));
        return _Result;
    }

    basic_stacktrace() noexcept(is_nothrow_default_constructible_v<allocator_type>) = default;
    explicit basic_stacktrace(const allocator_type& _Alloc) noexcept : _Frames(_Alloc) {}

    basic_stacktrace(const basic_stacktrace&)     = default;
    basic_stacktrace(basic_stacktrace&&) noexcept = default;
    basic_stacktrace(const basic_stacktrace& _Other, const allocator_type& _Alloc)
        : _Frames(_Other._Frames, _Alloc), _Hash(_Other._Hash) {}

    basic_stacktrace(basic_stacktrace&& _Other, const allocator_type& _Alloc)
        : _Frames(_STD move(_Other._Frames), _Alloc), _Hash(_Other._Hash) {}

    basic_stacktrace& operator=(const basic_stacktrace&) = default;
    basic_stacktrace& operator=(basic_stacktrace&&) noexcept(_Noex_move) = default;

    ~basic_stacktrace() = default;

    [[nodiscard]] allocator_type get_allocator() const noexcept {
        return _Frames.get_allocator();
    }

    [[nodiscard]] const_iterator begin() const noexcept {
        return _Frames.cbegin();
    }

    [[nodiscard]] const_iterator end() const noexcept {
        return _Frames.cend();
    }

    [[nodiscard]] const_reverse_iterator rbegin() const noexcept {
        return _Frames.crbegin();
    }

    [[nodiscard]] const_reverse_iterator rend() const noexcept {
        return _Frames.crend();
    }

    [[nodiscard]] const_iterator cbegin() const noexcept {
        return _Frames.cbegin();
    }

    [[nodiscard]] const_iterator cend() const noexcept {
        return _Frames.cend();
    }

    [[nodiscard]] const_reverse_iterator crbegin() const noexcept {
        return _Frames.crbegin();
    }

    [[nodiscard]] const_reverse_iterator crend() const noexcept {
        return _Frames.crend();
    }

    [[nodiscard]] bool empty() const noexcept {
        return _Frames.empty();
    }

    [[nodiscard]] size_type size() const noexcept {
        return _Frames.size();
    }

    [[nodiscard]] size_type max_size() const noexcept {
        return _Frames.max_size();
    }

    [[nodiscard]] const_reference operator[](size_type _Sx) const noexcept /* strengthened */ {
        return _Frames[_Sx];
    }

    [[nodiscard]] const_reference at(size_type _Sx) const {
        return _Frames.at(_Sx);
    }

    template <class _Al2>
    [[nodiscard]] friend bool operator==(const basic_stacktrace& _Lhs, const basic_stacktrace<_Al2>& _Rhs) noexcept {
        return _Lhs._Hash == _Rhs._Hash && _Lhs._Frames == _Rhs._Frames;
    }

    template <class _Al2>
    [[nodiscard]] friend strong_ordering operator<=>(
        const basic_stacktrace& _Lhs, const basic_stacktrace<_Al2>& _Rhs) noexcept {
        const auto _Result = _Lhs._Frames.size() <=> _Rhs._Frames.size();
        if (_Result != strong_ordering::equal) {
            return _Result;
        }

        return _Lhs._Frames <=> _Rhs._Frames;
    }

    void swap(basic_stacktrace& _Other) noexcept(
        allocator_traits<_Al>::propagate_on_container_swap::value || allocator_traits<_Al>::is_always_equal::value) {
        _STD swap(_Frames, _Other._Frames);
        _STD swap(_Hash, _Other._Hash);
    }

    [[nodiscard]] unsigned long _Get_hash() const noexcept {
        return _Hash;
    }

    [[nodiscard]] const void* _Data() const noexcept {
        return _Frames.data();
    }

private:
    static constexpr size_t _Max_frames = 0xFFFF;

    static constexpr bool _Noex_move = allocator_traits<_Al>::propagate_on_container_move_assignment::value
                                    || allocator_traits<_Al>::is_always_equal::value;

    struct _Internal_t {};

    basic_stacktrace(_Internal_t, size_type _Max_depth, const allocator_type& _Alloc) : _Frames(_Max_depth, _Alloc) {}

    _Frames_t _Frames;
    unsigned long _Hash = 0;
};

using stacktrace = basic_stacktrace<allocator<stacktrace_entry>>;

template <class _Al>
void swap(basic_stacktrace<_Al>& _Ax, basic_stacktrace<_Al>& _Bx) noexcept(noexcept(_Ax.swap(_Bx))) {
    return _Ax.swap(_Bx);
}

[[nodiscard]] inline string to_string(const stacktrace_entry& _Fx) {
    string _Result;
    __std_stacktrace_address_to_string(_Fx.native_handle(), &_Result, _Stacktrace_string_fill_impl);
    return _Result;
}

template <class _Al>
[[nodiscard]] string to_string(const basic_stacktrace<_Al>& _St) {
    string _Result;
    __std_stacktrace_to_string(_St._Data(), _St.size(), &_Result, _Stacktrace_string_fill_impl);
    return _Result;
}

template <class charT, class traits>
basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>& _Os, const stacktrace_entry& _Fx) {
    return _Os << to_string(_Fx);
}

template <class charT, class traits, class _Al>
basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>& _Os, const basic_stacktrace<_Al>& _Fx) {
    return _Os << to_string(_Fx);
}

namespace pmr {
    using stacktrace = basic_stacktrace<polymorphic_allocator<stacktrace_entry>>;
}

template <>
struct hash<stacktrace_entry> {
    [[nodiscard]] size_t operator()(const stacktrace_entry& _Val) const noexcept {
        return _Hash_representation(_Val.native_handle());
    }
};

template <class _Al>
struct hash<basic_stacktrace<_Al>> {
    [[nodiscard]] size_t operator()(const basic_stacktrace<_Al>& _Val) const noexcept {
        return _Val._Get_hash();
    }
};
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // ^^^ _HAS_CXX23 ^^^

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _STACK_
