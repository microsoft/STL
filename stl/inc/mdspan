// mdspan standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _MDSPAN_
#define _MDSPAN_
#include <yvals.h>
#if _STL_COMPILER_PREPROCESSOR
#if !_HAS_CXX23 || !defined(__cpp_lib_concepts) // TRANSITION, GH-395
_EMIT_STL_WARNING(STL4038, "The contents of <mdspan> are available only with C++23 or later.");
#else // ^^^ not supported / supported language mode vvv
#include <array>
#include <limits>
#include <span>
#include <tuple>
#include <type_traits>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN

_EXPORT_STD template <class _IndexType, size_t... _Extents>
class extents {
public:
    using index_type = _IndexType;
    using size_type  = make_unsigned_t<index_type>;
    using rank_type  = size_t;

    static_assert(_Is_standard_integer<index_type>,
        "IndexType must be a signed or unsigned integer type (N4950 [mdspan.extents.overview]/1.1).");
    static_assert(((_Extents == dynamic_extent || _STD in_range<index_type>(_Extents)) && ...),
        "Each element of Extents must be either equal to dynamic_extent, or must be representable as a value of type "
        "IndexType (N4950 [mdspan.extents.overview]/1.2).");

    static constexpr rank_type _Rank         = sizeof...(_Extents);
    static constexpr rank_type _Rank_dynamic = (static_cast<rank_type>(_Extents == dynamic_extent) + ... + 0);
    static constexpr array<rank_type, _Rank> _Static_extents        = {_Extents...};
    static constexpr bool _Multidim_index_space_size_is_always_zero = ((_Extents == 0) || ...);

private:
    _NODISCARD static consteval auto _Make_dynamic_indices() noexcept {
        array<rank_type, _Rank + 1> _Result{};
        rank_type _Counter = 0;
        for (rank_type _Idx = 0; _Idx < _Rank; ++_Idx) {
            _Result[_Idx] = _Counter;
            if (_Static_extents[_Idx] == dynamic_extent) {
                ++_Counter;
            }
        }
        _Result[_Rank] = _Counter;
        return _Result;
    }

    static constexpr array<rank_type, _Rank + 1> _Dynamic_indices = _Make_dynamic_indices();

    _NODISCARD static consteval auto _Make_dynamic_indices_inv() noexcept {
        array<rank_type, _Rank> _Result{};
        for (rank_type _Idx = 0; _Idx < _Rank; ++_Idx) {
            for (rank_type _Idx_inv = 0; _Idx_inv < _Rank; ++_Idx_inv) {
                if (_Dynamic_indices[_Idx_inv + 1] == _Idx + 1) {
                    _Result[_Idx] = _Idx_inv;
                    break;
                }
            }
        }
        return _Result;
    }

    static constexpr array<rank_type, _Rank> _Dynamic_indices_inv = _Make_dynamic_indices_inv();

    struct _Construct_from_tuple {
        constexpr explicit _Construct_from_tuple() noexcept = default;
    };

    struct _Static_extents_only {
        constexpr explicit _Static_extents_only() noexcept = default;
    };

    conditional_t<_Rank_dynamic != 0, array<index_type, _Rank_dynamic>, _Static_extents_only> _Dynamic_extents{};

public:
    _NODISCARD static constexpr rank_type rank() noexcept {
        return _Rank;
    }

    _NODISCARD static constexpr rank_type rank_dynamic() noexcept {
        return _Rank_dynamic;
    }

    _NODISCARD static constexpr size_t static_extent(const rank_type _Idx) noexcept {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Idx < _Rank, "Index must be less than rank() (N4950 [mdspan.extents.obs]/1)");
#endif // _CONTAINER_DEBUG_LEVEL > 0
        return _Static_extents[_Idx];
    }

    _NODISCARD constexpr index_type extent(const rank_type _Idx) const noexcept {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Idx < _Rank, "Index must be less than rank() (N4950 [mdspan.extents.obs]/3)");
#endif // _CONTAINER_DEBUG_LEVEL > 0
        if constexpr (rank_dynamic() == 0) {
            return static_cast<index_type>(_Static_extents[_Idx]);
        } else if constexpr (rank_dynamic() == rank()) {
            return _Dynamic_extents[_Idx];
        } else {
            if (_Static_extents[_Idx] == dynamic_extent) {
                return _Dynamic_extents[_Dynamic_indices[_Idx]];
            } else {
                return static_cast<index_type>(_Static_extents[_Idx]);
            }
        }
    }

    constexpr extents() noexcept = default;

    template <class _OtherIndexType, size_t... _OtherExtents, size_t... _Indices>
        requires (sizeof...(_OtherExtents) == rank())
              && ((_OtherExtents == dynamic_extent || _Extents == dynamic_extent || _OtherExtents == _Extents) && ...)
    constexpr explicit extents(
        const extents<_OtherIndexType, _OtherExtents...>& _Other, index_sequence<_Indices...>) noexcept
        : _Dynamic_extents{static_cast<index_type>(_Other.extent(_Dynamic_indices_inv[_Indices]))...} {
#if _CONTAINER_DEBUG_LEVEL > 0
        if constexpr (rank() > 0) {
            for (rank_type _Idx = 0; _Idx < _Rank; ++_Idx) {
                if constexpr (rank() != rank_dynamic()) {
                    _STL_VERIFY(_Static_extents[_Idx] == dynamic_extent
                                    || _STD cmp_equal(_Static_extents[_Idx], _Other.extent(_Idx)),
                        "Value of other.extent(r) must be equal to extent(r) for each r for which extent(r) is a "
                        "static extent (N4950 [mdspan.extents.cons]/2.1)");
                }
                _STL_VERIFY(_STD in_range<index_type>(_Other.extent(_Idx)),
                    "Value of other.extent(r) must be representable as a value of type index_type for every rank index "
                    "r (N4950 [mdspan.extents.cons]/2.2)");
            }
        }
#endif // _CONTAINER_DEBUG_LEVEL > 0
    }

    template <class _OtherIndexType, size_t... _OtherExtents>
        requires (sizeof...(_OtherExtents) == rank())
              && ((_OtherExtents == dynamic_extent || _Extents == dynamic_extent || _OtherExtents == _Extents) && ...)
    constexpr explicit(((_Extents != dynamic_extent && _OtherExtents == dynamic_extent) || ...)
                       || (numeric_limits<index_type>::max)() < (numeric_limits<_OtherIndexType>::max)())
        extents(const extents<_OtherIndexType, _OtherExtents...>& _Other) noexcept
        : extents(_Other, make_index_sequence<rank_dynamic()>{}) {}

    template <class _ExtsTuple, size_t... _Indices>
        requires (tuple_size_v<_ExtsTuple> == rank_dynamic())
    constexpr explicit extents(_Construct_from_tuple, _ExtsTuple _Tpl, index_sequence<_Indices...>) noexcept
        : _Dynamic_extents{static_cast<index_type>(_STD move(_STD get<_Indices>(_Tpl)))...} {}

    template <class _ExtsTuple, size_t... _DynIndices>
        requires (tuple_size_v<_ExtsTuple> != rank_dynamic())
    constexpr explicit extents(_Construct_from_tuple, _ExtsTuple _Tpl, index_sequence<_DynIndices...>) noexcept
        : _Dynamic_extents{static_cast<index_type>(_STD move(_STD get<_Dynamic_indices_inv[_DynIndices]>(_Tpl)))...} {
#if _CONTAINER_DEBUG_LEVEL > 0
        [&]<size_t... _MixedIndices>(index_sequence<_MixedIndices...>) {
            _STL_VERIFY(((_Static_extents[_MixedIndices] == dynamic_extent
                             || _STD cmp_equal(_Static_extents[_MixedIndices],
                                 static_cast<index_type>(_STD move(_STD get<_MixedIndices>(_Tpl)))))
                            && ...),
                "Value of exts_arr[r] must be equal to extent(r) for each r for which extent(r) is a static extent "
                "(N4950 [mdspan.extents.cons]/7.1)");
        }(make_index_sequence<rank()>{});
#endif // _CONTAINER_DEBUG_LEVEL > 0
    }

    template <class... _OtherIndexTypes>
        requires (is_convertible_v<_OtherIndexTypes, index_type> && ...)
              && (is_nothrow_constructible_v<index_type, _OtherIndexTypes> && ...)
              && (sizeof...(_OtherIndexTypes) == rank_dynamic() || sizeof...(_OtherIndexTypes) == rank())
    constexpr explicit extents(_OtherIndexTypes... _Exts) noexcept
        : extents(_Construct_from_tuple{}, _STD tie(_Exts...), make_index_sequence<rank_dynamic()>{}) {
#if _CONTAINER_DEBUG_LEVEL > 0
        auto _Check_extent = []<class _Ty>(const _Ty& _Ext) {
            if constexpr (_Is_standard_integer<_Ty>) {
                return _Ext >= 0 && _STD in_range<index_type>(_Ext);
            } else if constexpr (integral<_Ty> && !same_as<_Ty, bool>) { // NB: character types
                const auto _Integer_ext = static_cast<long long>(_Ext);
                return _Integer_ext >= 0 && _STD in_range<index_type>(_Integer_ext);
            } else {
                return true; // NB: We cannot check preconditions
            }
        };
        _STL_VERIFY((_Check_extent(_Exts) && ...),
            "Either sizeof...(exts) must be equal to 0 or each element of exts must be nonnegative and must be "
            "representable as value of type index_type (N4950 [mdspan.extents.cons]/7.2)");
#endif // _CONTAINER_DEBUG_LEVEL > 0
    }

    template <class _OtherIndexType, size_t _Size, size_t... _Indices>
        requires is_convertible_v<const _OtherIndexType&, index_type>
              && is_nothrow_constructible_v<index_type, const _OtherIndexType&> && (_Size == rank_dynamic())
    constexpr explicit extents(span<_OtherIndexType, _Size> _Dynamic_exts, index_sequence<_Indices...>) noexcept
        : _Dynamic_extents{static_cast<index_type>(_STD as_const(_Dynamic_exts[_Indices]))...} {
#if _CONTAINER_DEBUG_LEVEL > 0
        if constexpr (_Is_standard_integer<_OtherIndexType> && _Size != 0) {
            _STL_VERIFY(((_Dynamic_exts[_Indices] >= 0 && _STD in_range<index_type>(_Dynamic_exts[_Indices])) && ...),
                "Either N must be zero or exts[r] must be nonnegative and must be representable as value of type "
                "index_type for every rank index r (N4950 [mdspan.extents.cons]/10.2)");
        }
#endif // _CONTAINER_DEBUG_LEVEL > 0
    }

    template <class _OtherIndexType, size_t _Size, size_t... _Indices>
        requires is_convertible_v<const _OtherIndexType&, index_type>
              && is_nothrow_constructible_v<index_type, const _OtherIndexType&> && (_Size != rank_dynamic())
    constexpr explicit extents(span<_OtherIndexType, _Size> _Mixed_exts, index_sequence<_Indices...>) noexcept
        : _Dynamic_extents{static_cast<index_type>(_STD as_const(_Mixed_exts[_Dynamic_indices_inv[_Indices]]))...} {
#if _CONTAINER_DEBUG_LEVEL > 0
        if constexpr (_Is_standard_integer<_OtherIndexType>) {
            for (rank_type _Idx = 0; _Idx < _Rank; ++_Idx) {
                _STL_VERIFY(
                    _Static_extents[_Idx] == dynamic_extent || _STD cmp_equal(_Static_extents[_Idx], _Mixed_exts[_Idx]),
                    "Value of exts[r] must be equal to extent(r) for each r for which extent(r) is a static extent "
                    "(N4950 [mdspan.extents.cons]/10.1)");
                _STL_VERIFY(_Mixed_exts[_Idx] >= 0 && _STD in_range<index_type>(_Mixed_exts[_Idx]),
                    "Either N must be zero or exts[r] must be nonnegative and must be representable as value of type "
                    "index_type for every rank index r (N4950 [mdspan.extents.cons]/10.2)");
            }
        }
#endif // _CONTAINER_DEBUG_LEVEL > 0
    }

    template <class _OtherIndexType, size_t _Size>
        requires is_convertible_v<const _OtherIndexType&, index_type>
              && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
              && (_Size == rank_dynamic() || _Size == rank())
    constexpr explicit(_Size != rank_dynamic()) extents(span<_OtherIndexType, _Size> _Exts) noexcept
        : extents(_Exts, make_index_sequence<rank_dynamic()>{}) {}

    template <class _OtherIndexType, size_t _Size>
        requires is_convertible_v<const _OtherIndexType&, index_type>
              && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
              && (_Size == rank_dynamic() || _Size == rank())
    constexpr explicit(_Size != rank_dynamic()) extents(const array<_OtherIndexType, _Size>& _Exts) noexcept
        : extents(span{_Exts}, make_index_sequence<rank_dynamic()>{}) {}

    template <class _OtherIndexType, size_t... _OtherExtents>
    _NODISCARD_FRIEND constexpr bool operator==(
        const extents& _Left, const extents<_OtherIndexType, _OtherExtents...>& _Right) noexcept {
        if constexpr (rank() != sizeof...(_OtherExtents)) {
            return false;
        } else {
            for (rank_type _Idx = 0; _Idx < _Rank; ++_Idx) {
                if (_STD cmp_not_equal(_Left.extent(_Idx), _Right.extent(_Idx))) {
                    return false;
                }
            }
            return true;
        }
    }

    _NODISCARD static consteval bool _Is_static_multidim_index_space_size_representable() noexcept {
        // Pre: rank_dynamic() == 0
        if constexpr (_Multidim_index_space_size_is_always_zero) {
            return true;
        } else {
            index_type _Result{1};
#pragma warning(push)
#pragma warning(disable : 6287) // TRANSITION, DevCom-???
            const bool _Overflow = (_Mul_overflow(static_cast<index_type>(_Extents), _Result, _Result) || ...);
#pragma warning(pop)
            return !_Overflow;
        }
    }

    _NODISCARD constexpr bool _Is_dynamic_multidim_index_space_size_representable() const noexcept {
        // Pre: rank_dynamic() != 0
        if constexpr (_Multidim_index_space_size_is_always_zero) {
            return true;
        } else {
            index_type _Result{1};
            bool _Overflow = false;
            for (rank_type _Idx = 0; _Idx < _Rank; ++_Idx) {
                const index_type _Ext = extent(_Idx);
                if (_Ext == 0) {
                    return true;
                }

                if (!_Overflow) {
                    _Overflow = _Mul_overflow(extent(_Idx), _Result, _Result);
                }
            }

            return !_Overflow;
        }
    }

    template <class... _IndexTypes, size_t... _Seq>
    _NODISCARD constexpr bool _Contains_multidimensional_index(
        index_sequence<_Seq...>, _IndexTypes... _Indices) const noexcept {
        _STL_INTERNAL_STATIC_ASSERT((same_as<_IndexTypes, index_type> && ...));
        if constexpr (unsigned_integral<index_type>) {
            return ((_Indices < extent(_Seq)) && ...);
        } else {
            return ((0 <= _Indices && _Indices < extent(_Seq)) && ...);
        }
    }
};

template <class>
inline constexpr size_t _Repeat_dynamic_extent = dynamic_extent;

template <class... _Integrals>
    requires (is_convertible_v<_Integrals, size_t> && ...)
extents(_Integrals...) -> extents<size_t, _Repeat_dynamic_extent<_Integrals>...>;

template <class _IndexType, class _Indices>
struct _Dextents_impl;

template <class _IndexType, size_t... _Indices>
struct _Dextents_impl<_IndexType, index_sequence<_Indices...>> {
    using type = extents<_IndexType, ((void) _Indices, dynamic_extent)...>;
};

_EXPORT_STD template <class _IndexType, size_t _Rank>
using dextents = _Dextents_impl<_IndexType, make_index_sequence<_Rank>>::type;

template <class _Ty>
inline constexpr bool _Is_extents = false;

template <class _IndexType, size_t... _Args>
inline constexpr bool _Is_extents<extents<_IndexType, _Args...>> = true;

template <class _Extents>
    requires _Is_extents<_Extents>
class _Fwd_prod_of_extents {
public:
    _NODISCARD static constexpr _Extents::index_type _Calculate(const _Extents& _Exts, const size_t _Idx) noexcept {
        _STL_INTERNAL_CHECK(_Idx <= _Extents::_Rank);
        if constexpr (_Extents::rank() == 0) {
            return 1;
        } else {
            typename _Extents::index_type _Result = 1;
            for (size_t _Dim = 0; _Dim < _Idx; ++_Dim) {
                _Result *= _Exts.extent(_Dim);
            }
            return _Result;
        }
    }
};

template <class _IndexType, size_t... _Extents>
    requires (sizeof...(_Extents) > 0) && ((_Extents != dynamic_extent) && ...)
class _Fwd_prod_of_extents<extents<_IndexType, _Extents...>> {
private:
    using _Ty = extents<_IndexType, _Extents...>;

    _NODISCARD static consteval auto _Make_prods() noexcept {
        array<typename _Ty::index_type, _Ty::rank() + 1> _Result;
        _Result.front() = 1;
        for (size_t _Idx = 1; _Idx < _Ty::_Rank + 1; ++_Idx) {
            _Result[_Idx] = static_cast<_Ty::index_type>(_Result[_Idx - 1] * _Ty::_Static_extents[_Idx - 1]);
        }
        return _Result;
    }

    static constexpr array<typename _Ty::index_type, _Ty::rank() + 1> _Cache = _Make_prods();

public:
    _NODISCARD static constexpr _Ty::index_type _Calculate(const _Ty&, const size_t _Idx) noexcept {
        _STL_INTERNAL_CHECK(_Idx <= _Ty::_Rank);
        return _Cache[_Idx];
    }
};

template <class _Extents>
    requires _Is_extents<_Extents> && (_Extents::rank() > 0)
class _Rev_prod_of_extents {
public:
    _NODISCARD static constexpr _Extents::index_type _Calculate(const _Extents& _Exts, const size_t _Idx) noexcept {
        _STL_INTERNAL_CHECK(_Idx < _Extents::_Rank);
        typename _Extents::index_type _Result = 1;
        for (size_t _Dim = _Idx + 1; _Dim < _Extents::_Rank; ++_Dim) {
            _Result *= _Exts.extent(_Dim);
        }
        return _Result;
    }
};

template <class _IndexType, size_t... _Extents>
    requires ((_Extents != dynamic_extent) && ...)
class _Rev_prod_of_extents<extents<_IndexType, _Extents...>> {
private:
    using _Ty = extents<_IndexType, _Extents...>;

    _NODISCARD static consteval auto _Make_prods() noexcept {
        array<typename _Ty::index_type, _Ty::rank()> _Result;
        _Result.back() = 1;
        for (size_t _Idx = _Ty::_Rank; _Idx-- > 1;) {
            _Result[_Idx - 1] = static_cast<_Ty::index_type>(_Result[_Idx] * _Ty::_Static_extents[_Idx]);
        }
        return _Result;
    }

    static constexpr array<typename _Ty::index_type, _Ty::rank()> _Cache = _Make_prods();

public:
    _NODISCARD static constexpr _Ty::index_type _Calculate(const _Ty&, const size_t _Idx) noexcept {
        _STL_INTERNAL_CHECK(_Idx < _Ty::_Rank);
        return _Cache[_Idx];
    }
};

template <class _Layout, class _Mapping>
inline constexpr bool _Is_mapping_of =
    is_same_v<typename _Layout::template mapping<typename _Mapping::extents_type>, _Mapping>;

_EXPORT_STD struct layout_left {
    template <class _Extents>
    class mapping;
};

_EXPORT_STD struct layout_right {
    template <class _Extents>
    class mapping;
};

_EXPORT_STD struct layout_stride {
    template <class _Extents>
    class mapping;
};

template <class _Extents>
class layout_left::mapping {
public:
    using extents_type = _Extents;
    using index_type   = extents_type::index_type;
    using size_type    = extents_type::size_type;
    using rank_type    = extents_type::rank_type;
    using layout_type  = layout_left;

    static_assert(_Is_extents<extents_type>,
        "Extents must be a specialization of std::extents (N4950 [mdspan.layout.left.overview]/2).");
    static_assert(
        extents_type::rank_dynamic() != 0 || extents_type::_Is_static_multidim_index_space_size_representable(),
        "If Extents::rank_dynamic() == 0 is true, then the size of the multidimensional index space Extents() must be "
        "representable as a value of type typename Extents::index_type (N4950 [mdspan.layout.left.overview]/4).");

    constexpr mapping() noexcept               = default;
    constexpr mapping(const mapping&) noexcept = default;

    constexpr mapping(const extents_type& _Exts_) noexcept : _Exts(_Exts_) {
#if _CONTAINER_DEBUG_LEVEL > 0
        if constexpr (extents_type::rank_dynamic() != 0) {
            _STL_VERIFY(_Exts_._Is_dynamic_multidim_index_space_size_representable(),
                "The size of the multidimensional index space e must be representable as a value of type index_type "
                "(N4950 [mdspan.layout.left.cons]/1).");
        }
#endif // _CONTAINER_DEBUG_LEVEL > 0
    }

    template <class _OtherExtents>
        requires is_constructible_v<extents_type, _OtherExtents>
    constexpr explicit(!is_convertible_v<_OtherExtents, extents_type>)
        mapping(const mapping<_OtherExtents>& _Other) noexcept
        : _Exts(_Other.extents()) {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_STD in_range<index_type>(_Other.required_span_size()),
            "Value of other.required_span_size() must be representable as a value of type index_type (N4950 "
            "[mdspan.layout.left.cons]/4).");
#endif // _CONTAINER_DEBUG_LEVEL > 0
    }

    template <class _OtherExtents>
        requires (extents_type::rank() <= 1) && is_constructible_v<extents_type, _OtherExtents>
    constexpr explicit(!is_convertible_v<_OtherExtents, extents_type>)
        mapping(const layout_right::mapping<_OtherExtents>& _Other) noexcept
        : _Exts(_Other.extents()) {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_STD in_range<index_type>(_Other.required_span_size()),
            "Value of other.required_span_size() must be representable as a value of type index_type (N4950 "
            "[mdspan.layout.left.cons]/7).");
#endif // _CONTAINER_DEBUG_LEVEL > 0
    }

    template <class _OtherExtents>
        requires is_constructible_v<extents_type, _OtherExtents>
    constexpr explicit(extents_type::rank() > 0) mapping(const layout_stride::template mapping<_OtherExtents>& _Other)
        : _Exts(_Other.extents()) {
#if _CONTAINER_DEBUG_LEVEL > 0
        if constexpr (extents_type::rank() > 0) {
            index_type _Prod = 1;
            for (size_t _Idx = 0; _Idx < extents_type::_Rank; ++_Idx) {
                _STL_VERIFY(_Other.stride(_Idx) == _Prod,
                    "For all r in the range [0, extents_type::rank()), other.stride(r) must be equal to "
                    "extents().fwd-prod-of-extents(r) (N4950 [mdspan.layout.left.cons]/10.1).");
                _Prod = static_cast<index_type>(_Prod * _Exts.extent(_Idx));
            }
            _STL_VERIFY(_STD in_range<index_type>(_Other.required_span_size()),
                "Value of other.required_span_size() must be representable as a value of type index_type (N4950 "
                "[mdspan.layout.left.cons]/10.2).");
        }
#endif // _CONTAINER_DEBUG_LEVEL > 0
    }

    constexpr mapping& operator=(const mapping&) noexcept = default;

    _NODISCARD constexpr const extents_type& extents() const noexcept {
        return _Exts;
    }

    _NODISCARD constexpr index_type required_span_size() const noexcept {
        return _Fwd_prod_of_extents<extents_type>::_Calculate(_Exts, extents_type::_Rank);
    }

    template <class... _IndexTypes>
        requires (sizeof...(_IndexTypes) == extents_type::rank()) && (is_convertible_v<_IndexTypes, index_type> && ...)
              && (is_nothrow_constructible_v<index_type, _IndexTypes> && ...)
    _NODISCARD constexpr index_type operator()(_IndexTypes... _Indices) const noexcept {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Exts._Contains_multidimensional_index(
                        make_index_sequence<extents_type::rank()>{}, static_cast<index_type>(_Indices)...),
            "Value of extents_type::index-cast(i) must be a multidimensional index in extents_ (N4950 "
            "[mdspan.layout.left.obs]/3).");
#endif // _CONTAINER_DEBUG_LEVEL > 0
        return _Index_impl(make_index_sequence<extents_type::rank()>{}, static_cast<index_type>(_Indices)...);
    }

    _NODISCARD static constexpr bool is_always_unique() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_always_exhaustive() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_always_strided() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_unique() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_exhaustive() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_strided() noexcept {
        return true;
    }

    _NODISCARD constexpr index_type stride(const rank_type _Idx) const noexcept
        requires (extents_type::rank() > 0)
    {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Idx < extents_type::_Rank,
            "Value of i must be less than extents_type::rank() (N4950 [mdspan.layout.left.obs]/6).");
#endif // _CONTAINER_DEBUG_LEVEL > 0
        return _Fwd_prod_of_extents<extents_type>::_Calculate(_Exts, _Idx);
    }

    template <class _OtherExtents>
        requires (extents_type::rank() == _OtherExtents::rank())
    _NODISCARD_FRIEND constexpr bool operator==(const mapping& _Left, const mapping<_OtherExtents>& _Right) noexcept {
        return _Left._Exts == _Right.extents();
    }

private:
    extents_type _Exts{};

    template <class... _IndexTypes, size_t... _Seq>
    _NODISCARD constexpr index_type _Index_impl(index_sequence<_Seq...>, _IndexTypes... _Indices) const noexcept {
        _STL_INTERNAL_STATIC_ASSERT((same_as<_IndexTypes, index_type> && ...));
        index_type _Stride = 1;
        index_type _Result = 0;
        (((_Result += _Indices * _Stride), (_Stride *= _Exts.extent(_Seq))), ...);
        return _Result;
    }
};

template <class _Extents>
class layout_right::mapping {
public:
    using extents_type = _Extents;
    using index_type   = extents_type::index_type;
    using size_type    = extents_type::size_type;
    using rank_type    = extents_type::rank_type;
    using layout_type  = layout_right;

    static_assert(_Is_extents<extents_type>,
        "Extents must be a specialization of std::extents (N4950 [mdspan.layout.right.overview]/2).");
    static_assert(
        extents_type::rank_dynamic() != 0 || extents_type::_Is_static_multidim_index_space_size_representable(),
        "If Extents::rank_dynamic() == 0 is true, then the size of the multidimensional index space Extents() must be "
        "representable as a value of type typename Extents::index_type (N4950 [mdspan.layout.right.overview]/4).");

    constexpr mapping() noexcept               = default;
    constexpr mapping(const mapping&) noexcept = default;

    constexpr mapping(const extents_type& _Exts_) noexcept : _Exts(_Exts_) {
#if _CONTAINER_DEBUG_LEVEL > 0
        if constexpr (extents_type::rank_dynamic() != 0) {
            _STL_VERIFY(_Exts_._Is_dynamic_multidim_index_space_size_representable(),
                "The size of the multidimensional index space e must be representable as a value of type index_type "
                "(N4950 [mdspan.layout.right.cons]/1).");
        }
#endif // _CONTAINER_DEBUG_LEVEL > 0
    }

    template <class _OtherExtents>
        requires is_constructible_v<extents_type, _OtherExtents>
    constexpr explicit(!is_convertible_v<_OtherExtents, extents_type>)
        mapping(const mapping<_OtherExtents>& _Other) noexcept
        : _Exts(_Other.extents()) {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_STD in_range<index_type>(_Other.required_span_size()),
            "Value of other.required_span_size() must be representable as a value of type index_type (N4950 "
            "[mdspan.layout.right.cons]/4).");
#endif // _CONTAINER_DEBUG_LEVEL > 0
    }

    template <class _OtherExtents>
        requires (extents_type::rank() <= 1) && is_constructible_v<extents_type, _OtherExtents>
    constexpr explicit(!is_convertible_v<_OtherExtents, extents_type>)
        mapping(const layout_left::mapping<_OtherExtents>& _Other) noexcept
        : _Exts(_Other.extents()) {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_STD in_range<index_type>(_Other.required_span_size()),
            "Value of other.required_span_size() must be representable as a value of type index_type (N4950 "
            "[mdspan.layout.right.cons]/7).");
#endif // _CONTAINER_DEBUG_LEVEL > 0
    }

    template <class _OtherExtents>
        requires is_constructible_v<extents_type, _OtherExtents>
    constexpr explicit(extents_type::rank() > 0)
        mapping(const layout_stride::template mapping<_OtherExtents>& _Other) noexcept
        : _Exts(_Other.extents()) {
#if _CONTAINER_DEBUG_LEVEL > 0
        if constexpr (extents_type::rank() > 0) {
            index_type _Prod = 1;
            for (size_t _Idx = extents_type::_Rank; _Idx-- > 0;) {
                _STL_VERIFY(_Prod == _Other.stride(_Idx),
                    "For all r in the range [0, extents_type::rank()), other.stride(r) must be equal to "
                    "extents().rev-prod-of-extents(r) (N4950 [mdspan.layout.right.cons]/10.1).");
                _Prod = static_cast<index_type>(_Prod * _Exts.extent(_Idx));
            }
            _STL_VERIFY(_STD in_range<index_type>(_Other.required_span_size()),
                "Value of other.required_span_size() must be representable as a value of type index_type (N4950 "
                "[mdspan.layout.right.cons]/10.2).");
        }
#endif // _CONTAINER_DEBUG_LEVEL > 0
    }

    constexpr mapping& operator=(const mapping&) noexcept = default;

    _NODISCARD constexpr const extents_type& extents() const noexcept {
        return _Exts;
    }

    _NODISCARD constexpr index_type required_span_size() const noexcept {
        return _Fwd_prod_of_extents<extents_type>::_Calculate(_Exts, extents_type::_Rank);
    }

    template <class... _IndexTypes>
        requires (sizeof...(_IndexTypes) == extents_type::rank()) && (is_convertible_v<_IndexTypes, index_type> && ...)
              && (is_nothrow_constructible_v<index_type, _IndexTypes> && ...)
    _NODISCARD constexpr index_type operator()(_IndexTypes... _Indices) const noexcept {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Exts._Contains_multidimensional_index(
                        make_index_sequence<extents_type::rank()>{}, static_cast<index_type>(_Indices)...),
            "Value of extents_type::index-cast(i) must be a multidimensional index in extents_ (N4950 "
            "[mdspan.layout.right.obs]/3).");
#endif // _CONTAINER_DEBUG_LEVEL > 0
        return _Index_impl(make_index_sequence<extents_type::rank()>{}, static_cast<index_type>(_Indices)...);
    }

    _NODISCARD static constexpr bool is_always_unique() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_always_exhaustive() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_always_strided() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_unique() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_exhaustive() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_strided() noexcept {
        return true;
    }

    _NODISCARD constexpr index_type stride(const rank_type _Idx) const noexcept
        requires (extents_type::rank() > 0)
    {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Idx < extents_type::_Rank,
            "Value of i must be less than extents_type::rank() (N4950 [mdspan.layout.right.obs]/6).");
#endif // _CONTAINER_DEBUG_LEVEL > 0
        return _Rev_prod_of_extents<extents_type>::_Calculate(_Exts, _Idx);
    }

    template <class _OtherExtents>
        requires (extents_type::rank() == _OtherExtents::rank())
    _NODISCARD_FRIEND constexpr bool operator==(const mapping& _Left, const mapping<_OtherExtents>& _Right) noexcept {
        return _Left.extents() == _Right.extents();
    }

private:
    extents_type _Exts{};

    template <class... _IndexTypes, size_t... _Seq>
    _NODISCARD constexpr index_type _Index_impl(index_sequence<_Seq...>, _IndexTypes... _Indices) const noexcept {
        _STL_INTERNAL_STATIC_ASSERT((same_as<_IndexTypes, index_type> && ...));
        index_type _Result = 0;
        ((_Result = static_cast<index_type>(_Indices + _Exts.extent(_Seq) * _Result)), ...);
        return _Result;
    }
};

template <class _Mp>
concept _Layout_mapping_alike = requires {
    requires _Is_extents<typename _Mp::extents_type>;
    { _Mp::is_always_strided() } -> same_as<bool>;
    { _Mp::is_always_exhaustive() } -> same_as<bool>;
    { _Mp::is_always_unique() } -> same_as<bool>;
    bool_constant<_Mp::is_always_strided()>::value;
    bool_constant<_Mp::is_always_exhaustive()>::value;
    bool_constant<_Mp::is_always_unique()>::value;
};

template <class _Extents>
class layout_stride::mapping {
public:
    using extents_type = _Extents;
    using index_type   = extents_type::index_type;
    using size_type    = extents_type::size_type;
    using rank_type    = extents_type::rank_type;
    using layout_type  = layout_stride;

    static_assert(_Is_extents<extents_type>,
        "Extents must be a specialization of std::extents (N4950 [mdspan.layout.stride.overview]/2).");
    static_assert(
        extents_type::rank_dynamic() != 0 || extents_type::_Is_static_multidim_index_space_size_representable(),
        "If Extents::rank_dynamic() == 0 is true, then the size of the multidimensional index space Extents() must be "
        "representable as a value of type typename Extents::index_type (N4950 [mdspan.layout.stride.overview]/4).");

    constexpr mapping() noexcept : _Exts(extents_type{}) {
        if constexpr (extents_type::rank() != 0) {
            _Strides.back() = 1;
            for (rank_type _Idx = extents_type::_Rank - 1; _Idx-- > 0;) {
#if _CONTAINER_DEBUG_LEVEL > 0
                const bool _Overflow = _Mul_overflow(_Strides[_Idx + 1], _Exts.extent(_Idx + 1), _Strides[_Idx]);
                // NB: N4950 requires value of 'layout_right​::​mapping<extents_type>().required_span_size()' to be
                // representable as value of type 'index_type', but this is not enough. We need to require every single
                // stride to be representable as value of type 'index_type', so we can get desired effects.
                _STL_VERIFY(!_Overflow,
                    "Value of layout_right::mapping<extents_type>().required_span_size() must be "
                    "representable as a value of type index_type (N4950 [mdspan.layout.stride.cons]/1).");
#else // ^^^ _CONTAINER_DEBUG_LEVEL > 0 / _CONTAINER_DEBUG_LEVEL == 0 vvv
                _Strides[_Idx] = static_cast<index_type>(_Strides[_Idx + 1] * _Exts.extent(_Idx + 1));
#endif // _CONTAINER_DEBUG_LEVEL > 0
            }
        }
    }

    constexpr mapping(const mapping&) noexcept = default;

    template <class _OtherIndexType, size_t... _Indices>
        requires is_convertible_v<const _OtherIndexType&, index_type>
                  && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
    constexpr mapping(const extents_type& _Exts_, span<_OtherIndexType, extents_type::rank()> _Strides_,
        index_sequence<_Indices...>) noexcept
        : _Exts(_Exts_), _Strides{static_cast<index_type>(_STD as_const(_Strides_[_Indices]))...} {
#if _CONTAINER_DEBUG_LEVEL > 0
        if constexpr (extents_type::rank() != 0) {
            bool _Found_zero          = false;
            bool _Overflow            = false;
            index_type _Req_span_size = 0;
            for (rank_type _Idx = 0; _Idx < extents_type::_Rank; ++_Idx) {
                const index_type _Stride = _Strides[_Idx];
                _STL_VERIFY(_Stride > 0, "Value of s[i] must be greater than 0 for all i in the range [0, rank_) "
                                         "(N4950 [mdspan.layout.stride.cons]/4.1).");
                const index_type _Ext = _Exts.extent(_Idx);
                if (_Ext == 0) {
                    _Found_zero = true;
                }

                if (!_Found_zero && !_Overflow) {
                    index_type _Prod;
                    _Overflow = _Mul_overflow(static_cast<index_type>(_Ext - 1), _Stride, _Prod)
                             || _Add_overflow(_Req_span_size, _Prod, _Req_span_size);
                }
            }
            _STL_VERIFY(_Found_zero || !_Overflow, "REQUIRED-SPAN-SIZE(e, s) must be representable as a value of type "
                                                   "index_type (N4950 [mdspan.layout.stride.cons]/4.2).");
        }
#endif // _CONTAINER_DEBUG_LEVEL > 0
    }

#ifndef __clang__ // TRANSITION, DevCom-10360833
    template <class _OtherIndexType, enable_if_t<is_convertible_v<const _OtherIndexType&, index_type>
                                                     && is_nothrow_constructible_v<index_type, const _OtherIndexType&>,
                                         int> = 0>
#else // ^^^ workaround / no workaround vvv
    template <class _OtherIndexType>
        requires is_convertible_v<const _OtherIndexType&, index_type>
              && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
#endif // ^^^ no workaround ^^^
    constexpr mapping(const extents_type& _Exts_, span<_OtherIndexType, extents_type::rank()> _Strides_) noexcept
        : mapping(_Exts_, _Strides_, make_index_sequence<extents_type::rank()>{}) {
    }

#ifndef __clang__ // TRANSITION, DevCom-10360833
    template <class _OtherIndexType, enable_if_t<is_convertible_v<const _OtherIndexType&, index_type>
                                                     && is_nothrow_constructible_v<index_type, const _OtherIndexType&>,
                                         int> = 0>
#else // ^^^ workaround / no workaround vvv
    template <class _OtherIndexType>
        requires is_convertible_v<const _OtherIndexType&, index_type>
              && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
#endif // ^^^ no workaround ^^^
    constexpr mapping(
        const extents_type& _Exts_, const array<_OtherIndexType, extents_type::rank()>& _Strides_) noexcept
        : mapping(_Exts_, span{_Strides_}, make_index_sequence<extents_type::rank()>{}) {
    }

    template <class _StridedLayoutMapping>
        requires _Layout_mapping_alike<_StridedLayoutMapping>
              && is_constructible_v<extents_type, typename _StridedLayoutMapping::extents_type>
              && (_StridedLayoutMapping::is_always_unique()) && (_StridedLayoutMapping::is_always_strided())
    constexpr explicit(!(
        is_convertible_v<typename _StridedLayoutMapping::extents_type, extents_type>
        && (_Is_mapping_of<layout_left, _StridedLayoutMapping> || _Is_mapping_of<layout_right, _StridedLayoutMapping>
            || _Is_mapping_of<layout_stride, _StridedLayoutMapping>) ))
        mapping(const _StridedLayoutMapping& _Other) noexcept
        : _Exts(_Other.extents()) {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_STD in_range<index_type>(_Other.required_span_size()),
            "Value of other.required_span_size() must be representable as a value of type index_type (N4950 "
            "[mdspan.layout.stride.cons]/7.3).");
        _STL_VERIFY(
            _Offset(_Other) == 0, "Value of OFFSET(other) must be equal to 0 (N4950 [mdspan.layout.stride.cons]/7.4).");
#endif // _CONTAINER_DEBUG_LEVEL > 0
        for (rank_type _Idx = 0; _Idx < extents_type::_Rank; ++_Idx) {
            const auto _Stride = _Other.stride(_Idx);
#if _CONTAINER_DEBUG_LEVEL > 0
            _STL_VERIFY(_Stride > 0, "Value of other.stride(r) must be greater than 0 for every rank index r of "
                                     "extents() (N4950 [mdspan.layout.stride.cons]/7.2).");
#endif // _CONTAINER_DEBUG_LEVEL > 0
            _Strides[_Idx] = static_cast<index_type>(_Stride);
        }
    }

    constexpr mapping& operator=(const mapping&) noexcept = default;

    _NODISCARD constexpr const extents_type& extents() const noexcept {
        return _Exts;
    }

    _NODISCARD constexpr array<index_type, extents_type::rank()> strides() const noexcept {
        return _Strides;
    }

    _NODISCARD constexpr index_type required_span_size() const noexcept {
        if constexpr (extents_type::rank() == 0) {
            return 1;
        } else {
            index_type _Result = 1;
            for (rank_type _Idx = 0; _Idx < extents_type::_Rank; ++_Idx) {
                const index_type _Ext = _Exts.extent(_Idx);
                if (_Ext == 0) {
                    return 0;
                }

                _Result += (_Ext - 1) * _Strides[_Idx];
            }

            return _Result;
        }
    }

    template <class... _IndexTypes>
        requires (sizeof...(_IndexTypes) == extents_type::rank()) && (is_convertible_v<_IndexTypes, index_type> && ...)
              && (is_nothrow_constructible_v<index_type, _IndexTypes> && ...)
    _NODISCARD constexpr index_type operator()(_IndexTypes... _Indices) const noexcept {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Exts._Contains_multidimensional_index(
                        make_index_sequence<extents_type::rank()>{}, static_cast<index_type>(_Indices)...),
            "Value of extents_type::index-cast(i) must be a multidimensional index in extents_ (N4950 "
            "[mdspan.layout.stride.obs]/3).");
#endif // _CONTAINER_DEBUG_LEVEL > 0
        return _Index_impl(make_index_sequence<extents_type::rank()>{}, static_cast<index_type>(_Indices)...);
    }

    _NODISCARD static constexpr bool is_always_unique() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_always_exhaustive() noexcept {
        return false;
    }

    _NODISCARD static constexpr bool is_always_strided() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_unique() noexcept {
        return true;
    }

    _NODISCARD constexpr bool is_exhaustive() const noexcept {
        if constexpr (extents_type::rank() == 0) {
            return true;
        } else {
            return required_span_size() == _Fwd_prod_of_extents<extents_type>::_Calculate(_Exts, extents_type::_Rank);
        }
    }

    _NODISCARD static constexpr bool is_strided() noexcept {
        return true;
    }

    _NODISCARD constexpr index_type stride(const rank_type _Idx) const noexcept {
        return _Strides[_Idx];
    }

    template <class _OtherMapping>
        requires _Layout_mapping_alike<_OtherMapping> && (extents_type::rank() == _OtherMapping::extents_type::rank())
              && (_OtherMapping::is_always_strided())
    _NODISCARD_FRIEND constexpr bool operator==(const mapping& _Left, const _OtherMapping& _Right) noexcept {
        if constexpr (extents_type::rank() != 0) {
            if (_Left.extents() != _Right.extents()) {
                return false;
            }

            for (rank_type _Idx = 0; _Idx < extents_type::_Rank; ++_Idx) {
                if (_STD cmp_not_equal(_Left.stride(_Idx), _Right.stride(_Idx))) {
                    return false;
                }
            }
        }

        return _Offset(_Right) == 0;
    }

private:
    extents_type _Exts{};
    array<index_type, extents_type::rank()> _Strides{};

    template <class _OtherMapping>
    _NODISCARD static constexpr _OtherMapping::index_type _Offset(_OtherMapping& _Mapping) noexcept {
        if constexpr (extents_type::rank() == 0) {
            return _Mapping();
        } else {
            for (rank_type _Idx = 0; _Idx < extents_type::_Rank; ++_Idx) {
                if (_Mapping.extents().extent(_Idx) == 0) {
                    return 0;
                }
            }

            return [&]<size_t... _Indices>(index_sequence<_Indices...>) { return _Mapping(((void) _Indices, 0)...); }(
                       make_index_sequence<extents_type::rank()>{});
        }
    }

    template <class... _IndexTypes, size_t... _Seq>
    _NODISCARD constexpr index_type _Index_impl(index_sequence<_Seq...>, _IndexTypes... _Indices) const noexcept {
        _STL_INTERNAL_STATIC_ASSERT((same_as<_IndexTypes, index_type> && ...));
        return static_cast<index_type>(((_Indices * _Strides[_Seq]) + ... + 0));
    }
};

_EXPORT_STD template <class _ElementType>
struct default_accessor {
    using offset_policy    = default_accessor;
    using element_type     = _ElementType;
    using reference        = _ElementType&;
    using data_handle_type = _ElementType*;

    static_assert(
        sizeof(element_type) > 0, "ElementType must be a complete type (N4950 [mdspan.accessor.default.overview]/2).");
    static_assert(!is_abstract_v<element_type>,
        "ElementType cannot be an abstract type (N4950 [mdspan.accessor.default.overview]/2).");
    static_assert(
        !is_array_v<element_type>, "ElementType cannot be an array type (N4950 [mdspan.accessor.default.overview]/2).");

    constexpr default_accessor() noexcept = default;

    template <class _OtherElementType>
        requires is_convertible_v<_OtherElementType (*)[], element_type (*)[]>
    constexpr default_accessor(default_accessor<_OtherElementType>) noexcept {}

    _NODISCARD constexpr data_handle_type offset(data_handle_type _Ptr, size_t _Idx) const noexcept {
        return _Ptr + _Idx;
    }

    _NODISCARD constexpr reference access(data_handle_type _Ptr, size_t _Idx) const noexcept {
        return _Ptr[_Idx];
    }
};

_EXPORT_STD template <class _ElementType, class _Extents, class _LayoutPolicy = layout_right,
    class _AccessorPolicy = default_accessor<_ElementType>>
class mdspan {
public:
    using extents_type     = _Extents;
    using layout_type      = _LayoutPolicy;
    using accessor_type    = _AccessorPolicy;
    using mapping_type     = layout_type::template mapping<extents_type>;
    using element_type     = _ElementType;
    using value_type       = remove_cv_t<element_type>;
    using index_type       = extents_type::index_type;
    using size_type        = extents_type::size_type;
    using rank_type        = extents_type::rank_type;
    using data_handle_type = accessor_type::data_handle_type;
    using reference        = accessor_type::reference;

    static_assert(
        sizeof(element_type) > 0, "ElementType must be a complete type (N4950 [mdspan.mdspan.overview]/2.1).");
    static_assert(
        !is_abstract_v<element_type>, "ElementType cannot be an abstract type (N4950 [mdspan.mdspan.overview]/2.1).");
    static_assert(
        !is_array_v<element_type>, "ElementType cannot be an array type (N4950 [mdspan.mdspan.overview]/2.1).");
    static_assert(_Is_extents<extents_type>,
        "Extents must be a specialization of std::extents (N4950 [mdspan.mdspan.overview]/2.2).");
    static_assert(is_same_v<element_type, typename accessor_type::element_type>,
        "ElementType and typename AccessorPolicy::element_type must be the same type (N4950 "
        "[mdspan.mdspan.overview]/2.3).");

    _NODISCARD static constexpr rank_type rank() noexcept {
        return extents_type::_Rank;
    }

    _NODISCARD static constexpr rank_type rank_dynamic() noexcept {
        return extents_type::_Rank_dynamic;
    }

    _NODISCARD static constexpr size_t static_extent(const rank_type _Idx) noexcept {
        return extents_type::static_extent(_Idx);
    }

    _NODISCARD constexpr index_type extent(const rank_type _Idx) const noexcept {
        return _Map.extents().extent(_Idx);
    }

    constexpr mdspan()
        requires (rank_dynamic() > 0) && is_default_constructible_v<data_handle_type>
              && is_default_constructible_v<mapping_type> && is_default_constructible_v<accessor_type>
    {}

    constexpr mdspan(const mdspan&) = default;
    constexpr mdspan(mdspan&&)      = default;

    template <class... _OtherIndexTypes>
        requires (is_convertible_v<_OtherIndexTypes, index_type> && ...)
                  && (is_nothrow_constructible_v<index_type, _OtherIndexTypes> && ...)
                  && (sizeof...(_OtherIndexTypes) == rank() || sizeof...(_OtherIndexTypes) == rank_dynamic())
                  && is_constructible_v<mapping_type, extents_type> && is_default_constructible_v<accessor_type>
    constexpr explicit mdspan(data_handle_type _Ptr_, _OtherIndexTypes... _Exts)
        : _Ptr(_STD move(_Ptr_)), _Map(extents_type{static_cast<index_type>(_STD move(_Exts))...}), _Acc() {}

    template <class _OtherIndexType, size_t _Size>
        requires is_convertible_v<_OtherIndexType, index_type>
                  && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
                  && (_Size == rank() || _Size == rank_dynamic())
                  && is_constructible_v<mapping_type, extents_type> && is_default_constructible_v<accessor_type>
    constexpr explicit(_Size != rank_dynamic()) mdspan(data_handle_type _Ptr_, span<_OtherIndexType, _Size> _Exts)
        : _Ptr(_STD move(_Ptr_)), _Map(extents_type{_Exts}), _Acc() {}

    template <class _OtherIndexType, size_t _Size>
        requires is_convertible_v<const _OtherIndexType&, index_type>
                  && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
                  && (_Size == rank() || _Size == rank_dynamic())
                  && is_constructible_v<mapping_type, extents_type> && is_default_constructible_v<accessor_type>
    constexpr explicit(_Size != rank_dynamic())
        mdspan(data_handle_type _Ptr_, const array<_OtherIndexType, _Size>& _Exts)
        : _Ptr(_STD move(_Ptr_)), _Map(extents_type{_Exts}), _Acc() {}

    constexpr mdspan(data_handle_type _Ptr_, const extents_type& _Ext)
        requires is_constructible_v<mapping_type, const extents_type&> && is_default_constructible_v<accessor_type>
        : _Ptr(_STD move(_Ptr_)), _Map(_Ext), _Acc() {}

    constexpr mdspan(data_handle_type _Ptr_, const mapping_type& _Map_)
        requires is_default_constructible_v<accessor_type>
        : _Ptr(_STD move(_Ptr_)), _Map(_Map_), _Acc() {}

    constexpr mdspan(data_handle_type _Ptr_, const mapping_type& _Map_, const accessor_type& _Acc_)
        : _Ptr(_STD move(_Ptr_)), _Map(_Map_), _Acc(_Acc_) {}

    template <class _OtherElementType, class _OtherExtents, class _OtherLayoutPolicy, class _OtherAccessor>
        requires is_constructible_v<mapping_type, const typename _OtherLayoutPolicy::template mapping<_OtherExtents>&>
                  && is_constructible_v<accessor_type, const _OtherAccessor&>
    constexpr explicit(
        !is_convertible_v<const typename _OtherLayoutPolicy::template mapping<_OtherExtents>&, mapping_type>
        || !is_convertible_v<const _OtherAccessor&, accessor_type>)
        mdspan(const mdspan<_OtherElementType, _OtherExtents, _OtherLayoutPolicy, _OtherAccessor>& _Other)
        : _Ptr(_Other.data_handle()), _Map(_Other.mapping()), _Acc(_Other.accessor()) {
        static_assert(is_constructible_v<data_handle_type, const typename _OtherAccessor::data_handle_type&>,
            "The data_handle_type must be constructible from const typename OtherAccessor::data_handle_type& (N4950 "
            "[mdspan.mdspan.cons]/20.1).");
        static_assert(is_constructible_v<extents_type, _OtherExtents>,
            "The extents_type must be constructible from OtherExtents (N4950 [mdspan.mdspan.cons]/20.2).");
#if _CONTAINER_DEBUG_LEVEL > 0
        for (rank_type _Idx = 0; _Idx < extents_type::_Rank; ++_Idx) {
            const auto _Static_ext = extents_type::_Static_extents[_Idx];
            _STL_VERIFY(_Static_ext == dynamic_extent || _Static_ext == _Other.extent(_Idx),
                "For each rank index r of extents_type, static_extent(r) == dynamic_extent || static_extent(r) == "
                "other.extent(r) must be true (N4950 [mdspan.mdspan.cons]/21.1).");
        }
#endif // _CONTAINER_DEBUG_LEVEL > 0
    }

    constexpr mdspan& operator=(const mdspan&) = default;
    constexpr mdspan& operator=(mdspan&&)      = default;

#ifdef __cpp_multidimensional_subscript // TRANSITION, P2128R6
    template <class... _OtherIndexTypes>
        requires (is_convertible_v<_OtherIndexTypes, index_type> && ...)
              && (is_nothrow_constructible_v<index_type, _OtherIndexTypes> && ...)
              && (sizeof...(_OtherIndexTypes) == rank())
    _NODISCARD constexpr reference operator[](_OtherIndexTypes... _Indices) const {
#if _CONTAINER_DEBUG_LEVEL > 0
        if constexpr ((integral<_OtherIndexTypes> && ...)) {
            _STL_VERIFY(_Map.extents()._Contains_multidimensional_index(
                            make_index_sequence<rank()>{}, static_cast<index_type>(_Indices)...),
                "I must be a multidimensional index in extents() (N4950 [mdspan.mdspan.members]/3).");
        }
#endif // _CONTAINER_DEBUG_LEVEL > 0
        return _Acc.access(_Ptr, static_cast<size_t>(_Map(static_cast<index_type>(_STD move(_Indices))...)));
    }
#endif // __cpp_multidimensional_subscript

    template <class _OtherIndexType>
        requires is_convertible_v<const _OtherIndexType&, index_type>
              && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
    _NODISCARD constexpr reference operator[](span<_OtherIndexType, rank()> _Indices) const {
        return _Index_impl(_Indices, make_index_sequence<rank()>{});
    }

    template <class _OtherIndexType>
        requires is_convertible_v<const _OtherIndexType&, index_type>
              && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
    _NODISCARD constexpr reference operator[](const array<_OtherIndexType, rank()>& _Indices) const {
        return _Index_impl(span{_Indices}, make_index_sequence<rank()>{});
    }

    _NODISCARD constexpr size_type size() const noexcept {
        return static_cast<size_type>(
            _Fwd_prod_of_extents<extents_type>::_Calculate(_Map.extents(), extents_type::_Rank));
    }

    _NODISCARD constexpr bool empty() const noexcept {
        if constexpr (extents_type::_Multidim_index_space_size_is_always_zero) {
            return true;
        } else {
            const extents_type& _Exts = _Map.extents();
            for (rank_type _Idx = 0; _Idx < extents_type::_Rank; ++_Idx) {
                if (_Exts.extent(_Idx) == 0) {
                    return true;
                }
            }
            return false;
        }
    }

    friend constexpr void swap(mdspan& _Left, mdspan& _Right) noexcept {
        swap(_Left._Ptr, _Right._Ptr); // intentional ADL
        swap(_Left._Map, _Right._Map); // intentional ADL
        swap(_Left._Acc, _Right._Acc); // intentional ADL
    }

    _NODISCARD constexpr const extents_type& extents() const noexcept {
        return _Map.extents();
    }

    _NODISCARD constexpr const data_handle_type& data_handle() const noexcept {
        return _Ptr;
    }

    _NODISCARD constexpr const mapping_type& mapping() const noexcept {
        return _Map;
    }

    _NODISCARD constexpr const accessor_type& accessor() const noexcept {
        return _Acc;
    }

    _NODISCARD static constexpr bool is_always_unique() noexcept(
        noexcept(mapping_type::is_always_unique())) /* strengthened */ {
        return mapping_type::is_always_unique();
    }

    _NODISCARD static constexpr bool is_always_exhaustive() noexcept(
        noexcept(mapping_type::is_always_exhaustive())) /* strengthened */ {
        return mapping_type::is_always_exhaustive();
    }

    _NODISCARD static constexpr bool is_always_strided() noexcept(
        noexcept(mapping_type::is_always_strided())) /* strengthened */ {
        return mapping_type::is_always_strided();
    }

    _NODISCARD constexpr bool is_unique() const noexcept(noexcept(_Map.is_unique())) /* strengthened */ {
        return _Map.is_unique();
    }

    _NODISCARD constexpr bool is_exhaustive() const noexcept(noexcept(_Map.is_exhaustive())) /* strengthened */ {
        return _Map.is_exhaustive();
    }

    _NODISCARD constexpr bool is_strided() const noexcept(noexcept(_Map.is_strided())) /* strengthened */ {
        return _Map.is_strided();
    }

    _NODISCARD constexpr index_type stride(const rank_type _Idx) const
        noexcept(noexcept(_Map.stride(_Idx))) /* strengthened */ {
        return _Map.stride(_Idx);
    }

private:
    template <class _OtherIndexType, size_t... _Seq>
    _NODISCARD constexpr reference _Index_impl(span<_OtherIndexType, rank()> _Indices, index_sequence<_Seq...>) const {
#ifdef __cpp_multidimensional_subscript // TRANSITION, P2128R6
        return operator[](_STD as_const(_Indices[_Seq])...);
#else // ^^^ defined(__cpp_multidimensional_subscript) / !defined(__cpp_multidimensional_subscript) vvv
        return _Multidimensional_access(_STD as_const(_Indices[_Seq])...);
#endif // ^^^ !defined(__cpp_multidimensional_subscript) ^^^
    }

#ifndef __cpp_multidimensional_subscript // TRANSITION, P2128R6
    template <class... _OtherIndexTypes>
    _NODISCARD constexpr reference _Multidimensional_access(_OtherIndexTypes... _Indices) const {
        return _Acc.access(_Ptr, static_cast<size_t>(_Map(static_cast<index_type>(_STD move(_Indices))...)));
    }
#endif // __cpp_multidimensional_subscript

    data_handle_type _Ptr{};
    mapping_type _Map{};
    accessor_type _Acc{};
};

template <class _CArray>
    requires (is_array_v<_CArray> && rank_v<_CArray> == 1)
mdspan(_CArray&) -> mdspan<remove_all_extents_t<_CArray>, extents<size_t, extent_v<_CArray, 0>>>;

template <class _Pointer>
    requires (is_pointer_v<remove_reference_t<_Pointer>>)
mdspan(_Pointer&&) -> mdspan<remove_pointer_t<remove_reference_t<_Pointer>>, extents<size_t>>;

template <class _ElementType, class... _Integrals>
    requires ((is_convertible_v<_Integrals, size_t> && ...) && sizeof...(_Integrals) > 0)
explicit mdspan(_ElementType*, _Integrals...) -> mdspan<_ElementType, dextents<size_t, sizeof...(_Integrals)>>;

template <class _ElementType, class _OtherIndexType, size_t _Nx>
mdspan(_ElementType*, span<_OtherIndexType, _Nx>) -> mdspan<_ElementType, dextents<size_t, _Nx>>;

template <class _ElementType, class _OtherIndexType, size_t _Nx>
mdspan(_ElementType*, const array<_OtherIndexType, _Nx>&) -> mdspan<_ElementType, dextents<size_t, _Nx>>;

template <class _ElementType, class _IndexType, size_t... _ExtentsPack>
mdspan(_ElementType*, const extents<_IndexType, _ExtentsPack...>&)
    -> mdspan<_ElementType, extents<_IndexType, _ExtentsPack...>>;

template <class _ElementType, class _MappingType>
mdspan(_ElementType*, const _MappingType&)
    -> mdspan<_ElementType, typename _MappingType::extents_type, typename _MappingType::layout_type>;

template <class _MappingType, class _AccessorType>
mdspan(const typename _AccessorType::data_handle_type&, const _MappingType&, const _AccessorType&)
    -> mdspan<typename _AccessorType::element_type, typename _MappingType::extents_type,
        typename _MappingType::layout_type, _AccessorType>;

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // ^^^ supported language mode ^^^
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _MDSPAN_
