// mdspan standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _MDSPAN_
#define _MDSPAN_
#include <yvals.h>
#if _STL_COMPILER_PREPROCESSOR
#if !_HAS_CXX23 || !defined(__cpp_lib_concepts) // TRANSITION, GH-395
_EMIT_STL_WARNING(STL4038, "The contents of <mdspan> are available only with C++23 or later.");
#else // ^^^ not supported / supported language mode vvv
#include <algorithm>
#include <array>
#include <span>
#include <tuple>
#include <type_traits>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN

template <class _IndexType, size_t _Rank_dynamic, size_t... _Extents>
struct _Mdspan_extent_type {
    using index_type = _IndexType;

    _NODISCARD static constexpr auto _Get_dynamic_indices() noexcept { // TRANSITION consteval?
        array<size_t, sizeof...(_Extents)> _Result;
        size_t _Counter = 0;
        for (size_t _Ix = 0; _Ix < sizeof...(_Extents); ++_Ix) {
            _Result[_Ix] = _Counter;
            if (_Static_extents[_Ix] == dynamic_extent) {
                ++_Counter;
            }
        }
        return _Result;
    }

    index_type _Dynamic_extents[_Rank_dynamic]                           = {};
    static constexpr size_t _Static_extents[sizeof...(_Extents)]         = {_Extents...};
    static constexpr array<size_t, sizeof...(_Extents)> _Dynamic_indices = _Get_dynamic_indices();

    constexpr _Mdspan_extent_type() noexcept = default;

    template <class... _OtherIndexTypes>
        requires (sizeof...(_OtherIndexTypes) == _Rank_dynamic) && (is_same_v<_OtherIndexTypes, index_type> && ...)
    constexpr _Mdspan_extent_type(_OtherIndexTypes... _OtherExtents) noexcept : _Dynamic_extents{_OtherExtents...} {}

    template <class _OtherIndexType, size_t _Size, size_t... _Idx>
        requires (_Size == _Rank_dynamic)
    constexpr _Mdspan_extent_type(span<_OtherIndexType, _Size> _Data, index_sequence<_Idx...>) noexcept
        : _Dynamic_extents{static_cast<index_type>(_STD as_const(_Data[_Idx]))...} {}

    template <class... _OtherIndexTypes>
        requires (sizeof...(_OtherIndexTypes) == sizeof...(_Extents)) && (sizeof...(_Extents) != _Rank_dynamic)
              && (is_same_v<_OtherIndexTypes, index_type> && ...)
    constexpr _Mdspan_extent_type(_OtherIndexTypes... _OtherExtents) noexcept {
        auto _It = _Dynamic_extents;
        ((_Extents == dynamic_extent ? void(*_It++ = _OtherExtents) : void(_OtherExtents)), ...);
    }

    template <class _OtherIndexType, size_t _Size, size_t... _Idx>
        requires (_Size == sizeof...(_Extents)) && (sizeof...(_Extents) != _Rank_dynamic)
    constexpr _Mdspan_extent_type(span<_OtherIndexType, _Size> _Data, index_sequence<_Idx...>) noexcept
        : _Dynamic_extents{{static_cast<index_type>(_STD as_const(_Data[_Dynamic_indices[_Idx]]))...}} {}

    constexpr index_type* _Begin_dynamic_extents() noexcept {
        return _Dynamic_extents;
    }

    constexpr const index_type* _Begin_dynamic_extents() const noexcept {
        return _Dynamic_extents;
    }
};

template <class _IndexType, size_t... _Extents>
struct _Mdspan_extent_type<_IndexType, 0, _Extents...> {
    using index_type = _IndexType;

    static constexpr size_t _Static_extents[sizeof...(_Extents)] = {_Extents...};

    constexpr _Mdspan_extent_type() noexcept = default;

    template <class... _IndexTypes>
        requires (sizeof...(_IndexTypes) == sizeof...(_Extents))
    constexpr _Mdspan_extent_type(_IndexTypes... /*_OtherExtents*/) noexcept {}

    template <class _OtherIndexType, size_t _Size, size_t... _Idx>
        requires (_Size == sizeof...(_Extents)) || (_Size == 0)
    constexpr _Mdspan_extent_type(span<_OtherIndexType, _Size>, index_sequence<_Idx...>) noexcept {}

    constexpr index_type* _Begin_dynamic_extents() noexcept {
        return nullptr;
    }

    constexpr const index_type* _Begin_dynamic_extents() const noexcept {
        return nullptr;
    }
};

template <class _IndexType>
struct _Mdspan_extent_type<_IndexType, 0> {
    using index_type = _IndexType;

    constexpr index_type* _Begin_dynamic_extents() {
        return nullptr;
    }

    constexpr const index_type* _Begin_dynamic_extents() const noexcept {
        return nullptr;
    }
};

template <class _IndexType, size_t... _Extents>
class extents : private _Mdspan_extent_type<_IndexType, ((_Extents == dynamic_extent) + ... + 0), _Extents...> {
public:
    using _Mybase    = _Mdspan_extent_type<_IndexType, ((_Extents == dynamic_extent) + ... + 0), _Extents...>;
    using index_type = typename _Mybase::index_type;
    using size_type  = make_unsigned_t<index_type>;
    using rank_type  = size_t;

    static_assert(_Is_standard_integer<_IndexType>,
        "IndexType must be a signed or unsigned integer type (N4928 [mdspan.extents.overview]/1.1).");
    static_assert(((_Extents == dynamic_extent || _STD in_range<_IndexType>(_Extents)) && ...),
        "Each element of Extents must be either equal to dynamic_extent, or must be representable as a value of type "
        "IndexType (N4928 [mdspan.extents.overview]/1.2).");

    _NODISCARD static constexpr rank_type rank() noexcept {
        return sizeof...(_Extents);
    }

    _NODISCARD static constexpr rank_type rank_dynamic() noexcept {
        return ((_Extents == dynamic_extent) + ... + 0);
    }

    _NODISCARD static constexpr size_t static_extent(const rank_type _Idx) noexcept {
        return _Mybase::_Static_extents[_Idx];
    }

    _NODISCARD constexpr index_type extent(const rank_type _Idx) const noexcept {
        if constexpr (rank_dynamic() == 0) {
            return static_cast<index_type>(_Mybase::_Static_extents[_Idx]);
        } else if constexpr (rank_dynamic() == rank()) {
            return _Mybase::_Dynamic_extents[_Idx];
        } else {
            const auto _Static_extent = _Mybase::_Static_extents[_Idx];
            if (_Static_extent == dynamic_extent) {
                return _Mybase::_Dynamic_extents[_Mybase::_Dynamic_indices[_Idx]];
            } else {
                return static_cast<index_type>(_Static_extent);
            }
        }
    }

    constexpr extents() noexcept = default;

    template <class _OtherIndexType, size_t... _OtherExtents>
        requires (sizeof...(_OtherExtents) == sizeof...(_Extents))
              && ((_OtherExtents == dynamic_extent || _Extents == dynamic_extent || _OtherExtents == _Extents) && ...)
    constexpr explicit((((_Extents != dynamic_extent) && (_OtherExtents == dynamic_extent)) || ...)
                       || (numeric_limits<index_type>::max)() < (numeric_limits<_OtherIndexType>::max)())
        extents(const extents<_OtherIndexType, _OtherExtents...>& _Other) noexcept {
        auto _Dynamic_it = _Mybase::_Begin_dynamic_extents();
        for (rank_type _Dim = 0; _Dim < sizeof...(_Extents); ++_Dim) {
            if (_Mybase::_Static_extents[_Dim] == dynamic_extent) {
                *_Dynamic_it++ = _Other.extent(_Dim);
            }
        }
    }

    template <class... _OtherIndexTypes>
        requires (is_convertible_v<_OtherIndexTypes, index_type> && ...)
              && (is_nothrow_constructible_v<index_type, _OtherIndexTypes> && ...)
              && (sizeof...(_OtherIndexTypes) == rank_dynamic() || sizeof...(_OtherIndexTypes) == rank())
    constexpr explicit extents(_OtherIndexTypes... _Exts) noexcept
        : _Mybase{static_cast<index_type>(_STD move(_Exts))...} {}

    template <class _OtherIndexType, size_t _Size>
        requires is_convertible_v<const _OtherIndexType&, index_type>
              && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
              && (_Size == rank_dynamic() || _Size == rank())
    constexpr explicit(_Size != rank_dynamic()) extents(span<_OtherIndexType, _Size> _Exts) noexcept
        : _Mybase{_Exts, _STD make_index_sequence<rank_dynamic()>{}} {}

    template <class _OtherIndexType, size_t _Size>
        requires is_convertible_v<const _OtherIndexType&, index_type>
              && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
              && (_Size == rank_dynamic() || _Size == rank())
    constexpr explicit(_Size != rank_dynamic()) extents(const array<_OtherIndexType, _Size>& _Exts) noexcept
        : _Mybase{span{_Exts}, _STD make_index_sequence<rank_dynamic()>{}} {}

    template <class _OtherIndexType, size_t... _OtherExtents>
    _NODISCARD_FRIEND constexpr bool operator==(
        const extents& _Left, const extents<_OtherIndexType, _OtherExtents...>& _Right) noexcept {
        if constexpr (sizeof...(_Extents) != sizeof...(_OtherExtents)) {
            return false;
        }

        for (size_t _Dim = 0; _Dim < sizeof...(_Extents); ++_Dim) {
            if (_Left.extent(_Dim) != _Right.extent(_Dim)) {
                return false;
            }
        }

        return true;
    }

    constexpr void _Fill_extents(index_type* _Out) const noexcept {
        auto _Dynamic_it = _Mybase::_Begin_dynamic_extents();
        for (size_t _Dim = 0; _Dim < sizeof...(_Extents); ++_Dim) {
            if (_Mybase::_Static_extents[_Dim] == dynamic_extent) {
                *_Out++ = *_Dynamic_it++;
            } else {
                *_Out++ = static_cast<index_type>(_Mybase::_Static_extents[_Dim]);
            }
        }
    }

    _NODISCARD static constexpr bool _Is_index_space_size_representable() {
        if constexpr (rank_dynamic() == 0 && rank() > 0) {
            return _STD in_range<index_type>((_Extents * ...));
        } else {
            return true;
        }
    }
};

template <class _IndexType, size_t _Rank>
using dextents =
    decltype([]<class _IndexType2, size_t... _Seq>(const _IndexType2, const index_sequence<_Seq...>) constexpr {
        return extents<_IndexType2, ((void) _Seq, dynamic_extent)...>{};
    }(_IndexType{0}, make_index_sequence<_Rank>{}));

// TRANSITION: why not `((void) _Ext, dynamic_extent)...`?!
template <class... _Integrals>
    requires (is_convertible_v<_Integrals, size_t> && ...)
extents(_Integrals... _Ext)
    -> extents<size_t, conditional_t<true, integral_constant<size_t, dynamic_extent>, _Integrals>::value...>;

template <class _Type>
inline constexpr bool _Is_extents = false;

template <class _IndexType, size_t... _Args>
inline constexpr bool _Is_extents<extents<_IndexType, _Args...>> = true;

template <class _Mapping, class = void>
struct _Layout_mapping_alike_helper : false_type {};

template <class _Mapping>
struct _Layout_mapping_alike_helper<_Mapping,
    void_t<is_same<bool, decltype(_Mapping::is_always_strided())>,
        is_same<bool, decltype(_Mapping::is_always_exhaustive())>,
        is_same<bool, decltype(_Mapping::is_always_unique())>, bool_constant<_Mapping::is_always_strided()>,
        bool_constant<_Mapping::is_always_exhaustive()>, bool_constant<_Mapping::is_always_unique()>>>
    : bool_constant<_Is_extents<typename _Mapping::extents_type>> {};

template <class _Mapping>
struct _Layout_mapping_alike : bool_constant<_Layout_mapping_alike_helper<_Mapping>::value> {};

template <class _Layout, class _Mapping>
inline constexpr bool _Is_mapping_of =
    is_same_v<typename _Layout::template mapping<typename _Mapping::extents_type>, _Mapping>;

struct layout_left {
    template <class _Extents>
    class mapping;
};

struct layout_right {
    template <class _Extents>
    class mapping;
};

struct layout_stride {
    template <class _Extents>
    class mapping;
};

template <class _Extents>
class layout_left::mapping {
public:
    using extents_type = _Extents;
    using index_type   = typename _Extents::index_type;
    using size_type    = typename _Extents::size_type;
    using rank_type    = typename _Extents::rank_type;
    using layout_type  = layout_left;

    static_assert(_Is_extents<_Extents>,
        "Extents must be a specialization of std::extents (N4928 [mdspan.layout.left.overview]/2).");
    static_assert(_Extents::_Is_index_space_size_representable(),
        "If Extents::rank_dynamic() == 0 is true, then the size of the multidimensional index space Extents() must be "
        "representable as a value of type typename Extents::index_type.");

    constexpr mapping() noexcept               = default;
    constexpr mapping(const mapping&) noexcept = default;

    constexpr mapping(const _Extents& _Ext) noexcept : _Myext(_Ext) {}

    template <class _OtherExtents, enable_if_t<is_constructible_v<_Extents, _OtherExtents>, int> = 0>
    constexpr explicit(!is_convertible_v<_OtherExtents, _Extents>)
        mapping(const mapping<_OtherExtents>& _Other) noexcept
        : _Myext{_Other.extents()} {}

    template <class _OtherExtents,
        enable_if_t<_Extents::rank() <= 1 && is_constructible_v<_Extents, _OtherExtents>, int> = 0>
    constexpr explicit(!is_convertible_v<_OtherExtents, _Extents>)
        mapping(const layout_right::mapping<_OtherExtents>& _Other) noexcept
        : _Myext{_Other.extents()} {}

    template <class _OtherExtents, enable_if_t<is_constructible_v<_Extents, _OtherExtents>, int> = 0>
    constexpr explicit(_Extents::rank() > 0) mapping(const layout_stride::template mapping<_OtherExtents>& _Other)
        : _Myext{_Other.extents()} {}

    constexpr mapping& operator=(const mapping&) noexcept = default;

    _NODISCARD constexpr const extents_type& extents() const noexcept {
        return _Myext;
    }

    _NODISCARD constexpr index_type required_span_size() const noexcept {
        index_type _Result = 1;
        for (rank_type _Dim = 0; _Dim < _Extents::rank(); ++_Dim) {
            _Result *= _Myext.extent(_Dim);
        }

        return _Result;
    }

    template <class... _Indices,
        enable_if_t<sizeof...(_Indices) == _Extents::rank() && (is_convertible_v<_Indices, index_type> && ...)
                        && (is_nothrow_constructible_v<index_type, _Indices> && ...),
            int> = 0>
    _NODISCARD constexpr index_type operator()(_Indices... _Idx) const noexcept {
        return _Index_impl<conditional_t<true, index_type, _Indices>...>(
            static_cast<index_type>(_Idx)..., make_index_sequence<_Extents::rank()>{});
    }

    _NODISCARD static constexpr bool is_always_unique() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_always_exhaustive() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_always_strided() noexcept {
        return true;
    }

    _NODISCARD constexpr bool is_unique() const noexcept {
        return true;
    }

    _NODISCARD constexpr bool is_exhaustive() const noexcept {
        return true;
    }

    _NODISCARD constexpr bool is_strided() const noexcept {
        return true;
    }

    template <class _Ext = _Extents, enable_if_t<(_Ext::rank() > 0), int> = 0>
    _NODISCARD constexpr index_type stride(const rank_type _Rank) const noexcept {
        index_type _Result = 1;
        for (rank_type _Dim = 0; _Dim < _Rank; ++_Dim) {
            _Result *= _Myext.extent(_Dim);
        }

        return _Result;
    }

    template <class _OtherExtents>
    _NODISCARD_FRIEND constexpr bool operator==(const mapping& _Left, const mapping<_OtherExtents>& _Right) noexcept {
        return _Left.extents() == _Right.extents();
    }

private:
    _Extents _Myext{};

    template <class... _IndexType, size_t... _Seq>
    constexpr index_type _Index_impl(_IndexType... _Idx, index_sequence<_Seq...>) const noexcept {
        // return _Extents::rank() > 0 ? ((_Idx * stride(_Seq)) + ... + 0) : 0;
        index_type _Stride = 1;
        index_type _Result = 0;
        (((_Result += _Idx * _Stride), (void) (_Stride *= _Myext.extent(_Seq))), ...);
        return _Result;
    }
};

template <class _Extents>
class layout_right::mapping {
public:
    using extents_type = _Extents;
    using index_type   = typename _Extents::index_type;
    using size_type    = typename _Extents::size_type;
    using rank_type    = typename _Extents::rank_type;
    using layout_type  = layout_right;

    static_assert(_Is_extents<_Extents>,
        "Extents must be a specialization of std::extents (N4928 [mdspan.layout.right.overview]/2).");
    static_assert(_Extents::_Is_index_space_size_representable(),
        "If Extents::rank_dynamic() == 0 is true, then the size of the multidimensional index space Extents() must be "
        "representable as a value of type typename Extents::index_type.");

    constexpr mapping() noexcept               = default;
    constexpr mapping(const mapping&) noexcept = default;

    constexpr mapping(const _Extents& _Ext) noexcept : _Myext(_Ext) {}

    template <class _OtherExtents, enable_if_t<is_constructible_v<_Extents, _OtherExtents>, int> = 0>
    constexpr explicit(!is_convertible_v<_OtherExtents, _Extents>)
        mapping(const mapping<_OtherExtents>& _Other) noexcept
        : _Myext{_Other.extents()} {}

    template <class _OtherExtents,
        enable_if_t<_Extents::rank() <= 1 && is_constructible_v<_Extents, _OtherExtents>, int> = 0>
    constexpr explicit(!is_convertible_v<_OtherExtents, _Extents>)
        mapping(const layout_left::mapping<_OtherExtents>& _Other) noexcept
        : _Myext{_Other.extents()} {}

    template <class _OtherExtents, enable_if_t<is_constructible_v<_Extents, _OtherExtents>, int> = 0>
    constexpr explicit(_Extents::rank() > 0) mapping(const layout_stride::template mapping<_OtherExtents>& _Other)
        : _Myext{_Other.extents()} {}

    constexpr mapping& operator=(const mapping&) noexcept = default;

    _NODISCARD constexpr const extents_type& extents() const noexcept {
        return _Myext;
    }

    _NODISCARD constexpr index_type required_span_size() const noexcept {
        index_type _Result = 1;
        for (rank_type _Dim = 0; _Dim < _Extents::rank(); ++_Dim) {
            _Result *= _Myext.extent(_Dim);
        }

        return _Result;
    }

    template <class... _Indices,
        enable_if_t<sizeof...(_Indices) == _Extents::rank() && (is_convertible_v<_Indices, index_type> && ...)
                        && (is_nothrow_constructible_v<index_type, _Indices> && ...),
            int> = 0>
    _NODISCARD constexpr index_type operator()(_Indices... _Idx) const noexcept {
        return _Index_impl<conditional_t<true, index_type, _Indices>...>(
            static_cast<index_type>(_Idx)..., make_index_sequence<_Extents::rank()>{});
    }

    _NODISCARD static constexpr bool is_always_unique() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_always_exhaustive() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_always_strided() noexcept {
        return true;
    }

    _NODISCARD constexpr bool is_unique() const noexcept {
        return true;
    }

    _NODISCARD constexpr bool is_exhaustive() const noexcept {
        return true;
    }

    _NODISCARD constexpr bool is_strided() const noexcept {
        return true;
    }

    template <class _Ext = _Extents, enable_if_t<(_Ext::rank() > 0), int> = 0>
    _NODISCARD constexpr index_type stride(const rank_type _Rank) const noexcept {
        index_type _Result = 1;
        for (rank_type _Dim = _Rank + 1; _Dim < _Extents::rank(); ++_Dim) {
            _Result *= _Myext.extent(_Dim);
        }

        return _Result;
    }

    template <class _OtherExtents>
    _NODISCARD_FRIEND constexpr bool operator==(const mapping& _Left, const mapping<_OtherExtents>& _Right) noexcept {
        return _Left.extents() == _Right.extents();
    }

private:
    _Extents _Myext{};

    static constexpr size_t _Multiply(size_t _X, size_t _Y) {
        return _X * _Y;
    }

    template <class... _IndexType, size_t... _Seq>
    constexpr index_type _Index_impl(_IndexType... _Idx, index_sequence<_Seq...>) const noexcept {
        index_type _Result = 0;
        ((void) (_Result = _Idx + _Myext.extent(_Seq) * _Result), ...);
        return _Result;
    }
};

template <class _Extents>
class layout_stride::mapping {
public:
    using extents_type = _Extents;
    using index_type   = typename _Extents::index_type;
    using size_type    = typename _Extents::size_type;
    using rank_type    = typename _Extents::rank_type;
    using layout_type  = layout_stride;

    static_assert(_Is_extents<_Extents>,
        "Extents must be a specialization of std::extents (N4928 [mdspan.layout.stride.overview]/2).");
    static_assert(_Extents::_Is_index_space_size_representable(),
        "If Extents::rank_dynamic() == 0 is true, then the size of the multidimensional index space Extents() must be "
        "representable as a value of type typename Extents::index_type.");

    constexpr mapping() noexcept               = default;
    constexpr mapping(const mapping&) noexcept = default;

    template <class _OtherIndexType, enable_if_t<is_convertible_v<_OtherIndexType, index_type>, int> = 0>
    constexpr mapping(const _Extents& _E_, const array<_OtherIndexType, _Extents::rank()>& _S_) noexcept : _Myext{_E_} {
        for (rank_type _Idx = 0; _Idx < _Extents::rank(); ++_Idx) {
            _Mystrides[_Idx] = _S_[_Idx];
        }
    };

    template <class _OtherIndexType, enable_if_t<is_convertible_v<_OtherIndexType, index_type>, int> = 0>
    constexpr mapping(const _Extents& _E_, const span<_OtherIndexType, _Extents::rank()> _S_) noexcept : _Myext{_E_} {
        for (rank_type _Idx = 0; _Idx < _Extents::rank(); ++_Idx) {
            _Mystrides[_Idx] = _S_[_Idx];
        }
    };

    template <class _OtherExtents, enable_if_t<is_constructible_v<_Extents, _OtherExtents>, int> = 0>
    constexpr explicit(!is_convertible_v<_OtherExtents, _Extents>)
        mapping(const mapping<_OtherExtents>& _Other) noexcept
        : _Myext{_Other.extents()}, _Mystrides{_Other.strides()} {
        for (rank_type _Idx = 0; _Idx < _Extents::rank(); ++_Idx) {
            _Mystrides[_Idx] = _Other.stride(_Idx);
        }
    }

    template <class _StridedLayoutMapping,
        enable_if_t<_Layout_mapping_alike<_StridedLayoutMapping>::value
                        && is_constructible_v<extents_type, typename _StridedLayoutMapping::extents_type>
                        && _StridedLayoutMapping::is_always_unique() && _StridedLayoutMapping::is_always_strided(),
            int> = 0>
    constexpr explicit(
        !is_convertible_v<typename _StridedLayoutMapping::extents_type, extents_type>
        && (_Is_mapping_of<layout_left, _StridedLayoutMapping> || _Is_mapping_of<layout_right, _StridedLayoutMapping>
            || _Is_mapping_of<layout_stride, _StridedLayoutMapping>) )
        mapping(const _StridedLayoutMapping& _Other) noexcept
        : _Myext(_Other.extents()) {
        for (rank_type _Dim = 0; _Dim < _Extents::rank(); ++_Dim) {
            _Mystrides[_Dim] = _Other.stride(_Dim);
        }
    }

    constexpr mapping& operator=(const mapping&) noexcept = default;

    _NODISCARD constexpr const extents_type& extents() const noexcept {
        return _Myext;
    }

    _NODISCARD constexpr array<index_type, _Extents::rank()> strides() const noexcept {
        return _Mystrides;
    }

    _NODISCARD constexpr index_type required_span_size() const noexcept {
        if (_Extents::rank() > 0) {
            index_type _Result = 1;
            for (rank_type _Dim = 0; _Dim < _Extents::rank(); ++_Dim) {
                const auto _Ext = _Myext.extent(_Dim);
                if (_Ext == 0) {
                    return 0;
                }

                _Result += (_Ext - 1) * _Mystrides[_Dim];
            }

            return _Result;
        } else {
            return 1;
        }
    }

    template <class... _Indices,
        enable_if_t<sizeof...(_Indices) == _Extents::rank() && (is_convertible_v<_Indices, index_type> && ...)
                        && (is_nothrow_constructible_v<index_type, _Indices> && ...),
            int> = 0>
    _NODISCARD constexpr index_type operator()(_Indices... _Idx) const noexcept {
        return _Index_impl<conditional_t<true, index_type, _Indices>...>(
            static_cast<index_type>(_Idx)..., make_index_sequence<_Extents::rank()>{});
    }

    _NODISCARD static constexpr bool is_always_unique() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_always_exhaustive() noexcept {
        return false;
    }

    _NODISCARD static constexpr bool is_always_strided() noexcept {
        return true;
    }

    _NODISCARD constexpr bool is_unique() const noexcept {
        return true;
    }

    _NODISCARD constexpr bool is_exhaustive() const noexcept {
        index_type _Ext_size = 1;
        for (rank_type _Dim = 0; _Dim < _Extents::rank(); ++_Dim) {
            _Ext_size *= _Myext.extent(_Dim);
        }

        return required_span_size() == _Ext_size;
    }

    _NODISCARD constexpr bool is_strided() const noexcept {
        return true;
    }

    template <class _Ext = extents_type, enable_if_t<(_Ext::rank() > 0), int> = 0>
    _NODISCARD constexpr index_type stride(const rank_type _Idx) const noexcept {
        return _Mystrides[_Idx];
    }

    template <class _OtherMapping, enable_if_t<_Layout_mapping_alike<_OtherMapping>::value
                                                   && extents_type::rank() == _OtherMapping::extents_type::rank()
                                                   && _OtherMapping::is_always_strided(),
                                       int> = 0>
    _NODISCARD_FRIEND constexpr bool operator==(const mapping& _Left, const _OtherMapping& _Right) noexcept {
        if (_Left.extents() != _Right.extents()) {
            return false;
        }

        constexpr rank_type _Rank = extents_type::rank();
        for (rank_type _Dim = 0; _Dim < _Rank; ++_Dim) {
            if (_Left.stride(_Dim) != _Right.stride(_Dim)) {
                return false;
            }
        }

        index_type _Offset;
        if constexpr (_Rank == 0) {
            _Offset = _Right();
        } else {
            bool _Is_empty = false;
            for (rank_type _Dim = 0; _Dim < _Rank; ++_Dim) {
                if (_Left.extents().extent(_Dim) == 0) {
                    _Is_empty = true;
                    break;
                }
            }

            if (_Is_empty) {
                _Offset = 0;
            } else {
                _Offset = [&_Right]<size_t... _Idx>(index_sequence<_Idx...>) {
                    return _Right(((void) _Idx, 0)...);
                }
                (make_index_sequence<_Rank>{});
            }

            return _Offset == 0;
        }
    }

private:
    _Extents _Myext{};
    array<index_type, _Extents::rank()> _Mystrides = {};

    template <class... _IndexType, size_t... _Seq>
    constexpr index_type _Index_impl(_IndexType... _Idx, index_sequence<_Seq...>) const noexcept {
        return ((_Idx * _Mystrides[_Seq]) + ...);
    }
};

template <class _ElementType>
struct default_accessor {
    using offset_policy    = default_accessor;
    using element_type     = _ElementType;
    using reference        = _ElementType&;
    using data_handle_type = _ElementType*;

    constexpr default_accessor() noexcept = default;

    template <class _OtherElementType,
        enable_if_t<
            is_convertible_v<typename default_accessor<_OtherElementType>::element_type (*)[], _ElementType (*)[]>,
            int> = 0>
    constexpr default_accessor(default_accessor<_OtherElementType>) noexcept {}

    _NODISCARD constexpr data_handle_type offset(data_handle_type _Ptr, size_t _Idx) const noexcept {
        return _Ptr + _Idx;
    }

    _NODISCARD constexpr reference access(data_handle_type _Ptr, size_t _Idx) const noexcept {
        return _Ptr[_Idx];
    }
};

template <class _ElementType, class _Extents, class _LayoutPolicy = layout_right,
    class _AccessorPolicy = default_accessor<_ElementType>>
class mdspan {
public:
    using extents_type     = _Extents;
    using layout_type      = _LayoutPolicy;
    using accessor_type    = _AccessorPolicy;
    using mapping_type     = typename layout_type::template mapping<extents_type>;
    using element_type     = _ElementType;
    using value_type       = remove_cv_t<element_type>;
    using index_type       = typename extents_type::index_type;
    using size_type        = typename extents_type::size_type;
    using rank_type        = typename extents_type::rank_type;
    using data_handle_type = typename accessor_type::data_handle_type;
    using reference        = typename accessor_type::reference;

    static_assert(
        sizeof(_ElementType) > 0, "ElementType must be a complete type (N4928 [mdspan.mdspan.overview]/2.1).");
    static_assert(
        !is_abstract_v<_ElementType>, "ElementType cannot be an abstract type (N4928 [mdspan.mdspan.overview]/2.1).");
    static_assert(
        !is_array_v<_ElementType>, "ElementType cannot be an array type (N4928 [mdspan.mdspan.overview]/2.1).");
    static_assert(_Is_extents<_Extents>,
        "Extents must be a specialization of std::extents (N4928 [mdspan.mdspan.overview]/2.2).");
    static_assert(is_same_v<_ElementType, typename _AccessorPolicy::element_type>,
        "ElementType and typename AccessorPolicy::element_type must be the same type (N4928 "
        "[mdspan.mdspan.overview]/2.3).");

    _NODISCARD static constexpr rank_type rank() noexcept {
        return _Extents::rank();
    }

    _NODISCARD static constexpr rank_type rank_dynamic() noexcept {
        return _Extents::rank_dynamic();
    }

    _NODISCARD static constexpr size_t static_extent(const rank_type _Rank) noexcept {
        return _Extents::static_extent(_Rank);
    }

    template <class _Mapping = mapping_type,
        enable_if_t<(rank_dynamic() > 0) && is_default_constructible_v<data_handle_type>
                        && is_default_constructible_v<_Mapping> && is_default_constructible_v<accessor_type>,
            int>             = 0>
    constexpr mdspan() {}

    constexpr mdspan(const mdspan&) = default;
    constexpr mdspan(mdspan&&)      = default;

    template <class _Mapping = mapping_type,
        enable_if_t<(rank() == 0 || rank_dynamic() == 0)
                        && is_constructible_v<_Mapping, extents_type> && is_default_constructible_v<accessor_type>,
            int>             = 0>
    constexpr explicit mdspan(data_handle_type _Ptr_) : _Ptr{_STD move(_Ptr_)}, _Map{extents_type{}} {}

    template <class... _OtherIndexTypes,
        enable_if_t<((sizeof...(_OtherIndexTypes) > 0)) && (is_convertible_v<_OtherIndexTypes, index_type> && ...)
                        && (is_nothrow_constructible_v<index_type, _OtherIndexTypes> && ...)
                        //&& (sizeof...(_OtherIndexTypes) == rank() || sizeof...(_OtherIndexTypes) == rank_dynamic())
                        && is_constructible_v<mapping_type, extents_type> && is_default_constructible_v<accessor_type>,
            int> = 0>
    constexpr explicit mdspan(data_handle_type _Ptr_, _OtherIndexTypes... _Exts)
        : _Ptr{_STD move(_Ptr_)}, _Map{extents_type{static_cast<index_type>(_STD move(_Exts))...}} {}

    template <class _OtherIndexType, size_t _Size,
        enable_if_t<is_convertible_v<_OtherIndexType, index_type>
                        && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
                        && (_Size == rank() || _Size == rank_dynamic())
                        && is_constructible_v<mapping_type, _Extents> && is_default_constructible_v<accessor_type>,
            int> = 0>
    constexpr explicit(_Size != rank_dynamic()) mdspan(data_handle_type _Ptr_, span<_OtherIndexType, _Size>& _Exts)
        : _Ptr{_Ptr_}, _Map{_Extents{_Exts}} {}

    template <class _OtherIndexType, size_t _Size,
        enable_if_t<is_convertible_v<_OtherIndexType, index_type>
                        && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
                        && (_Size == rank() || _Size == rank_dynamic())
                        && is_constructible_v<mapping_type, _Extents> && is_default_constructible_v<accessor_type>,
            int> = 0>
    constexpr explicit(_Size != rank_dynamic())
        mdspan(data_handle_type _Ptr_, const array<_OtherIndexType, _Size>& _Exts)
        : _Ptr{_Ptr_}, _Map{_Extents{_Exts}} {}

    template <class _Extents2 = _Extents,
        enable_if_t<is_constructible_v<mapping_type, _Extents2> && is_default_constructible_v<accessor_type>, int> = 0>
    constexpr mdspan(data_handle_type _Ptr_, const _Extents& _Ext) : _Ptr{_Ptr_}, _Map{_Ext} {}

    template <class _Accessor = accessor_type, enable_if_t<is_default_constructible_v<_Accessor>, int> = 0>
    constexpr mdspan(data_handle_type _Ptr_, const mapping_type& _Map_) : _Ptr{_Ptr_}, _Map{_Map_} {}

    constexpr mdspan(data_handle_type _Ptr_, const mapping_type& _Map_, const accessor_type& _Acc_)
        : _Ptr{_Ptr_}, _Map{_Map_}, _Acc{_Acc_} {}

    template <class _OtherElementType, class _OtherExtents, class _OtherLayoutPolicy, class _OtherAccessor,
        enable_if_t<
            is_constructible_v<mapping_type, const typename _OtherLayoutPolicy::template mapping<_OtherExtents>&>
                && is_constructible_v<accessor_type, const _OtherAccessor&>,
            int> = 0>
    constexpr explicit(
        !is_convertible_v<const typename _OtherLayoutPolicy::template mapping<_OtherExtents>&, mapping_type>
        || !is_convertible_v<const _OtherAccessor&, accessor_type>)
        mdspan(const mdspan<_OtherElementType, _OtherExtents, _OtherLayoutPolicy, _OtherAccessor>& _Other)
        : _Ptr{_Other._Ptr}, _Map{_Other._Map}, _Acc{_Other._Acc} {
        static_assert(is_constructible_v<data_handle_type, const typename _OtherAccessor::data_handle_type&>,
            "The data_handle_type must be constructible from const typename OtherAccessor::data_handle_type& (N4928 "
            "[mdspan.mdspan.cons]/20.1).");
        static_assert(is_constructible_v<extents_type, _OtherExtents>,
            "The extents_type must be constructible from OtherExtents (N4928 [mdspan.mdspan.cons]/20.2).");
    }

    constexpr mdspan& operator=(const mdspan&) = default;
    constexpr mdspan& operator=(mdspan&&)      = default;

    // TRANSITION operator[](const _OtherIndexTypes... _Indices)
    template <class... _OtherIndexTypes,
        enable_if_t<(is_convertible_v<_OtherIndexTypes, index_type> && ...)
                        && (is_nothrow_constructible_v<index_type, _OtherIndexTypes> && ...),
            /*&& sizeof...(_OtherIndexTypes) == rank(),*/
            int> = 0>
    _NODISCARD constexpr reference operator()(const _OtherIndexTypes... _Indices) const {
        return _Acc.access(_Ptr, _Map(static_cast<index_type>(_STD move(_Indices))...));
    }

    template <class _OtherIndexType, enable_if_t<is_convertible_v<const _OtherIndexType&, index_type>, int> = 0>
    _NODISCARD constexpr reference operator[](span<_OtherIndexType, rank()> _Indices) const {
        return _Index_impl(_Indices, make_index_sequence<rank()>{});
    }

    template <class _OtherIndexType, enable_if_t<is_convertible_v<const _OtherIndexType&, index_type>, int> = 0>
    _NODISCARD constexpr reference operator[](const array<_OtherIndexType, rank()>& _Indices) const {
        return _Index_impl(_Indices, make_index_sequence<rank()>{});
    }

    _NODISCARD constexpr const extents_type& extents() const noexcept {
        return _Map.extents();
    }

    _NODISCARD constexpr const data_handle_type& data_handle() const noexcept {
        return _Ptr;
    }

    _NODISCARD constexpr const mapping_type& mapping() const noexcept {
        return _Map;
    }

    _NODISCARD constexpr const accessor_type& accessor() const noexcept {
        return _Acc;
    }

    _NODISCARD constexpr index_type extent(const rank_type _Rank) const noexcept {
        const auto& _Ext = _Map.extents();
        return _Ext.extent(_Rank);
    }

    _NODISCARD constexpr size_type size() const noexcept {
        const auto& _Ext  = _Map.extents();
        size_type _Result = 1;
        for (rank_type _Dim = 0; _Dim < rank(); ++_Dim) {
            _Result *= _Ext.extent(_Dim);
        }
        return _Result;
    }

    _NODISCARD constexpr bool empty() const noexcept {
        for (rank_type _Dim = 0; _Dim < rank(); ++_Dim) {
            if (_Map.extents().extent(_Dim) == 0) {
                return true;
            }
        }

        return false;
    }

    friend constexpr void swap(mdspan& _Left, mdspan& _Right) noexcept {
        swap(_Left._Ptr, _Right._Ptr);
        swap(_Left._Map, _Right._Map);
        swap(_Left._Acc, _Right._Acc);
    }

    _NODISCARD static constexpr bool is_always_unique() {
        return mapping_type::is_always_unique();
    }

    _NODISCARD static constexpr bool is_always_exhaustive() {
        return mapping_type::is_always_exhaustive();
    }

    _NODISCARD static constexpr bool is_always_strided() {
        return mapping_type::is_always_strided();
    }

    _NODISCARD constexpr bool is_unique() const {
        return _Map.is_unique();
    }

    _NODISCARD constexpr bool is_exhaustive() const {
        return _Map.is_exhaustive();
    }

    _NODISCARD constexpr bool is_strided() const {
        return _Map.is_strided();
    }

    _NODISCARD constexpr index_type stride(const size_t _Dim) const {
        return _Map.stride(_Dim);
    }

private:
    template <class _IndexContainer, size_t... _Idx>
    _NODISCARD constexpr reference _Index_impl(_IndexContainer&& _Indices, index_sequence<_Idx...>) const {
        return _Acc.access(_Ptr, _Map(_STD as_const(_STD forward<_IndexContainer>(_Indices)[_Idx])...));
    }

    data_handle_type _Ptr{};
    mapping_type _Map{};
    accessor_type _Acc{};
};

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _HAS_CXX23
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _MDSPAN_
