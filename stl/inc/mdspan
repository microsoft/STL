// mdspan standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _MDSPAN_
#define _MDSPAN_
#include <yvals.h>
#if _STL_COMPILER_PREPROCESSOR
#if !_HAS_CXX23 || !defined(__cpp_lib_concepts) // TRANSITION, GH-395
_EMIT_STL_WARNING(STL4038, "The contents of <mdspan> are available only with C++23 or later.");
#else // ^^^ not supported / supported language mode vvv
#include <array>
#include <span>
#include <type_traits>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN

_EXPORT_STD template <class _IndexType, size_t... _Extents>
class extents {
public:
    using index_type = _IndexType;
    using size_type  = make_unsigned_t<index_type>;
    using rank_type  = size_t;

    _NODISCARD static constexpr rank_type rank() noexcept {
        return sizeof...(_Extents);
    }

    static_assert(_Is_standard_integer<index_type>,
        "IndexType must be a signed or unsigned integer type (N4944 [mdspan.extents.overview]/1.1).");
    static_assert(((_Extents == dynamic_extent || _STD in_range<index_type>(_Extents)) && ...),
        "Each element of Extents must be either equal to dynamic_extent, or must be representable as a value of type "
        "IndexType (N4944 [mdspan.extents.overview]/1.2).");

private:
    _NODISCARD static _CONSTEVAL auto _Make_dynamic_indices() noexcept {
#pragma warning(push) // TRANSITION, "/analyze:only" BUG?
#pragma warning(disable : 28020) // The expression '0<=_Param_(1)&&_Param_(1)<=1-1' is not true at this call
        array<rank_type, rank() + 1> _Result{};
        rank_type _Counter = 0;
        for (rank_type _Idx = 0; _Idx < rank(); ++_Idx) {
            _Result[_Idx] = _Counter;
            if (_Static_extents[_Idx] == dynamic_extent) {
                ++_Counter;
            }
        }
        _Result[rank()] = _Counter;
        return _Result;
#pragma warning(pop) // TRANSITION, "/analyze:only" BUG?
    }

    static constexpr array<rank_type, rank()> _Static_extents      = {_Extents...};
    static constexpr array<rank_type, rank() + 1> _Dynamic_indices = _Make_dynamic_indices();

    _NODISCARD static constexpr rank_type _Dynamic_index(rank_type _Idx) noexcept {
        return _Dynamic_indices[_Idx];
    }

    _NODISCARD static _CONSTEVAL auto _Make_dynamic_indices_inv() noexcept {
        array<rank_type, rank()> _Result{};
        for (rank_type _Idx = 0; _Idx < rank(); ++_Idx) {
            for (rank_type _Idx_inv = 0; _Idx_inv < rank(); ++_Idx_inv) {
                if (_Dynamic_index(_Idx_inv + 1) == _Idx + 1) {
                    _Result[_Idx] = _Idx_inv;
                    break;
                }
            }
        }
        return _Result;
    }

    static constexpr array<rank_type, rank()> _Dynamic_indices_inv = _Make_dynamic_indices_inv();

    _NODISCARD static constexpr rank_type _Dynamic_index_inv(rank_type _Idx) noexcept {
        return _Dynamic_indices_inv[_Idx];
    }

    struct _Static_extents_only {
        constexpr explicit _Static_extents_only() noexcept = default;

        template <class... _Args>
        constexpr explicit _Static_extents_only(_Args&&...) noexcept {}

        _NODISCARD constexpr index_type* begin() const noexcept {
            return nullptr;
        }
    };

    static constexpr rank_type _Rank_dynamic = _Dynamic_index(rank());
    conditional_t<_Rank_dynamic != 0, array<index_type, _Rank_dynamic>, _Static_extents_only> _Dynamic_extents{};

public:
    _NODISCARD static constexpr rank_type rank_dynamic() noexcept {
        return _Rank_dynamic;
    }

    _NODISCARD static constexpr size_t static_extent(const rank_type _Idx) noexcept {
        _STL_VERIFY(_Idx < rank(), "Index must be less than rank() (N4944 [mdspan.extents.obs]/1)");
        return _Static_extents[_Idx];
    }

    _NODISCARD constexpr index_type extent(const rank_type _Idx) const noexcept {
        _STL_VERIFY(_Idx < rank(), "Index must be less than rank() (N4944 [mdspan.extents.obs]/3)");
        if constexpr (rank_dynamic() == 0) {
            return static_cast<index_type>(static_extent(_Idx));
        } else if constexpr (rank_dynamic() == rank()) {
            return _Dynamic_extents[_Idx];
        } else {
            if (static_extent(_Idx) == dynamic_extent) {
                return _Dynamic_extents[_Dynamic_index(_Idx)];
            } else {
                return static_cast<index_type>(static_extent(_Idx));
            }
        }
    }

    constexpr extents() noexcept = default;

    template <class _OtherIndexType, size_t... _OtherExtents>
        requires (sizeof...(_OtherExtents) == rank())
              && ((_OtherExtents == dynamic_extent || _Extents == dynamic_extent || _OtherExtents == _Extents) && ...)
    constexpr explicit(((_Extents != dynamic_extent && _OtherExtents == dynamic_extent) || ...)
                       || (numeric_limits<index_type>::max)() < (numeric_limits<_OtherIndexType>::max)())
        extents(const extents<_OtherIndexType, _OtherExtents...>& _Other) noexcept {
        auto _It = _Dynamic_extents.begin();
        for (rank_type _Idx = 0; _Idx < rank(); ++_Idx) {
            _STL_VERIFY(
                static_extent(_Idx) == dynamic_extent || _STD cmp_equal(static_extent(_Idx), _Other.extent(_Idx)),
                "Value of other.extent(r) must be equal to extent(r) for each r for which extent(r) is a static extent "
                "(N4944 [mdspan.extents.cons]/2.1)");
            _STL_VERIFY(_STD in_range<index_type>(_Other.extent(_Idx)),
                "Value of other.extent(r) must be representable as a value of type index_type for every rank index r "
                "(N4944 [mdspan.extents.cons]/2.2)");

            if (static_extent(_Idx) == dynamic_extent) {
                *_It = static_cast<index_type>(_Other.extent(_Idx));
                ++_It;
            }
        }
    }

    template <class... _OtherIndexTypes>
        requires (is_convertible_v<_OtherIndexTypes, index_type> && ...)
              && (is_nothrow_constructible_v<index_type, _OtherIndexTypes> && ...)
              && (sizeof...(_OtherIndexTypes) == rank_dynamic() || sizeof...(_OtherIndexTypes) == rank())
    constexpr explicit extents(_OtherIndexTypes... _Exts) noexcept {
#pragma warning(push) // TRANSITION, "/analyze:only" BUG?
#pragma warning(disable : 28020) // The expression '0<=_Param_(1)&&_Param_(1)<=1-1' is not true at this call
        if constexpr ((_Is_standard_integer<_OtherIndexTypes> && ...)) {
            _STL_VERIFY(sizeof...(_Exts) == 0 || ((_Exts >= 0 && _STD in_range<index_type>(_Exts)) && ...),
                "Either sizeof...(exts) must be equal to 0 or each element of exts must be nonnegative and must be "
                "representable as value of type index_type (N4944 [mdspan.extents.cons]/7.2)");
        }

        if constexpr (sizeof...(_Exts) == rank_dynamic()) {
            _Dynamic_extents = {static_cast<index_type>(_STD move(_Exts))...};
        } else {
            array<index_type, sizeof...(_Exts)> _Exts_arr{static_cast<index_type>(_STD move(_Exts))...};
            auto _It = _Dynamic_extents.begin();
            for (rank_type _Idx = 0; _Idx < rank(); ++_Idx) {
                _STL_VERIFY(
                    static_extent(_Idx) == dynamic_extent || _STD cmp_equal(static_extent(_Idx), _Exts_arr[_Idx]),
                    "Value of exts_arr[r] must be equal to extent(r) for each r for which extent(r) is a static extent "
                    "(N4944 [mdspan.extents.cons]/7.1)");
                if (static_extent(_Idx) == dynamic_extent) {
                    *_It = _Exts_arr[_Idx];
                    ++_It;
                }
            }
        }
#pragma warning(pop) // TRANSITION, "/analyze:only" BUG?
    }

    template <class _OtherIndexType, size_t _Size, size_t... _Indices>
        requires is_convertible_v<const _OtherIndexType&, index_type>
              && is_nothrow_constructible_v<index_type, const _OtherIndexType&> && (_Size != rank())
    constexpr explicit extents(span<_OtherIndexType, _Size> _Exts, index_sequence<_Indices...>) noexcept
        : _Dynamic_extents{static_cast<index_type>(_STD as_const(_Exts[_Indices]))...} {
        if constexpr (_Is_standard_integer<_OtherIndexType> && _Size != 0) {
            for (_OtherIndexType _Ext : _Exts) {
                _STL_VERIFY(_Ext >= 0 && _STD in_range<index_type>(_Ext),
                    "Either N must be zero or exts[r] must be nonnegative and must be representable as value of type "
                    "index_type for every rank index r (N4944 [mdspan.extents.cons]/10.2)");
            }
        }
    }

    template <class _OtherIndexType, size_t _Size, size_t... _Indices>
        requires is_convertible_v<const _OtherIndexType&, index_type>
              && is_nothrow_constructible_v<index_type, const _OtherIndexType&> && (_Size == rank())
    constexpr explicit extents(span<_OtherIndexType, _Size> _Exts, index_sequence<_Indices...>) noexcept
        : _Dynamic_extents{static_cast<index_type>(_STD as_const(_Exts[_Dynamic_index_inv(_Indices)]))...} {
        if constexpr (_Is_standard_integer<_OtherIndexType>) {
            for (rank_type _Idx = 0; _Idx < rank(); ++_Idx) {
                _STL_VERIFY(static_extent(_Idx) == dynamic_extent || _STD cmp_equal(static_extent(_Idx), _Exts[_Idx]),
                    "Value of exts[r] must be equal to extent(r) for each r for which extent(r) is a static extent "
                    "(N4944 [mdspan.extents.cons]/10.1)");
                _STL_VERIFY(_Exts[_Idx] >= 0 && _STD in_range<index_type>(_Exts[_Idx]),
                    "Either N must be zero or exts[r] must be nonnegative and must be representable as value of type "
                    "index_type for every rank index r (N4944 [mdspan.extents.cons]/10.2)");
            }
        }
    }

    template <class _OtherIndexType, size_t _Size>
        requires is_convertible_v<const _OtherIndexType&, index_type>
              && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
              && (_Size == rank_dynamic() || _Size == rank())
    constexpr explicit(_Size != rank_dynamic()) extents(span<_OtherIndexType, _Size> _Exts) noexcept
        : extents(_Exts, make_index_sequence<rank_dynamic()>{}) {}

    template <class _OtherIndexType, size_t _Size>
        requires is_convertible_v<const _OtherIndexType&, index_type>
              && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
              && (_Size == rank_dynamic() || _Size == rank())
    constexpr explicit(_Size != rank_dynamic()) extents(const array<_OtherIndexType, _Size>& _Exts) noexcept
        : extents(span{_Exts}, make_index_sequence<rank_dynamic()>{}) {}

    template <class _OtherIndexType, size_t... _OtherExtents>
    _NODISCARD_FRIEND constexpr bool operator==(
        const extents& _Left, const extents<_OtherIndexType, _OtherExtents...>& _Right) noexcept {
        if constexpr (rank() != sizeof...(_OtherExtents)) {
            return false;
        } else {
            for (rank_type _Idx = 0; _Idx < rank(); ++_Idx) {
                if (_STD cmp_not_equal(_Left.extent(_Idx), _Right.extent(_Idx))) {
                    return false;
                }
            }
            return true;
        }
    }

    _NODISCARD static _CONSTEVAL bool _Is_index_space_size_representable() {
        if constexpr (rank_dynamic() == 0 && rank() > 0) {
            return _STD in_range<index_type>((_Extents * ...));
        } else {
            return true;
        }
    }
};

#if defined(__clang__) || defined(__EDG__) // TRANSITION, REQUIRES REPORT (ICE)
template <class... _Integrals>
    requires (is_convertible_v<_Integrals, size_t> && ...)
extents(_Integrals... _Exts) -> extents<size_t, ((void) _Exts, dynamic_extent)...>;
#else // ^^^ no workaround / workaround vvv
template <class... _Integrals>
    requires (is_convertible_v<_Integrals, size_t> && ...)
extents(_Integrals...)
    -> extents<size_t, conditional_t<true, integral_constant<size_t, dynamic_extent>, _Integrals>::value...>;
#endif // ^^^ workaround ^^^

template <class _IndexType, class _Indices>
struct _Dextents_impl;

template <class _IndexType, size_t... _Indices>
struct _Dextents_impl<_IndexType, index_sequence<_Indices...>> {
    using type = extents<_IndexType, ((void) _Indices, dynamic_extent)...>;
};

_EXPORT_STD template <class _IndexType, size_t _Rank>
using dextents = typename _Dextents_impl<_IndexType, make_index_sequence<_Rank>>::type;

template <class _Ty>
inline constexpr bool _Is_extents = false;

template <class _IndexType, size_t... _Args>
inline constexpr bool _Is_extents<extents<_IndexType, _Args...>> = true;

template <class _Layout, class _Mapping>
inline constexpr bool _Is_mapping_of =
    is_same_v<typename _Layout::template mapping<typename _Mapping::extents_type>, _Mapping>;

_EXPORT_STD struct layout_left {
    template <class _Extents>
    class mapping;
};

_EXPORT_STD struct layout_right {
    template <class _Extents>
    class mapping;
};

_EXPORT_STD struct layout_stride {
    template <class _Extents>
    class mapping;
};

template <class _Extents>
class layout_left::mapping {
public:
    using extents_type = _Extents;
    using index_type   = typename extents_type::index_type;
    using size_type    = typename extents_type::size_type;
    using rank_type    = typename extents_type::rank_type;
    using layout_type  = layout_left;

    static_assert(_Is_extents<extents_type>,
        "Extents must be a specialization of std::extents (N4944 [mdspan.layout.left.overview]/2).");
    static_assert(extents_type::_Is_index_space_size_representable(),
        "If Extents::rank_dynamic() == 0 is true, then the size of the multidimensional index space Extents() must be "
        "representable as a value of type typename Extents::index_type (N4944 [mdspan.layout.left.overview]/4).");

    constexpr mapping() noexcept               = default;
    constexpr mapping(const mapping&) noexcept = default;

    constexpr mapping(const extents_type& _Exts_) noexcept : _Exts(_Exts_) {}

    template <class _OtherExtents>
        requires is_constructible_v<extents_type, _OtherExtents>
    constexpr explicit(!is_convertible_v<_OtherExtents, extents_type>)
        mapping(const mapping<_OtherExtents>& _Other) noexcept
        : _Exts(_Other.extents()) {}

    template <class _OtherExtents>
        requires (extents_type::rank() <= 1) && is_constructible_v<extents_type, _OtherExtents>
    constexpr explicit(!is_convertible_v<_OtherExtents, extents_type>)
        mapping(const layout_right::mapping<_OtherExtents>& _Other) noexcept
        : _Exts(_Other.extents()) {}

    template <class _OtherExtents>
        requires is_constructible_v<extents_type, _OtherExtents>
    constexpr explicit(extents_type::rank() > 0) mapping(const layout_stride::template mapping<_OtherExtents>& _Other)
        : _Exts(_Other.extents()) {}

    constexpr mapping& operator=(const mapping&) noexcept = default;

    _NODISCARD constexpr const extents_type& extents() const noexcept {
        return _Exts;
    }

    _NODISCARD constexpr index_type required_span_size() const noexcept {
        index_type _Result = 1;
        for (rank_type _Dim = 0; _Dim < extents_type::rank(); ++_Dim) {
            _Result *= _Exts.extent(_Dim);
        }
        return _Result;
    }

    template <class... _Indices>
        requires (sizeof...(_Indices) == extents_type::rank()) && (is_convertible_v<_Indices, index_type> && ...)
              && (is_nothrow_constructible_v<index_type, _Indices> && ...)
    _NODISCARD constexpr index_type operator()(_Indices... _Idx) const noexcept {
        return _Index_impl<conditional_t<true, index_type, _Indices>...>(
            static_cast<index_type>(_Idx)..., make_index_sequence<extents_type::rank()>{});
    }

    _NODISCARD static constexpr bool is_always_unique() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_always_exhaustive() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_always_strided() noexcept {
        return true;
    }

    _NODISCARD constexpr bool is_unique() const noexcept {
        return true;
    }

    _NODISCARD constexpr bool is_exhaustive() const noexcept {
        return true;
    }

    _NODISCARD constexpr bool is_strided() const noexcept {
        return true;
    }

    _NODISCARD constexpr index_type stride(const rank_type _Rank) const noexcept
        requires (extents_type::rank() > 0)
    {
        index_type _Result = 1;
        for (rank_type _Dim = 0; _Dim < _Rank; ++_Dim) {
            _Result *= _Exts.extent(_Dim);
        }

        return _Result;
    }

    template <class _OtherExtents>
        requires (extents_type::rank() == _OtherExtents::rank())
    _NODISCARD_FRIEND constexpr bool operator==(const mapping& _Left, const mapping<_OtherExtents>& _Right) noexcept {
        return _Left.extents() == _Right.extents();
    }

private:
    extents_type _Exts{};

    template <class... _IndexType, size_t... _Seq>
    constexpr index_type _Index_impl(_IndexType... _Idx, index_sequence<_Seq...>) const noexcept {
        // return _Extents::rank() > 0 ? ((_Idx * stride(_Seq)) + ... + 0) : 0;
        index_type _Stride = 1;
        index_type _Result = 0;
        (((_Result += _Idx * _Stride), (void) (_Stride *= _Exts.extent(_Seq))), ...);
        return _Result;
    }
};

template <class _Extents>
class layout_right::mapping {
public:
    using extents_type = _Extents;
    using index_type   = typename extents_type::index_type;
    using size_type    = typename extents_type::size_type;
    using rank_type    = typename extents_type::rank_type;
    using layout_type  = layout_right;

    static_assert(_Is_extents<extents_type>,
        "Extents must be a specialization of std::extents (N4944 [mdspan.layout.right.overview]/2).");
    static_assert(extents_type::_Is_index_space_size_representable(),
        "If Extents::rank_dynamic() == 0 is true, then the size of the multidimensional index space Extents() must be "
        "representable as a value of type typename Extents::index_type (N4944 [mdspan.layout.right.overview]/4).");

    constexpr mapping() noexcept               = default;
    constexpr mapping(const mapping&) noexcept = default;

    constexpr mapping(const extents_type& _Exts_) noexcept : _Exts(_Exts_) {}

    template <class _OtherExtents>
        requires is_constructible_v<extents_type, _OtherExtents>
    constexpr explicit(!is_convertible_v<_OtherExtents, extents_type>)
        mapping(const mapping<_OtherExtents>& _Other) noexcept
        : _Exts(_Other.extents()) {}

    template <class _OtherExtents>
        requires (extents_type::rank() <= 1) && is_constructible_v<extents_type, _OtherExtents>
    constexpr explicit(!is_convertible_v<_OtherExtents, extents_type>)
        mapping(const layout_left::mapping<_OtherExtents>& _Other) noexcept
        : _Exts(_Other.extents()) {}

    template <class _OtherExtents>
        requires is_constructible_v<extents_type, _OtherExtents>
    constexpr explicit(extents_type::rank() > 0) mapping(const layout_stride::template mapping<_OtherExtents>& _Other)
        : _Exts(_Other.extents()) {}

    constexpr mapping& operator=(const mapping&) noexcept = default;

    _NODISCARD constexpr const extents_type& extents() const noexcept {
        return _Exts;
    }

    _NODISCARD constexpr index_type required_span_size() const noexcept {
        index_type _Result = 1;
        for (rank_type _Dim = 0; _Dim < extents_type::rank(); ++_Dim) {
            _Result *= _Exts.extent(_Dim);
        }
        return _Result;
    }

    template <class... _Indices>
        requires (sizeof...(_Indices) == extents_type::rank()) && (is_convertible_v<_Indices, index_type> && ...)
              && (is_nothrow_constructible_v<index_type, _Indices> && ...)
    _NODISCARD constexpr index_type operator()(_Indices... _Idx) const noexcept {
        return _Index_impl<conditional_t<true, index_type, _Indices>...>(
            static_cast<index_type>(_Idx)..., make_index_sequence<extents_type::rank()>{});
    }

    _NODISCARD static constexpr bool is_always_unique() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_always_exhaustive() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_always_strided() noexcept {
        return true;
    }

    _NODISCARD constexpr bool is_unique() const noexcept {
        return true;
    }

    _NODISCARD constexpr bool is_exhaustive() const noexcept {
        return true;
    }

    _NODISCARD constexpr bool is_strided() const noexcept {
        return true;
    }

    _NODISCARD constexpr index_type stride(const rank_type _Rank) const noexcept
        requires (extents_type::rank() > 0)
    {
        index_type _Result = 1;
        for (rank_type _Dim = _Rank + 1; _Dim < extents_type::rank(); ++_Dim) {
            _Result *= _Exts.extent(_Dim);
        }

        return _Result;
    }

    template <class _OtherExtents>
        requires (extents_type::rank() == _OtherExtents::rank())
    _NODISCARD_FRIEND constexpr bool operator==(const mapping& _Left, const mapping<_OtherExtents>& _Right) noexcept {
        return _Left.extents() == _Right.extents();
    }

private:
    extents_type _Exts{};

    template <class... _IndexType, size_t... _Seq>
    constexpr index_type _Index_impl(_IndexType... _Idx, index_sequence<_Seq...>) const noexcept {
        index_type _Result = 0;
        ((void) (_Result = _Idx + _Exts.extent(_Seq) * _Result), ...);
        return _Result;
    }
};

template <class _Mp>
concept _Layout_mapping_alike = requires {
                                    requires _Is_extents<typename _Mp::extents_type>;
                                    { _Mp::is_always_strided() } -> same_as<bool>;
                                    { _Mp::is_always_exhaustive() } -> same_as<bool>;
                                    { _Mp::is_always_unique() } -> same_as<bool>;
                                    bool_constant<_Mp::is_always_strided()>::value;
                                    bool_constant<_Mp::is_always_exhaustive()>::value;
                                    bool_constant<_Mp::is_always_unique()>::value;
                                };

template <class _Extents>
class layout_stride::mapping {
public:
    using extents_type = _Extents;
    using index_type   = typename extents_type::index_type;
    using size_type    = typename extents_type::size_type;
    using rank_type    = typename extents_type::rank_type;
    using layout_type  = layout_stride;

    static_assert(_Is_extents<extents_type>,
        "Extents must be a specialization of std::extents (N4944 [mdspan.layout.stride.overview]/2).");
    static_assert(extents_type::_Is_index_space_size_representable(),
        "If Extents::rank_dynamic() == 0 is true, then the size of the multidimensional index space Extents() must be "
        "representable as a value of type typename Extents::index_type (N4944 [mdspan.layout.stride.overview]/4).");

    constexpr mapping() noexcept               = default;
    constexpr mapping(const mapping&) noexcept = default;

#ifndef __clang__ // TRANSITION, MSVC messes up CTAD when concepts are used here (needs further investigation)
    template <class _OtherIndexType, enable_if_t<is_convertible_v<const _OtherIndexType&, index_type>
                                                     && is_nothrow_constructible_v<index_type, const _OtherIndexType&>,
                                         int> = 0>
#else // ^^^ workaround / no workaround vvv
    template <class _OtherIndexType>
        requires is_convertible_v<const _OtherIndexType&, index_type>
              && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
#endif // ^^^ no workaround ^^^
    constexpr mapping(const extents_type& _Exts_, const span<_OtherIndexType, extents_type::rank()> _Strides_) noexcept
        : _Exts{_Exts_} {
        for (rank_type _Idx = 0; _Idx < extents_type::rank(); ++_Idx) {
            _Strides[_Idx] = _Strides_[_Idx];
        }
    };

#ifndef __clang__ // TRANSITION, MSVC messes up CTAD when concepts are used here (needs further investigation)
    template <class _OtherIndexType, enable_if_t<is_convertible_v<const _OtherIndexType&, index_type>
                                                     && is_nothrow_constructible_v<index_type, const _OtherIndexType&>,
                                         int> = 0>
#else // ^^^ workaround / no workaround vvv
    template <class _OtherIndexType>
        requires is_convertible_v<const _OtherIndexType&, index_type>
              && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
#endif // ^^^ no workaround ^^^
    constexpr mapping(
        const extents_type& _Exts_, const array<_OtherIndexType, extents_type::rank()>& _Strides_) noexcept
        : _Exts{_Exts_} {
        for (rank_type _Idx = 0; _Idx < extents_type::rank(); ++_Idx) {
            _Strides[_Idx] = _Strides_[_Idx];
        }
    };

    template <class _StridedLayoutMapping>
        requires _Layout_mapping_alike<_StridedLayoutMapping>
              && is_constructible_v<extents_type, typename _StridedLayoutMapping::extents_type>
              && (_StridedLayoutMapping::is_always_unique()) && (_StridedLayoutMapping::is_always_strided())
    constexpr explicit(!(
        is_convertible_v<typename _StridedLayoutMapping::extents_type, extents_type>
        && (_Is_mapping_of<layout_left, _StridedLayoutMapping> || _Is_mapping_of<layout_right, _StridedLayoutMapping>
            || _Is_mapping_of<layout_stride, _StridedLayoutMapping>) ))
        mapping(const _StridedLayoutMapping& _Other) noexcept
        : _Exts(_Other.extents()) {
        for (rank_type _Dim = 0; _Dim < extents_type::rank(); ++_Dim) {
            _Strides[_Dim] = _Other.stride(_Dim);
        }
    }

    constexpr mapping& operator=(const mapping&) noexcept = default;

    _NODISCARD constexpr const extents_type& extents() const noexcept {
        return _Exts;
    }

    _NODISCARD constexpr array<index_type, extents_type::rank()> strides() const noexcept {
        return _Strides;
    }

    _NODISCARD constexpr index_type required_span_size() const noexcept {
        if (extents_type::rank() > 0) {
            index_type _Result = 1;
            for (rank_type _Dim = 0; _Dim < extents_type::rank(); ++_Dim) {
                const auto _Ext = _Exts.extent(_Dim);
                if (_Ext == 0) {
                    return 0;
                }

                _Result += (_Ext - 1) * _Strides[_Dim];
            }

            return _Result;
        } else {
            return 1;
        }
    }

    template <class... _Indices>
        requires (sizeof...(_Indices) == extents_type::rank()) && (is_convertible_v<_Indices, index_type> && ...)
              && (is_nothrow_constructible_v<index_type, _Indices> && ...)
    _NODISCARD constexpr index_type operator()(_Indices... _Idx) const noexcept {
        return _Index_impl<conditional_t<true, index_type, _Indices>...>(
            static_cast<index_type>(_Idx)..., make_index_sequence<extents_type::rank()>{});
    }

    _NODISCARD static constexpr bool is_always_unique() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool is_always_exhaustive() noexcept {
        return false;
    }

    _NODISCARD static constexpr bool is_always_strided() noexcept {
        return true;
    }

    _NODISCARD constexpr bool is_unique() const noexcept {
        return true;
    }

    _NODISCARD constexpr bool is_exhaustive() const noexcept {
        index_type _Ext_size = 1;
        for (rank_type _Dim = 0; _Dim < extents_type::rank(); ++_Dim) {
            _Ext_size *= _Exts.extent(_Dim);
        }

        return required_span_size() == _Ext_size;
    }

    _NODISCARD constexpr bool is_strided() const noexcept {
        return true;
    }

    _NODISCARD constexpr index_type stride(const rank_type _Idx) const noexcept {
        return _Strides[_Idx];
    }

    template <class _OtherMapping>
        requires _Layout_mapping_alike<_OtherMapping> && (extents_type::rank() == _OtherMapping::extents_type::rank())
              && (_OtherMapping::is_always_strided())
    _NODISCARD_FRIEND constexpr bool operator==(const mapping& _Left, const _OtherMapping& _Right) noexcept {
        if (_Left.extents() != _Right.extents()) {
            return false;
        }

        constexpr rank_type _Rank = extents_type::rank();
        for (rank_type _Dim = 0; _Dim < _Rank; ++_Dim) {
            if (_Left.stride(_Dim) != _Right.stride(_Dim)) {
                return false;
            }
        }

        index_type _Offset;
        if constexpr (_Rank == 0) {
            _Offset = _Right();
        } else {
            bool _Is_empty = false;
            for (rank_type _Dim = 0; _Dim < _Rank; ++_Dim) {
                if (_Left.extents().extent(_Dim) == 0) {
                    _Is_empty = true;
                    break;
                }
            }

            if (_Is_empty) {
                _Offset = 0;
            } else {
                _Offset = [&_Right]<size_t... _Idx>(index_sequence<_Idx...>) {
                    return _Right(((void) _Idx, 0)...);
                }
                (make_index_sequence<_Rank>{});
            }

            return _Offset == 0;
        }
    }

private:
    extents_type _Exts{};
    array<index_type, extents_type::rank()> _Strides{};

    template <class... _IndexType, size_t... _Seq>
    constexpr index_type _Index_impl(_IndexType... _Idx, index_sequence<_Seq...>) const noexcept {
        return ((_Idx * _Strides[_Seq]) + ...);
    }
};

_EXPORT_STD template <class _ElementType>
struct default_accessor {
    using offset_policy    = default_accessor;
    using element_type     = _ElementType;
    using reference        = _ElementType&;
    using data_handle_type = _ElementType*;

    constexpr default_accessor() noexcept = default;

    template <class _OtherElementType>
        requires is_convertible_v<_OtherElementType (*)[], element_type (*)[]>
    constexpr default_accessor(default_accessor<_OtherElementType>) noexcept {}

    _NODISCARD constexpr data_handle_type offset(data_handle_type _Ptr, size_t _Idx) const noexcept {
        return _Ptr + _Idx;
    }

    _NODISCARD constexpr reference access(data_handle_type _Ptr, size_t _Idx) const noexcept {
        return _Ptr[_Idx];
    }
};

_EXPORT_STD template <class _ElementType, class _Extents, class _LayoutPolicy = layout_right,
    class _AccessorPolicy = default_accessor<_ElementType>>
class mdspan {
public:
    using extents_type     = _Extents;
    using layout_type      = _LayoutPolicy;
    using accessor_type    = _AccessorPolicy;
    using mapping_type     = typename layout_type::template mapping<extents_type>;
    using element_type     = _ElementType;
    using value_type       = remove_cv_t<element_type>;
    using index_type       = typename extents_type::index_type;
    using size_type        = typename extents_type::size_type;
    using rank_type        = typename extents_type::rank_type;
    using data_handle_type = typename accessor_type::data_handle_type;
    using reference        = typename accessor_type::reference;

    static_assert(
        sizeof(element_type) > 0, "ElementType must be a complete type (N4944 [mdspan.mdspan.overview]/2.1).");
    static_assert(
        !is_abstract_v<element_type>, "ElementType cannot be an abstract type (N4944 [mdspan.mdspan.overview]/2.1).");
    static_assert(
        !is_array_v<element_type>, "ElementType cannot be an array type (N4944 [mdspan.mdspan.overview]/2.1).");
    static_assert(_Is_extents<extents_type>,
        "Extents must be a specialization of std::extents (N4944 [mdspan.mdspan.overview]/2.2).");
    static_assert(is_same_v<element_type, typename accessor_type::element_type>,
        "ElementType and typename AccessorPolicy::element_type must be the same type (N4944 "
        "[mdspan.mdspan.overview]/2.3).");

    _NODISCARD static constexpr rank_type rank() noexcept {
        return extents_type::rank();
    }

    _NODISCARD static constexpr rank_type rank_dynamic() noexcept {
        return extents_type::rank_dynamic();
    }

    _NODISCARD static constexpr size_t static_extent(const rank_type _Rank) noexcept {
        return extents_type::static_extent(_Rank);
    }

    constexpr mdspan()
        requires (rank_dynamic() > 0) && is_default_constructible_v<data_handle_type>
              && is_default_constructible_v<mapping_type> && is_default_constructible_v<accessor_type>
    {}

    constexpr mdspan(const mdspan&) = default;
    constexpr mdspan(mdspan&&)      = default;

    template <class... _OtherIndexTypes>
        requires (is_convertible_v<_OtherIndexTypes, index_type> && ...)
                  && (is_nothrow_constructible_v<index_type, _OtherIndexTypes> && ...)
                  && (sizeof...(_OtherIndexTypes) > 0)
                  && (sizeof...(_OtherIndexTypes) == rank() || sizeof...(_OtherIndexTypes) == rank_dynamic())
                  && is_constructible_v<mapping_type, extents_type> && is_default_constructible_v<accessor_type>
    constexpr explicit mdspan(data_handle_type _Ptr_, _OtherIndexTypes... _Exts)
        : _Ptr{_STD move(_Ptr_)}, _Map{extents_type{static_cast<index_type>(_STD move(_Exts))...}} {}

    template <class _OtherIndexType, size_t _Size>
        requires is_convertible_v<_OtherIndexType, index_type>
                  && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
                  && (_Size == rank() || _Size == rank_dynamic())
                  && is_constructible_v<mapping_type, extents_type> && is_default_constructible_v<accessor_type>
    constexpr explicit(_Size != rank_dynamic()) mdspan(data_handle_type _Ptr_, span<_OtherIndexType, _Size>& _Exts)
        : _Ptr{_Ptr_}, _Map{extents_type{_Exts}} {}

    template <class _OtherIndexType, size_t _Size>
        requires is_convertible_v<const _OtherIndexType&, index_type>
                  && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
                  && (_Size == rank() || _Size == rank_dynamic())
                  && is_constructible_v<mapping_type, extents_type> && is_default_constructible_v<accessor_type>
    constexpr explicit(_Size != rank_dynamic())
        mdspan(data_handle_type _Ptr_, const array<_OtherIndexType, _Size>& _Exts)
        : _Ptr{_Ptr_}, _Map{extents_type{_Exts}} {}

    constexpr mdspan(data_handle_type _Ptr_, const extents_type& _Ext)
        requires is_constructible_v<mapping_type, const extents_type&> && is_default_constructible_v<accessor_type>
        : _Ptr{_Ptr_}, _Map{_Ext} {}

    constexpr mdspan(data_handle_type _Ptr_, const mapping_type& _Map_)
        requires is_default_constructible_v<accessor_type>
        : _Ptr{_Ptr_}, _Map{_Map_} {}

    constexpr mdspan(data_handle_type _Ptr_, const mapping_type& _Map_, const accessor_type& _Acc_)
        : _Ptr{_Ptr_}, _Map{_Map_}, _Acc{_Acc_} {}

    template <class _OtherElementType, class _OtherExtents, class _OtherLayoutPolicy, class _OtherAccessor>
        requires is_constructible_v<mapping_type, const typename _OtherLayoutPolicy::template mapping<_OtherExtents>&>
                  && is_constructible_v<accessor_type, const _OtherAccessor&>
    constexpr explicit(
        !is_convertible_v<const typename _OtherLayoutPolicy::template mapping<_OtherExtents>&, mapping_type>
        || !is_convertible_v<const _OtherAccessor&, accessor_type>)
        mdspan(const mdspan<_OtherElementType, _OtherExtents, _OtherLayoutPolicy, _OtherAccessor>& _Other)
        : _Ptr{_Other._Ptr}, _Map{_Other._Map}, _Acc{_Other._Acc} {
        static_assert(is_constructible_v<data_handle_type, const typename _OtherAccessor::data_handle_type&>,
            "The data_handle_type must be constructible from const typename OtherAccessor::data_handle_type& (N4944 "
            "[mdspan.mdspan.cons]/20.1).");
        static_assert(is_constructible_v<extents_type, _OtherExtents>,
            "The extents_type must be constructible from OtherExtents (N4944 [mdspan.mdspan.cons]/20.2).");
    }

    constexpr mdspan& operator=(const mdspan&) = default;
    constexpr mdspan& operator=(mdspan&&)      = default;

    // TRANSITION, P2128R6 (Multidimensional subscript operator)
    template <class... _OtherIndexTypes>
        requires (is_convertible_v<_OtherIndexTypes, index_type> && ...)
              && (is_nothrow_constructible_v<index_type, _OtherIndexTypes> && ...)
              && (sizeof...(_OtherIndexTypes) == rank())
    _NODISCARD constexpr reference operator()(const _OtherIndexTypes... _Indices) const {
        return _Acc.access(_Ptr, _Map(static_cast<index_type>(_STD move(_Indices))...));
    }

    template <class _OtherIndexType>
        requires is_convertible_v<const _OtherIndexType&, index_type>
              && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
    _NODISCARD constexpr reference operator[](span<_OtherIndexType, rank()> _Indices) const {
        return _Index_impl(_Indices, make_index_sequence<rank()>{});
    }

    template <class _OtherIndexType>
        requires is_convertible_v<const _OtherIndexType&, index_type>
              && is_nothrow_constructible_v<index_type, const _OtherIndexType&>
    _NODISCARD constexpr reference operator[](const array<_OtherIndexType, rank()>& _Indices) const {
        return _Index_impl(_Indices, make_index_sequence<rank()>{});
    }

    _NODISCARD constexpr const extents_type& extents() const noexcept {
        return _Map.extents();
    }

    _NODISCARD constexpr const data_handle_type& data_handle() const noexcept {
        return _Ptr;
    }

    _NODISCARD constexpr const mapping_type& mapping() const noexcept {
        return _Map;
    }

    _NODISCARD constexpr const accessor_type& accessor() const noexcept {
        return _Acc;
    }

    _NODISCARD constexpr index_type extent(const rank_type _Rank) const noexcept {
        const auto& _Ext = _Map.extents();
        return _Ext.extent(_Rank);
    }

    _NODISCARD constexpr size_type size() const noexcept {
        const auto& _Ext  = _Map.extents();
        size_type _Result = 1;
        for (rank_type _Dim = 0; _Dim < rank(); ++_Dim) {
            _Result *= _Ext.extent(_Dim);
        }
        return _Result;
    }

    _NODISCARD constexpr bool empty() const noexcept {
        for (rank_type _Dim = 0; _Dim < rank(); ++_Dim) {
            if (_Map.extents().extent(_Dim) == 0) {
                return true;
            }
        }

        return false;
    }

    friend constexpr void swap(mdspan& _Left, mdspan& _Right) noexcept {
        swap(_Left._Ptr, _Right._Ptr);
        swap(_Left._Map, _Right._Map);
        swap(_Left._Acc, _Right._Acc);
    }

    _NODISCARD static constexpr bool is_always_unique() {
        return mapping_type::is_always_unique();
    }

    _NODISCARD static constexpr bool is_always_exhaustive() {
        return mapping_type::is_always_exhaustive();
    }

    _NODISCARD static constexpr bool is_always_strided() {
        return mapping_type::is_always_strided();
    }

    _NODISCARD constexpr bool is_unique() const {
        return _Map.is_unique();
    }

    _NODISCARD constexpr bool is_exhaustive() const {
        return _Map.is_exhaustive();
    }

    _NODISCARD constexpr bool is_strided() const {
        return _Map.is_strided();
    }

    _NODISCARD constexpr index_type stride(const size_t _Dim) const {
        return _Map.stride(_Dim);
    }

private:
    template <class _IndexContainer, size_t... _Idx>
    _NODISCARD constexpr reference _Index_impl(_IndexContainer&& _Indices, index_sequence<_Idx...>) const {
        return _Acc.access(_Ptr, _Map(_STD as_const(_STD forward<_IndexContainer>(_Indices)[_Idx])...));
    }

    data_handle_type _Ptr{};
    mapping_type _Map{};
    accessor_type _Acc{};
};

template <class _CArray>
    requires (is_array_v<_CArray> && rank_v<_CArray> == 1)
mdspan(_CArray&) -> mdspan<remove_all_extents_t<_CArray>, extents<size_t, extent_v<_CArray, 0>>>;

template <class _Pointer>
    requires (is_pointer_v<remove_reference_t<_Pointer>>)
mdspan(_Pointer&&) -> mdspan<remove_pointer_t<remove_reference_t<_Pointer>>, extents<size_t>>;

template <class _ElementType, class... _Integrals>
    requires ((is_convertible_v<_Integrals, size_t> && ...) && sizeof...(_Integrals) > 0)
explicit mdspan(_ElementType*, _Integrals...) -> mdspan<_ElementType, dextents<size_t, sizeof...(_Integrals)>>;

template <class _ElementType, class _OtherIndexType, size_t _Nx>
mdspan(_ElementType*, span<_OtherIndexType, _Nx>) -> mdspan<_ElementType, dextents<size_t, _Nx>>;

template <class _ElementType, class _OtherIndexType, size_t _Nx>
mdspan(_ElementType*, const array<_OtherIndexType, _Nx>&) -> mdspan<_ElementType, dextents<size_t, _Nx>>;

template <class _ElementType, class _IndexType, size_t... _ExtentsPack>
mdspan(_ElementType*, const extents<_IndexType, _ExtentsPack...>&)
    -> mdspan<_ElementType, extents<_IndexType, _ExtentsPack...>>;

template <class _ElementType, class _MappingType>
mdspan(_ElementType*, const _MappingType&)
    -> mdspan<_ElementType, typename _MappingType::extents_type, typename _MappingType::layout_type>;

template <class _MappingType, class _AccessorType>
mdspan(const typename _AccessorType::data_handle_type&, const _MappingType&, const _AccessorType&)
    -> mdspan<typename _AccessorType::element_type, typename _MappingType::extents_type,
        typename _MappingType::layout_type, _AccessorType>;

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // ^^^ supported language mode ^^^
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _MDSPAN_
