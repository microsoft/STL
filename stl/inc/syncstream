// syncstream standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _SYNCSTREAM_
#define _SYNCSTREAM_
#include <yvals.h>
#if _STL_COMPILER_PREPROCESSOR
#if !_HAS_CXX20
#pragma message("The contents of <syncstream> are available only with C++20 or later.")
#else // ^^^ !_HAS_CXX20 / _HAS_CXX20 vvv
#include <memory>
#include <ostream>
#include <shared_mutex>
#include <streambuf>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#pragma push_macro("emit")
#undef new
#undef emit

_STD_BEGIN

extern "C" shared_mutex* __cdecl _Get_mutex_for_instance(void* _Ptr);
extern "C" void __cdecl _Acquire_mutex_for_instance(void* _Ptr) noexcept;
extern "C" void __cdecl _Release_mutex_for_instance(void* _Ptr) noexcept;

// CLASS TEMPLATE basic_syncbuf
template <class _Elem, class _Traits, class _Alloc>
class basic_syncbuf : public basic_streambuf<_Elem, _Traits> {
public:
    using int_type       = typename _Traits::int_type;
    using pos_type       = typename _Traits::pos_type;
    using off_type       = typename _Traits::off_type;
    using allocator_type = _Alloc;
    using streambuf_type = basic_streambuf<_Elem, _Traits>;

    using pointer   = typename allocator_traits<_Alloc>::pointer;
    using size_type = typename allocator_traits<_Alloc>::size_type;

    basic_syncbuf() = default;

    explicit basic_syncbuf(streambuf_type* _Strbuf) : basic_syncbuf(_Strbuf, _Alloc{}) {}

    basic_syncbuf(streambuf_type* _Strbuf, const _Alloc& _Al_) : _Wrapped(_Strbuf), _Al(_Al_) {
        if (_Wrapped) {
            _Acquire_mutex_for_instance(_Wrapped);
        }
        _Init();
    }

    basic_syncbuf(basic_syncbuf&& _Right) {
        _Al = _STD move(_Right._Al);
        _Assign_rv(_STD move(_Right));
    }

    ~basic_syncbuf() {
        _Emit();
        _Tidy();
    }

    basic_syncbuf& operator=(basic_syncbuf&& _Right) {
        _Emit();
        if (this != _STD addressof(_Right)) {
            _Move_assign(_STD move(_Right), _Choose_pocma<_Alloc>{});
        }
        return *this;
    }

    void swap(basic_syncbuf& _Right) noexcept {
        if (this != _STD addressof(_Right)) {
            _Pocs(_Al, _Right._Al);
            _Swap_except_al(_Right);
        }
    }

    bool emit() {
        if (!_Wrapped) {
            return false;
        }

        bool _Result                 = true;
        const size_type _Data_size   = _Get_data_size();
        const pointer _Begin_seq_ptr = pointer_traits<pointer>::pointer_to(*streambuf_type::pbase());
        if (_Data_size > 0 || _Record_sync) {
            scoped_lock _Guard(*_Get_mutex_for_instance(_Wrapped));

            if (_Data_size > 0 && _Data_size != _Wrapped->sputn(_Begin_seq_ptr, _Data_size)) {
                _Result = false;
            }

            if (_Record_sync) {
                if (_Wrapped->pubsync() == -1) {
                    _Result = false;
                }
            }
        }
        _Record_sync = false;
        streambuf_type::setp(
            _Begin_seq_ptr, pointer_traits<pointer>::pointer_to(*streambuf_type::epptr())); // reset written data
        return _Result;
    }

    _NODISCARD streambuf_type* get_wrapped() const noexcept {
        return _Wrapped;
    }

    _NODISCARD allocator_type get_allocator() const noexcept {
        return _Al;
    }

    void set_emit_on_sync(bool _Val) noexcept {
        _Emit_on_sync = _Val;
    }

protected:
    int sync() override {
        _Record_sync = true;

        if (_Emit_on_sync) {
            if (!emit()) {
                return -1;
            }
        }
        return 0;
    }

    int_type overflow(int_type _Current_elem) override {
        if (_Wrapped == nullptr) {
            return _Traits::eof();
        }
        const bool _Chk_eof = _Traits::eq_int_type(_Current_elem, _Traits::eof());
        if (_Chk_eof) {
            return _Traits::not_eof(_Current_elem);
        }

        const size_type _Buf_size       = _Get_buffer_size();
        const size_type _Max_allocation = allocator_traits<_Alloc>::max_size(_Al);
        if (_Buf_size == _Max_allocation) {
            return _Traits::eof();
        }

        const size_type _New_capacity  = _Calculate_growth(_Buf_size, _Buf_size + 1, _Max_allocation);
        const pointer _Old_ptr         = pointer_traits<pointer>::pointer_to(*streambuf_type::pbase());
        const size_type _Old_data_size = _Get_data_size();

        const pointer _New_ptr = _Al.allocate(_New_capacity);
        _Traits::copy(_New_ptr, _Old_ptr, _Old_data_size);

        streambuf_type::setp(_New_ptr, _New_ptr + _Old_data_size, _New_ptr + _New_capacity);
        streambuf_type::sputc(_Traits::to_char_type(_Current_elem));

        return _Current_elem;
    }

private:
    static constexpr size_type _Min_size = 32; // constant for minimum buffer size

    void _Init() {
        const pointer _New_ptr = _Al.allocate(_Min_size);
        streambuf_type::setp(_New_ptr, _New_ptr + _Min_size);
    }

    void _Tidy() noexcept {
        const size_type _Buf_size = _Get_buffer_size();
        _Al.deallocate(pointer_traits<pointer>::pointer_to(*streambuf_type::pbase()), _Buf_size);

        streambuf_type::setp(nullptr, nullptr, nullptr);
        if (_Wrapped != nullptr) {
            _Release_mutex_for_instance(_Wrapped);
            _Wrapped = nullptr;
        }
    }

    void _Assign_rv(basic_syncbuf&& _Right) {
        if (this != _STD addressof(_Right)) {
            _Tidy();
            this->_Swap_except_al(_Right);
        }
    }

    void _Move_assign(basic_syncbuf&& _Right, _Equal_allocators) noexcept {
        _Tidy();
        _Pocma(_Al, _Right._Al);
        this->_Swap_except_al(_Right);
    }

    void _Move_assign(basic_syncbuf&& _Right, _Propagate_allocators) noexcept {
        _Tidy();
        _Pocma(_Al, _Right._Al);
        this->_Swap_except_al(_Right);
    }

    void _Move_assign(basic_syncbuf&& _Right, _No_propagate_allocators) {
        if (_Al == _Right._Al) {
            _Move_assign(_Right, _Equal_allocators{});
        } else {
            const size_type _Right_buf_size  = _Right._Get_buffer_size();
            const size_type _Right_data_size = _Right._Get_data_size();

            const pointer _New_ptr = _Al.allocate(_Right_buf_size);
            _Traits::copy(_New_ptr, pointer_traits<pointer>::pointer_to(*_Right.pbase()), _Right_data_size);

            streambuf_type::setp(_New_ptr, _New_ptr + _Right_data_size, _New_ptr + _Right_buf_size);
            streambuf_type::_Plocale = _STD move(_Right._Plocale);

            _Right._Tidy();
        }
    }

    void _Swap_except_al(basic_syncbuf& _Right) noexcept {
        streambuf_type::swap(_Right);
        _STD swap(_Emit_on_sync, _Right._Emit_on_sync);
        _STD swap(_Record_sync, _Right._Record_sync);
        _STD swap(_Wrapped, _Right._Wrapped);
    }

    bool _Emit() noexcept {
        _TRY_BEGIN
        return emit();
        _CATCH_ALL
        return false;
        _CATCH_END
    }

    _NODISCARD constexpr size_type _Calculate_growth(
        const size_type _Oldsize, const size_type _Newsize, const size_type _Maxsize) const {
        if (_Oldsize > _Maxsize - _Oldsize / 2) {
            return _Maxsize; // geometric growth would overflow
        }

        const size_type _Geometric = _Oldsize + _Oldsize / 2;

        if (_Geometric < _Newsize) {
            return _Newsize; // geometric growth would be insufficient
        }

        return _Geometric; // geometric growth is sufficient
    }

    _NODISCARD constexpr size_type _Get_data_size() const noexcept {
        return static_cast<size_type>(streambuf_type::pptr() - streambuf_type::pbase());
    }

    _NODISCARD constexpr size_type _Get_buffer_size() const noexcept {
        return static_cast<size_type>(streambuf_type::epptr() - streambuf_type::pbase());
    }

    streambuf_type* _Wrapped{nullptr};
    allocator_type _Al{};
    bool _Emit_on_sync{false};
    bool _Record_sync{false};
};

template <class _Elem, class _Traits, class _Alloc>
void swap(basic_syncbuf<_Elem, _Traits, _Alloc>& _Left, basic_syncbuf<_Elem, _Traits, _Alloc>& _Right) {
    _Left.swap(_Right);
}

template <class _Elem, class _Traits, class _Alloc>
class basic_osyncstream : public basic_ostream<_Elem, _Traits> {
public:
    using char_type      = _Elem;
    using int_type       = typename _Traits::int_type;
    using pos_type       = typename _Traits::pos_type;
    using off_type       = typename _Traits::off_type;
    using traits_type    = _Traits;
    using allocator_type = _Alloc;
    using streambuf_type = basic_streambuf<_Elem, _Traits>;
    using syncbuf_type   = basic_syncbuf<_Elem, _Traits, _Alloc>;

    using _Mybase = basic_ostream<_Elem, _Traits>;

    basic_osyncstream(streambuf_type* _Strbuf, const _Alloc& _Al)
        : _Mybase(_STD addressof(_Sync_buf)), _Sync_buf(_Strbuf, _Al) {}

    explicit basic_osyncstream(streambuf_type* _Strbuf) : basic_osyncstream(_Strbuf, _Alloc{}) {}

    basic_osyncstream(basic_ostream<_Elem, _Traits>& _Str, const _Alloc& _Al) : basic_osyncstream(_Str.rdbuf(), _Al) {}

    explicit basic_osyncstream(basic_ostream<_Elem, _Traits>& _Str) : basic_osyncstream(_Str, _Alloc{}) {}

    basic_osyncstream(basic_osyncstream&& _Right) noexcept
        : _Mybase(_STD move(_Right)), _Sync_buf(_STD move(_Right._Sync_buf)) {
        _Mybase::set_rdbuf(_STD addressof(_Sync_buf));
    }

    ~basic_osyncstream() = default;

    basic_osyncstream& operator=(basic_osyncstream&&) noexcept = default;

    void emit() {
        if (!_Sync_buf.emit()) {
            _Mybase::setstate(ios::badbit);
        }
    }
    _NODISCARD streambuf_type* get_wrapped() const noexcept {
        return _Sync_buf.get_wrapped();
    }
    _NODISCARD syncbuf_type* rdbuf() const noexcept {
        return const_cast<syncbuf_type*>(_STD addressof(_Sync_buf));
    }

private:
    syncbuf_type _Sync_buf;
};

_STD_END

#pragma pop_macro("emit")
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _HAS_CXX20
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _SYNCSTREAM_
