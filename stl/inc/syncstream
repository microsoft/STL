// syncstream standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _SYNCSTREAM_
#define _SYNCSTREAM_
#include <yvals.h>
#if _STL_COMPILER_PREPROCESSOR
#ifndef __cpp_lib_syncbuf
#pragma message("The contents of <syncstream> are available only with C++20 syncbuf support.")
#else // ^^^ !defined(__cpp_lib_syncbuf) / defined(__cpp_lib_syncbuf) vvv
#include <map>
#include <memory>
#include <mutex>
#include <streambuf>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#pragma push_macro("emit")
#undef new
#undef emit

_STD_BEGIN
struct _Basic_syncbuf_global_mutex {
private:
    struct _Mutex_count_pair {
        mutex _Mutex;
        uint64_t _Ref_count = 0;
    };
    static map<void*, _Mutex_count_pair>& _Get_mutex_map() noexcept {
        static map<void*, _Mutex_count_pair> _Mutex_Map;
        return _Mutex_Map;
    }
    static mutex& _Get_map_mutex() noexcept {
        static mutex _Mutex;
        return _Mutex;
    }
    static mutex& _Get_mutex_for_instance(void* _Ptr) {
        mutex& _Mutex = _Get_map_mutex();
        {
            scoped_lock _Guard(_Mutex);

            auto& _Mutex_map         = _Get_mutex_map();
            auto _Instance_mutex_itr = _Mutex_map.find(_Ptr);

            _STL_ASSERT(_Instance_mutex_itr != _Mutex_map.end(), "No mutex exists for given instance!");
            return _Instance_mutex_itr->second._Mutex;
        }
    }
    static void _Add_mutex_for_instance_or_increment(void* _Ptr) noexcept {
        mutex& _Mutex = _Get_map_mutex();
        {
            scoped_lock _Guard(_Mutex);

            auto& _Mutex_map = _Get_mutex_map();
            _Mutex_map.try_emplace(_Ptr).first->second._Ref_count++;
        }
    }
    static void _Delete_mutex_for_instance_or_decrement(void* _Ptr) noexcept {
        mutex& _Mutex = _Get_map_mutex();
        {
            scoped_lock _Guard(_Mutex);

            auto& _Mutex_map         = _Get_mutex_map();
            auto _Instance_mutex_itr = _Mutex_map.find(_Ptr);
            if (_Instance_mutex_itr == _Mutex_map.end())
                return;
            _Instance_mutex_itr->second._Ref_count--;
            if (_Instance_mutex_itr->second._Ref_count == 0) {
                _Mutex_map.erase(_Ptr);
            }
        }
    }

    template <class _Elem, class _Traits, class _Alloc>
    friend class basic_syncbuf;
};

// CLASS TEMPLATE basic_syncbuf
template <class _Elem, class _Traits, class _Alloc>
class basic_syncbuf : public basic_streambuf<_Elem, _Traits> {
public:
    using int_type       = typename _Traits::int_type;
    using pos_type       = typename _Traits::pos_type;
    using off_type       = typename _Traits::off_type;
    using allocator_type = _Alloc;
    using streambuf_type = basic_streambuf<_Elem, _Traits>;

    using pointer   = typename allocator_traits<_Alloc>::pointer;
    using size_type = typename allocator_traits<_Alloc>::size_type;

    basic_syncbuf() : basic_syncbuf(nullptr){};

    explicit basic_syncbuf(streambuf_type* _StrBuf) : basic_syncbuf(_StrBuf, _Alloc{}) {}

    basic_syncbuf(streambuf_type* _StrBuf, const _Alloc& _Al) : _Wrapped(_StrBuf), _Al(_Al) {
        if (_Wrapped != nullptr) {
            _Basic_syncbuf_global_mutex::_Add_mutex_for_instance_or_increment(static_cast<void*>(_Wrapped));
        }
        _Init();
    }

    basic_syncbuf(basic_syncbuf&& _Right) {
        _Al = _STD move(_Right._Al);
        _Assign_rv(_STD move(_Right));
    }

    ~basic_syncbuf() {
        _Emit();
        _Tidy();
    }

    basic_syncbuf& operator=(basic_syncbuf&& _Right) {
        _Emit();
        _Move_assign(_STD move(_Right), _Choose_pocma<_Alloc>{});
        return *this;
    }

    void swap(basic_syncbuf& _Right) {
        if (this != _STD addressof(_Right)) {
            _Pocs(_Getal(), _Right._Getal());
            _Swap_except_al(_Right);
        }
    }

    bool emit() {
        if (_Wrapped == nullptr) {
            return false;
        }

        bool _Result                 = true;
        const size_type _Data_size   = _Get_data_size();
        const pointer _Begin_seq_ptr = pointer_traits<pointer>::pointer_to(*streambuf_type::pbase());
        if (_Data_size > 0 || _Record_sync) {
            scoped_lock _Guard(_Basic_syncbuf_global_mutex::_Get_mutex_for_instance(static_cast<void*>(_Wrapped)));

            if (_Data_size > 0 && _Data_size != _Wrapped->sputn(_Begin_seq_ptr, _Data_size)) {
                _Result = false;
            }

            if (_Record_sync) {
                if (_Wrapped->pubsync() == -1) {
                    _Result = false;
                }
            }
        }
        _Record_sync = false;
        streambuf_type::setp(
            _Begin_seq_ptr, pointer_traits<pointer>::pointer_to(*streambuf_type::epptr())); // reset written data
        return _Result;
    }

    streambuf_type* get_wrapped() const noexcept {
        return _Wrapped;
    }

    allocator_type get_allocator() const noexcept {
        return _Getal();
    }

    void set_emit_on_sync(bool _Val) noexcept {
        _Emit_on_sync = _Val;
    }

protected:
    int sync() override {
        _Record_sync = true;

        if (_Emit_on_sync) {
            if (!emit()) {
                return -1;
            }
        }
        return 0;
    }

    int_type overflow(int_type _Current_elem) override {
        if (_Wrapped == nullptr)
            return _Traits::eof();
        const bool _Chk_eof = _Traits::eq_int_type(_Current_elem, _Traits::eof());
        if (_Chk_eof)
            return _Traits::not_eof(_Current_elem);

        const size_type _Buf_size       = _Get_buffer_size();
        const size_type _Max_allocation = allocator_traits<_Alloc>::max_size(_Al);
        if (_Buf_size == _Max_allocation)
            return _Traits::eof();

        const size_type _New_capacity  = _Calculate_growth(_Buf_size, _Buf_size + 1, _Max_allocation);
        const pointer _Old_ptr         = pointer_traits<pointer>::pointer_to(*streambuf_type::pbase());
        const size_type _Old_data_size = _Get_data_size();

        const pointer _New_ptr = _Unfancy(_Al.allocate(_New_capacity));
        _Traits::copy(_New_ptr, _Old_ptr, _Old_data_size);

        streambuf_type::setp(_New_ptr, _New_ptr + _Old_data_size, _New_ptr + _New_capacity);
        streambuf_type::sputc(_Current_elem);

        return _Current_elem;
    }

private:
    enum { // constant for minimum buffer size
        _MINSIZE = 32
    };

    void _Init() {
        const pointer _New_ptr = _Unfancy(_Al.allocate(_MINSIZE));
        streambuf_type::setp(_New_ptr, _New_ptr + _MINSIZE);
    }

    void _Tidy() noexcept {
        const size_type _Buf_size = _Get_buffer_size();
        _Al.deallocate(pointer_traits<pointer>::pointer_to(*streambuf_type::pbase()), _Buf_size);

        streambuf_type::setp(nullptr, nullptr, nullptr);
        if (_Wrapped != nullptr) {
            _Basic_syncbuf_global_mutex::_Delete_mutex_for_instance_or_decrement(static_cast<void*>(_Wrapped));
            _Wrapped = nullptr;
        }
    }

    void _Assign_rv(basic_syncbuf&& _Right) {
        if (this != _STD addressof(_Right)) {
            _Tidy();
            this->_Swap_except_al(_Right);
        }
    }

    void _Move_assign(basic_syncbuf&& _Right, _Equal_allocators) noexcept {
        _Tidy();
        _Pocma(_Getal(), _Right._Getal());
        this->_Swap_except_al(_Right);
    }

    void _Move_assign(basic_syncbuf&& _Right, _Propagate_allocators) noexcept {
        _Tidy();
        _Pocma(_Getal(), _Right._Getal());
        this->_Swap_except_al(_Right);
    }

    void _Move_assign(basic_syncbuf&& _Right, _No_propagate_allocators) {
        if (_Getal() == _Right._Getal()) {
            _Move_assign(_Right, _Equal_allocators{});
        } else {
            const size_type _Right_Buf_size  = _Right._Get_buffer_size();
            const size_type _Right_Data_size = _Right._Get_data_size();

            const pointer _New_ptr = _Unfancy(_Al.allocate(_Right_Buf_size));
            _Traits::copy(_New_ptr, pointer_traits<pointer>::pointer_to(*_Right.pbase()), _Right_Data_size);

            streambuf_type::setp(_New_ptr, _New_ptr + _Right_Data_size, _New_ptr + _Right_Buf_size);
            streambuf_type::_Plocale = _STD move(_Right._Plocale);

            _Right._Tidy();
        }
    }

    void _Swap_except_al(basic_syncbuf& _Right) {
        streambuf_type::swap(_Right);
        _STD swap(_Emit_on_sync, _Right._Emit_on_sync);
        _STD swap(_Record_sync, _Right._Record_sync);
        _STD swap(_Wrapped, _Right._Wrapped);
    }

    bool _Emit() noexcept {
        _TRY_BEGIN
        return emit();
        _CATCH_ALL
        _CATCH_END
    }

    constexpr size_type _Calculate_growth(
        const size_type _Oldsize, const size_type _Newsize, const size_type _Maxsize) const {
        if (_Oldsize > _Maxsize - _Oldsize / 2) {
            return _Maxsize; // geometric growth would overflow
        }

        const size_type _Geometric = _Oldsize + _Oldsize / 2;

        if (_Geometric < _Newsize) {
            return _Newsize; // geometric growth would be insufficient
        }

        return _Geometric; // geometric growth is sufficient
    }

    constexpr size_type _Get_data_size() const noexcept {
        return static_cast<size_type>(streambuf_type::pptr() - streambuf_type::pbase());
    }

    constexpr size_type _Get_buffer_size() const noexcept {
        return static_cast<size_type>(streambuf_type::epptr() - streambuf_type::pbase());
    }

    constexpr _Alloc& _Getal() noexcept {
        return _Al;
    }

    constexpr const _Alloc& _Getal() const noexcept {
        return _Al;
    }

    streambuf_type* _Wrapped = nullptr;
    allocator_type _Al;
    bool _Emit_on_sync = false;
    bool _Record_sync  = false;
};

template <class _Elem, class _Traits, class _Alloc>
void swap(basic_syncbuf<_Elem, _Traits, _Alloc>& _Left, basic_syncbuf<_Elem, _Traits, _Alloc>& _Right) {
    _Left.swap(_Right);
}

_STD_END

#pragma pop_macro("emit")
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // __cpp_lib_syncbuf
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _SYNCSTREAM_
