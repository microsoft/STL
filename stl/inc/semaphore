// semaphore standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _SEMAPHORE_
#define _SEMAPHORE_
#include <yvals.h>
#if _STL_COMPILER_PREPROCESSOR

#ifdef _M_CEE_PURE
#error <semaphore> is not supported when compiling with /clr:pure.
#endif // _M_CEE_PURE

#if !_HAS_CXX20
#pragma message("The contents of <semaphore> are available only with C++20 or later.")
#else // ^^^ !_HAS_CXX20 / _HAS_CXX20 vvv

#include <atomic>
#include <chrono>
#include <limits.h>
#include <xerrc.h>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("max")
#undef max

_EXTERN_C
[[noreturn]] void __stdcall __std_sync_error(_STD errc code);
_END_EXTERN_C


_STD_BEGIN

inline constexpr ptrdiff_t _Max_semaphore_value = (1ULL << (sizeof(ptrdiff_t) * CHAR_BIT - 1)) - 1;

template <ptrdiff_t _Least_max_value = _Max_semaphore_value>
class counting_semaphore {
public:
    [[nodiscard]] static constexpr ptrdiff_t max() noexcept {
        return _Least_max_value; // use least_max value as actual max value
    }

    constexpr explicit counting_semaphore(const ptrdiff_t _Desired) noexcept /* strengthened */ : _Counter(_Desired) {}
    ~counting_semaphore() = default;

    counting_semaphore(const counting_semaphore&) = delete;
    counting_semaphore& operator=(const counting_semaphore&) = delete;

    void release(const ptrdiff_t _Update = 1) {
        if (_Update == 0) {
            return;
        }
        if (_Update < 0) {
            __std_sync_error(errc::invalid_argument);
        }
        const ptrdiff_t _Prev = _Counter.fetch_add(_Update, memory_order_release);
        if (_Prev < 0 || static_cast<size_t>(_Prev) + static_cast<size_t>(_Update) > _Least_max_value) {
            __std_sync_error(errc::state_not_recoverable);
        }
        if (_Prev == 0) {
            if (_Update == 1) {
                _Counter.notify_one();
            } else {
                _Counter.notify_all();
            }
        }
    }

    void acquire() {
        ptrdiff_t _Current = _Counter.load(memory_order_relaxed);
        for (;;) {
            if (_Current == 0) {
                _Counter.wait(0, std::memory_order_relaxed);
                _Current = _Counter.load(memory_order_relaxed);
            }
            if (_Current < 0 || _Current > _Least_max_value) {
                __std_sync_error(errc::state_not_recoverable);
            }
            if (_Counter.compare_exchange_weak(
                    _Current, _Current - 1, std::memory_order_acquire, std::memory_order_relaxed)) {
                break;
            }
        }
    }

    [[nodiscard]] bool try_acquire() noexcept {
        ptrdiff_t _Current = _Counter.load(memory_order_relaxed);
        if (_Current == 0) {
            return false;
        }
        if (_Current < 0 || _Current > _Least_max_value) {
            return false; // semaphore is broken, but we can't speak up thru noexcept
        }
        return _Counter.compare_exchange_weak(
            _Current, _Current - 1, std::memory_order_acquire, std::memory_order_relaxed);
    }

    template <class _Rep, class _Period>
    [[nodiscard]] bool try_acquire_for(const chrono::duration<_Rep, _Period>& _Rel_time) {
        auto _Rel_time_ms  = chrono::duration_cast<chrono::duration<unsigned long, milli>>(_Rel_time);
        auto _Deadline     = __std_atomic_wait_get_deadline(_Rel_time_ms.count());
        ptrdiff_t _Current = _Counter.load(memory_order_relaxed);
        for (;;) {
            while (_Current == 0) {
                const auto _Remaining_timeout = __std_atomic_wait_get_remaining_timeout(_Deadline);
                if (_Remaining_timeout == 0) {
                    return false;
                }
                __std_atomic_wait_direct(&_Counter, &_Current, sizeof(_Current), _Remaining_timeout);
                _Current = _Counter.load(memory_order_relaxed);
            }
            if (_Current < 0 || _Current > _Least_max_value) {
                __std_sync_error(errc::state_not_recoverable);
            }
            if (_Counter.compare_exchange_weak(
                    _Current, _Current - 1, std::memory_order_acquire, std::memory_order_relaxed)) {
                return true;
            }
        }
    }

    template <class _Clock, class _Duration>
    [[nodiscard]] bool try_acquire_until(const chrono::time_point<_Clock, _Duration>& _Abs_time) {
        ptrdiff_t _Current = _Counter.load(memory_order_relaxed);
        for (;;) {
            while (_Current == 0) {
                auto _Now = _Clock::now();
                if (_Now >= _Abs_time) {
                    return false;
                }

                auto _Rel_time = _Abs_time - _Now;
                chrono::duration<unsigned long, milli> _Rel_time_ms;
                static constexpr auto _Ten_days = chrono::hours(24 * 10);
                if (_Rel_time >= _Ten_days) {
                    _Rel_time_ms = _Ten_days;
                } else {
                    _Rel_time_ms = chrono::duration_cast<chrono::duration<unsigned long, milli>>(_Rel_time);
                }
                __std_atomic_wait_direct(&_Counter, &_Current, sizeof(_Current), _Rel_time_ms.count());
                _Current = _Counter.load(memory_order_relaxed);
            }
            if (_Current < 0 || _Current > _Least_max_value) {
                __std_sync_error(errc::state_not_recoverable);
            }
            if (_Counter.compare_exchange_weak(
                    _Current, _Current - 1, std::memory_order_acquire, std::memory_order_relaxed)) {
                return true;
            }
        }
    }

private:
    atomic<ptrdiff_t> _Counter;
};

template <>
class counting_semaphore<1> {
public:
    [[nodiscard]] static constexpr ptrdiff_t max() noexcept {
        return 1;
    }

    constexpr explicit counting_semaphore(const ptrdiff_t _Desired) noexcept /* strengthened */
        : _Counter(static_cast<int8_t>(_Desired != 0)) {}
    ~counting_semaphore() = default;

    counting_semaphore(const counting_semaphore&) = delete;
    counting_semaphore& operator=(const counting_semaphore&) = delete;

    void release(const ptrdiff_t _Update = 1) {
        if (_Update == 0) {
            return;
        }
        if (_Update != 1) {
            __std_sync_error(errc::invalid_argument);
        }

        _Counter.store(1, memory_order_release);
        _Counter.notify_one();
    }

    void acquire() {
        for (;;) {
            int8_t _Prev = _Counter.exchange(0, std::memory_order_acquire);
            if (_Prev == 1) {
                break;
            }
            if (_Prev != 0) {
                __std_sync_error(errc::state_not_recoverable);
            }
            _Counter.wait(0, std::memory_order_relaxed);
        }
    }

    [[nodiscard]] bool try_acquire() noexcept {
        int8_t _Prev = _Counter.exchange(0, std::memory_order_acquire);
        switch (_Prev) {
        case 0:
            return false;
        case 1:
            return true;
        default:
            __std_sync_error(errc::state_not_recoverable);
        }
    }

    template <class _Rep, class _Period>
    [[nodiscard]] bool try_acquire_for(const chrono::duration<_Rep, _Period>& _Rel_time) {
        auto _Rel_time_ms = chrono::duration_cast<chrono::duration<unsigned long long, milli>>(_Rel_time);
        auto _Deadline    = __std_atomic_wait_get_deadline(_Rel_time_ms.count());
        for (;;) {
            int8_t _Prev = _Counter.exchange(0, std::memory_order_acquire);
            if (_Prev == 1) {
                return true;
            }
            if (_Prev != 0) {
                __std_sync_error(errc::state_not_recoverable);
            }
            const auto _Remaining_timeout = __std_atomic_wait_get_remaining_timeout(_Deadline);
            if (_Remaining_timeout == 0) {
                return false;
            }
            __std_atomic_wait_direct(&_Counter, &_Prev, sizeof(_Prev), _Remaining_timeout);
        }
    }

    template <class _Clock, class _Duration>
    [[nodiscard]] bool try_acquire_until(const chrono::time_point<_Clock, _Duration>& _Abs_time) {
        for (;;) {
            int8_t _Prev = _Counter.exchange(0, std::memory_order_acquire);
            if (_Prev == 1) {
                return true;
            }
            if (_Prev != 0) {
                __std_sync_error(errc::state_not_recoverable);
            }

            auto _Now = _Clock::now();
            if (_Now >= _Abs_time) {
                return false;
            }

            auto _Rel_time = _Abs_time - _Now;
            chrono::duration<unsigned long, milli> _Rel_time_ms;
            static constexpr auto _Ten_days = chrono::hours(24 * 10);
            if (_Rel_time >= _Ten_days) {
                _Rel_time_ms = _Ten_days;
            } else {
                _Rel_time_ms = chrono::duration_cast<chrono::duration<unsigned long, milli>>(_Rel_time);
            }
            __std_atomic_wait_direct(&_Counter, &_Prev, sizeof(_Prev), _Rel_time_ms.count());
        }
    }

private:
    atomic<int8_t> _Counter;
};

using binary_semaphore = counting_semaphore<1>;

_STD_END

#pragma pop_macro("max")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // ^^^ _HAS_CXX20 ^^^

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _SEMAPHORE_
