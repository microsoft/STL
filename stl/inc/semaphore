// semaphore standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once

#ifndef _SEMAPHORE_
#define _SEMAPHORE_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR

#if !_HAS_CXX20
#pragma message("The contents of <semaphore> are available only with C++20 or later.")
#else // ^^^ !_HAS_CXX20 / _HAS_CXX20 vvv
#include <atomic>
#include <cassert>
#include <chrono>
#include <cstddef>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
template <ptrdiff_t _LeastMaxValue = 256>
class counting_semaphore {
public:
    static constexpr ptrdiff_t max() noexcept {
        // _LeastMaxValue is used here so that things such as binary_semaphore are
        return _LeastMaxValue;
    }
    constexpr explicit counting_semaphore(ptrdiff_t __desired) {
        assert(__desired >= 0 && __desired <= max());
        atomic_init(&__counter, __desired);
    }
    ~counting_semaphore()                         = default;
    counting_semaphore(const counting_semaphore&) = delete;
    counting_semaphore& operator=(const counting_semaphore&) = delete;

    void release(ptrdiff_t __update = 1) {
        assert(__update >= 0 && __update <= (max() - __counter.load())
               && "You have released this semaphore more times than you have acquired");
        __counter.fetch_add(__update, memory_order_release);
    }
    void acquire() {
        while (!try_acquire()) {
        }
    }
    bool try_acquire() noexcept {
        ptrdiff_t __old     = __counter.load(memory_order_acquire);
        ptrdiff_t __desired = __old - 1;
        if (__old > 0 && __counter.compare_exchange_strong(__old, __desired, memory_order_acquire)) {
            return true;
        }
        return false;
    }
    template <class _Rep, class _Period>
    bool try_acquire_for(const chrono::duration<_Rep, _Period>& __rel_time) {
        return try_acquire_until(chrono::steady_clock::now() + __rel_time);
    }
    template <class _Clock, class _Duration>
    bool try_acquire_until(const chrono::time_point<_Clock, _Duration>& __abs_time) {
        while (!try_acquire()) {
            if (_Clock::now() > __abs_time) {
                return false;
            }
        }
        return true;
    }

private:
    atomic_ptrdiff_t __counter;
};
using binary_semaphore = counting_semaphore<1>;
_STD_END
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif
#endif
#endif
