// flat_set standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _FLAT_SET_
#define _FLAT_SET_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR
#include <algorithm>
#include <compare>
#include <initializer_list>
#include <ranges>
#include <vector>

_STD_BEGIN

template <class, class = void>
struct _Is_transparent : false_type {};

template <class _Ty>
struct _Is_transparent<_Ty, void_t<typename _Ty::is_transparent>> : true_type {};

template <class _Kty, class _Keylt, class _Container, bool _Mfl, class _Deriv, class _Tsorted>
class _Base_flat_set {
private:
    static constexpr bool _Keylt_transparent = _Is_transparent<_Keylt>::value;

public:
    static_assert(is_same_v<_Kty, typename _Container::value_type>,
        "The C++ Standard dictates that the Key type must be the "
        "same as the container's value type [flatset.overview]");

    using key_type               = _Kty;
    using value_type             = _Kty;
    using key_compare            = _Keylt;
    using value_compare          = _Keylt;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using size_type              = typename _Container::size_type;
    using difference_type        = typename _Container::difference_type;
    using iterator               = typename _Container::iterator;
    using const_iterator         = typename _Container::const_iterator;
    using reverse_iterator       = _STD reverse_iterator<iterator>;
    using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
    using container_type         = _Container;

    static_assert(random_access_iterator<iterator>, "The C++ Standard forbids containers without random "
                                                    "access iterators from being adapted. See [flatset.overview].");

    _Base_flat_set() : _My_pair(_Zero_then_variadic_args_t{}, _Keylt()) {}

    explicit _Base_flat_set(container_type _Cont, const key_compare& _Comp = key_compare())
        : _My_pair(_One_then_variadic_args_t{}, _STD move(_Cont), _Comp) {
        _Make_invariants_fulfilled();
    }

    _Base_flat_set(_Tsorted, container_type _Cont, const key_compare& _Comp = key_compare())
        : _My_pair(_One_then_variadic_args_t{}, _STD move(_Cont), _Comp) {}

    explicit _Base_flat_set(const key_compare& _Comp) : _My_pair(_Zero_then_variadic_args_t{}, _Comp) {}

    template <class _Iter>
    _Base_flat_set(_Iter _First, _Iter _Last, const key_compare& _Comp = key_compare())
        : _Base_flat_set(container_type(_First, _Last), _Comp) {}

    template <_Container_compatible_range<_Kty> _Rng>
    _Base_flat_set(from_range_t, _Rng&& _Range, const key_compare& _Comp = key_compare())
        : _Base_flat_set(to<container_type>(_STD forward<_Rng>(_Range)), _Comp) {}

    template <class _Iter>
    _Base_flat_set(_Tsorted _S, _Iter _First, _Iter _Last, const key_compare& _Comp = key_compare())
        : _Base_flat_set(_S, container_type(_First, _Last), _Comp) {}

    _Base_flat_set(initializer_list<_Kty> _Ilist, const key_compare& _Comp = key_compare())
        : _Base_flat_set(_Ilist.begin(), _Ilist.end(), _Comp) {}

    _Base_flat_set(_Tsorted _S, initializer_list<_Kty> _Ilist, const key_compare& _Comp = key_compare())
        : _Base_flat_set(_S, _Ilist.begin(), _Ilist.end(), _Comp) {}

    template <class _Alloc, enable_if_t<uses_allocator_v<container_type, _Alloc>>>
    _Base_flat_set(const container_type& _Cont, const _Alloc& _Al) : _Base_flat_set(container_type(_Cont, _Al)) {}

    template <class _Alloc, enable_if_t<uses_allocator_v<container_type, _Alloc>>>
    _Base_flat_set(const container_type& _Cont, const key_compare& _Comp, const _Alloc& _Al)
        : _Base_flat_set(container_type(_Cont, _Al), _Comp) {}

    template <class _Alloc, enable_if_t<uses_allocator_v<container_type, _Alloc>>>
    _Base_flat_set(_Tsorted _S, const container_type& _Cont, const _Alloc& _Al)
        : _Base_flat_set(_S, container_type(_Cont, _Al)) {}

    template <class _Alloc, enable_if_t<uses_allocator_v<container_type, _Alloc>>>
    _Base_flat_set(_Tsorted _S, const container_type& _Cont, const key_compare& _Comp, const _Alloc& _Al)
        : _Base_flat_set(_S, container_type(_Cont, _Al), _Comp) {}

    template <class _Alloc, enable_if_t<uses_allocator_v<container_type, _Alloc>>>
    _Base_flat_set(const key_compare& _Comp, const _Alloc& _Al) : _Base_flat_set(_Comp, container_type(_Al)) {}

    template <class _Alloc, enable_if_t<uses_allocator_v<container_type, _Alloc>>>
    explicit _Base_flat_set(const _Alloc& _Al) : _Base_flat_set(container_type(_Al)) {}

    template <class _Iter, class _Alloc, enable_if_t<uses_allocator_v<container_type, _Alloc>>>
    _Base_flat_set(_Iter _First, _Iter _Last, const key_compare& _Comp, const _Alloc& _Al)
        : _Base_flat_set(container_type(_First, _Last, _Al), _Comp) {}

    template <class _Iter, class _Alloc, enable_if_t<uses_allocator_v<container_type, _Alloc>>>
    _Base_flat_set(_Iter _First, _Iter _Last, const _Alloc& _Al) : _Base_flat_set(container_type(_First, _Last, _Al)) {}

    template <_Container_compatible_range<_Kty> _Rng, class _Alloc,
        enable_if_t<uses_allocator_v<container_type, _Alloc>>>
    _Base_flat_set(from_range_t, _Rng&& _Range, const _Alloc& _Al)
        : _Base_flat_set(to<container_type>(_STD forward<_Rng>(_Range), _Al)) {}

    template <_Container_compatible_range<_Kty> _Rng, class _Alloc,
        enable_if_t<uses_allocator_v<container_type, _Alloc>>>
    _Base_flat_set(from_range_t, _Rng&& _Range, const key_compare& _Comp, const _Alloc& _Al)
        : _Base_flat_set(to<container_type>(_STD forward<_Rng>(_Range), _Al), _Comp) {}

    template <class _Iter, class _Alloc, enable_if_t<uses_allocator_v<container_type, _Alloc>>>
    _Base_flat_set(_Tsorted _S, _Iter _First, _Iter _Last, const key_compare& _Comp, const _Alloc& _Al)
        : _Base_flat_set(_S, container_type(_First, _Last, _Al), _Comp) {}

    template <class _Iter, class _Alloc, enable_if_t<uses_allocator_v<container_type, _Alloc>>>
    _Base_flat_set(_Tsorted _S, _Iter _First, _Iter _Last, const _Alloc& _Al)
        : _Base_flat_set(_S, container_type(_First, _Last, _Al)) {}

    template <class _Alloc, enable_if_t<uses_allocator_v<container_type, _Alloc>>>
    _Base_flat_set(initializer_list<_Kty> _Ilist, const key_compare& _Comp, const _Alloc& _Al)
        : _Base_flat_set(container_type(_Ilist.begin(), _Ilist.end(), _Al), _Comp) {}

    template <class _Alloc, enable_if_t<uses_allocator_v<container_type, _Alloc>>>
    _Base_flat_set(initializer_list<_Kty> _Ilist, const _Alloc& _Al)
        : _Base_flat_set(container_type(_Ilist.begin(), _Ilist.end(), _Al)) {}

    template <class _Alloc, enable_if_t<uses_allocator_v<container_type, _Alloc>>>
    _Base_flat_set(_Tsorted _S, initializer_list<_Kty> _Ilist, const key_compare& _Comp, const _Alloc& _Al)
        : _Base_flat_set(_S, container_type(_Ilist.begin(), _Ilist.end(), _Al), _Comp) {}

    template <class _Alloc, enable_if_t<uses_allocator_v<container_type, _Alloc>>>
    _Base_flat_set(_Tsorted _S, initializer_list<_Kty> _Ilist, const _Alloc& _Al)
        : _Base_flat_set(_S, container_type(_Ilist.begin(), _Ilist.end(), _Al)) {}

    _Deriv& operator=(initializer_list<_Kty> _Ilist) {
        _Get_cont() = container_type(_Ilist.begin(), _Ilist.end());
        _Make_invariants_fulfilled();
        return static_cast<_Deriv>(*this);
    }

    _NODISCARD iterator begin() noexcept {
        return _Get_cont().begin();
    }
    _NODISCARD const_iterator begin() const noexcept {
        return _Get_cont().begin();
    }
    _NODISCARD iterator end() noexcept {
        return _Get_cont().end();
    }
    _NODISCARD const_iterator end() const noexcept {
        return _Get_cont().end();
    }
    _NODISCARD reverse_iterator rbegin() noexcept {
        return _Get_cont().rbegin();
    }
    _NODISCARD const_reverse_iterator rbegin() const noexcept {
        return _Get_cont().rbegin();
    }
    _NODISCARD reverse_iterator rend() noexcept {
        return _Get_cont().rend();
    }
    _NODISCARD const_reverse_iterator rend() const noexcept {
        return _Get_cont().rend();
    }
    _NODISCARD const_iterator cbegin() const noexcept {
        return _Get_cont().cbegin();
    }
    _NODISCARD const_iterator cend() const noexcept {
        return _Get_cont().cend();
    }
    _NODISCARD const_reverse_iterator crbegin() const noexcept {
        return _Get_cont().crbegin();
    }
    _NODISCARD const_reverse_iterator crend() const noexcept {
        return _Get_cont().crend();
    }

    _NODISCARD_EMPTY_MEMBER bool empty() const noexcept {
        return _Get_cont().empty();
    }
    _NODISCARD size_type size() const noexcept {
        return _Get_cont().size();
    }
    _NODISCARD size_type max_size() const noexcept {
        return _Get_cont().max_size();
    }

    template <class... _Args>
    auto emplace(_Args&&... _Vals) {
        _Kty _Temp{_STD forward<_Args>(_Vals)...};
        _Container& _Cont = _Get_cont();
        iterator _End     = end();
        iterator _Where   = _STD lower_bound(begin(), _End, _Temp, _Get_comp());
        if constexpr (_Mfl) {
            return _Cont.insert(_Where, _STD move(_Temp));
        } else {
            if (_Where != _End && _Keys_equal(_Temp, *_Where)) {
                return pair{_Where, false};
            }
            return pair{_Cont.insert(_Where, _STD move(_Temp)), true};
        }
    }

    template <class... _Args>
    iterator emplace_hint(const_iterator _Where, _Args&&... _Vals) {
        _Kty _Temp{_STD forward<_Args>(_Vals)...};
        _Keylt& _Compare      = _Get_comp();
        _Container& _Cont     = _Get_cont();
        const iterator _Begin = begin();
        const iterator _End   = end();
        if (_Where == _End || _Compare(_Temp, *_Where)) {
            do {
                _Where--;
            } while (_Where != _Begin && !_Compare(*_Where, _Temp));
        } else {
            do {
                _Where++;
            } while (_Where != _End && _Compare(*_Where, _Temp));
        }

        if constexpr (_Mfl) {
            return _Cont.insert(_Where, _STD move(_Temp));
        } else {
            if (_Where == _End || !_Keys_equal(_Temp, *_Where)) {
                return _Cont.insert(_Where, _STD move(_Temp));
            }
            return _Where;
        }
    }

    auto insert(const value_type& _Val) {
        return emplace(_Val);
    }
    auto insert(value_type&& _Val) {
        return emplace(_STD move(_Val));
    }

    template <class _Other, enable_if_t<_Keylt_transparent && is_constructible_v<_Kty, _Other>>>
    auto insert(_Other&& _Val) {
        const _Container _Cont = _Get_cont();
        const iterator _End    = end();
        const iterator _Where  = _STD lower_bound(begin(), _End, _Val, _Get_comp());
        if constexpr (_Mfl) {
            return _Cont.insert(_Where, _STD forward<_Other>(_Val));
        } else {
            if (_Where != _End && _Key_other_equal(*_Where, _Val)) {
                return pair{_Where, false};
            }
            return pair{_Cont.insert(_Where, _STD forward<_Other>(_Val)), true};
        }
    }

    template <class _Other, enable_if_t<_Keylt_transparent && is_constructible_v<_Kty, _Other>>>
    iterator insert(const_iterator _Where, _Other&& _Val) {
        return emplace_hint(_Where, _STD forward<_Other>(_Val));
    }

    iterator insert(const_iterator _Where, const value_type& _Val) {
        return emplace_hint(_Where, _Val);
    }
    iterator insert(const_iterator _Where, value_type&& _Val) {
        return emplace_hint(_Where, _STD move(_Val));
    }

    template <class _Iter>
    void insert(const _Iter& _First, const _Iter& _Last) {
        _Insert_range<false>(_First, _Last);
    }

    template <class _Iter>
    void insert(_Tsorted, _Iter _First, _Iter _Last) {
        _Insert_range<true>(_First, _Last);
    }

    template <_Container_compatible_range<_Kty> _Rng>
    void insert_range(_Rng&& _Range) {
        const auto _Old_size = _STD distance(begin(), end());
        _Container& _Cont    = _Get_cont();

        // This stinks!!
        for (const auto& _Val : _Range) {
            _Cont.insert(_Cont.end(), _Val);
        }

        _Restore_invariants_after_insert<false>(_Old_size);
    }

    container_type extract() && {
        // The container NEEDS to be cleared no matter what,
        // which is not guaranteed by simply moving it away
        // ("... valid but unspecified ...")
        container_type& _Cont = _Get_cont();
        _TRY_BEGIN
        container_type _Temp = _STD move(_Cont);
        _Cont.clear();
        return _Temp;
        _CATCH_ALL
        _Cont.clear();
        _RERAISE;
        _CATCH_END
    }

    void replace(container_type&& _Cont) {
        _Get_cont() = _STD move(_Cont);
    }

    iterator erase(iterator _Where) {
        return _Get_cont().erase(_Where);
    }
    iterator erase(const_iterator _Where) {
        return _Get_cont().erase(_Where);
    }
    size_type erase(const _Kty& _Val) {
        return erase<_Kty>(_Val);
    }

    template <class _Other, enable_if_t<_Keylt_transparent || is_same_v<_Other, _Kty>>>
    size_type erase(_Other&& _Val) {
        const auto [_First, _Last] = _STD equal_range(begin(), end(), _Val, _Get_comp());

        const auto _Removed = _STD distance(_First, _Last);
        _Get_cont().erase(_First, _Last);
        return _Removed;
    }

    iterator erase(const_iterator _First, const_iterator _Last) {
        return _Get_cont().erase(_First, _Last);
    }

    void swap(_Deriv& _Other) noexcept {
        _RANGES swap(_Get_comp(), _Other._Get_comp());
        _RANGES swap(_Get_cont(), _Other._Get_cont());
    }

    void clear() noexcept {
        _Get_cont().clear();
    }

    _NODISCARD key_compare key_comp() const {
        return _Get_comp();
    }
    _NODISCARD value_compare value_comp() const {
        return _Get_comp();
    }

    _NODISCARD iterator find(const _Kty& _Val) {
        const iterator _End   = end();
        const iterator _Where = lower_bound(_Val);
        if (_Where != _End && _Keys_equal(*_Where, _Val)) {
            return _Where;
        } else {
            return _End;
        }
    }

    _NODISCARD const_iterator find(const _Kty& _Val) const {
        const const_iterator _End   = cend();
        const const_iterator _Where = lower_bound(_Val);
        if (_Where != _End && _Keys_equal(*_Where, _Val)) {
            return _Where;
        } else {
            return _End;
        }
    }

    template <class _Other, bool _Check = _Keylt_transparent, enable_if_t<_Check>>
    _NODISCARD iterator find(const _Other& _Val) {
        const iterator _End   = end();
        const iterator _Where = lower_bound(_Val);
        if (_Where != _End && _Key_other_equal(*_Where, _Val)) {
            return _Where;
        } else {
            return _End;
        }
    }

    template <class _Other, bool _Check = _Keylt_transparent, enable_if_t<_Check>>
    _NODISCARD const_iterator find(const _Other& _Val) const {
        const const_iterator _End   = cend();
        const const_iterator _Where = lower_bound(_Val);
        if (_Where != _End && _Key_other_equal(*_Where, _Val)) {
            return _Where;
        } else {
            return _End;
        }
    }

    _NODISCARD size_type count(const _Kty& _Val) const {
        return count<_Kty>(_Val);
    }

    template <class _Other, enable_if_t<_Keylt_transparent || is_same_v<_Other, _Kty>>>
    _NODISCARD size_type count(const _Other& _Val) const {
        const auto [_First, _Last] = _STD equal_range(cbegin(), cend(), _Val);
        return _STD distance(_First, _Last);
    }

    _NODISCARD bool contains(const _Kty& _Val) const {
        return find(_Val) != end();
    }
    template <class _Other, bool _Check = _Keylt_transparent, enable_if_t<_Check>>
    _NODISCARD bool contains(const _Other& _Val) const {
        return find(_Val) != end();
    }
    _NODISCARD iterator lower_bound(const _Kty& _Val) {
        return _STD lower_bound(begin(), end(), _Val, _Get_comp());
    }
    _NODISCARD const_iterator lower_bound(const _Kty& _Val) const {
        return _STD lower_bound(cbegin(), cend(), _Val, _Get_comp());
    }

    template <class _Other, bool _Check = _Keylt_transparent, enable_if_t<_Check>>
    _NODISCARD iterator lower_bound(const _Other& _Val) {
        return _STD lower_bound(begin(), end(), _Val, _Get_comp());
    }

    template <class _Other, bool _Check = _Keylt_transparent, enable_if_t<_Check>>
    _NODISCARD const_iterator lower_bound(const _Other& _Val) const {
        return _STD lower_bound(cbegin(), cend(), _Val, _Get_comp());
    }

    _NODISCARD iterator upper_bound(const _Kty& _Val) {
        return _STD upper_bound(begin(), end(), _Val, _Get_comp());
    }

    _NODISCARD const_iterator upper_bound(const _Kty& _Val) const {
        return _STD upper_bound(cbegin(), cend(), _Val, _Get_comp());
    }

    template <class _Other, bool _Check = _Keylt_transparent, enable_if_t<_Check>>
    _NODISCARD iterator upper_bound(const _Other& _Val) {
        return _STD upper_bound(begin(), end(), _Val, _Get_comp());
    }

    template <class _Other, bool _Check = _Keylt_transparent, enable_if_t<_Check>>
    _NODISCARD const_iterator upper_bound(const _Other& _Val) const {
        return _STD upper_bound(cbegin(), cend(), _Val, _Get_comp());
    }

    _NODISCARD pair<iterator, iterator> equal_range(const _Kty& _Val) {
        return _STD equal_range(begin(), end(), _Val, _Get_comp());
    }

    _NODISCARD pair<const_iterator, const_iterator> equal_range(const _Kty& _Val) const {
        return _STD equal_range(cbegin(), cend(), _Val, _Get_comp());
    }

    template <class _Other, bool _Check = _Keylt_transparent, enable_if_t<_Check>>
    _NODISCARD pair<iterator, iterator> equal_range(const _Other& _Val) {
        return _STD equal_range(begin(), end(), _Val, _Get_comp());
    }

    template <class _Other, bool _Check = _Keylt_transparent, enable_if_t<_Check>>
    _NODISCARD pair<const_iterator, const_iterator> equal_range(const _Other& _Val) const {
        return _STD equal_range(cbegin(), cend(), _Val, _Get_comp());
    }

    _NODISCARD friend bool operator==(const _Deriv& _Lhs, const _Deriv& _Rhs) {
        return _Lhs.size() == _Rhs.size() && _STD equal(_Lhs.cbegin(), _Lhs.cend(), _Rhs.cbegin());
    }

    _NODISCARD friend _Synth_three_way_result<_Kty> operator<=>(const _Deriv& _Lhs, const _Deriv& _Rhs) {
        return _STD lexicographical_compare_three_way(
            _Lhs.cbegin(), _Lhs.cend(), _Rhs.cbegin(), _Rhs.cend(), _Synth_three_way{});
    }

    friend void swap(_Deriv& _Lhs, _Deriv& _Rhs) noexcept {
        _Lhs.swap(_Rhs);
    }

private:
    template <bool _Presorted, class _Iter>
    void _Insert_range(_Iter _First, _Iter _Last) {
        const auto _Old_size = _STD distance(begin(), end());
        _Container& _Cont    = _Get_cont();
        _Cont.insert(_Cont.end(), _First, _Last);
        _Restore_invariants_after_insert<_Presorted>(_Old_size);
    }

    _NODISCARD bool _Keys_equal(const _Kty& _Lhs, const _Kty& _Rhs) {
        key_compare& _Compare = _Get_comp();
        return !_Compare(_Lhs, _Rhs) && !_Compare(_Rhs, _Lhs);
    }

    template <class _Other, bool _Check = _Keylt_transparent, enable_if_t<_Check>>
    _NODISCARD bool _Key_other_equal(const _Kty& _Lhs, const _Other& _Rhs) {
        key_compare& _Compare = _Get_comp();
        return !_Compare(_Lhs, _Rhs) && !_Compare(_Rhs, _Lhs);
    }

    // O(N) if already sorted.
    void _Sort_potentially_sorted(const iterator& _Begin, const iterator& _End) {
        key_compare& _Compare          = _Get_comp();
        const iterator _Begin_unsorted = is_sorted_until(_Begin, _End, _Compare);

        if (_Begin_unsorted != _End) {
            sort(_Begin_unsorted, _End, _Compare);
        }
    }

    void _Erase_dupes_if_needed() {
        _Erase_dupes_if_needed(begin(), end());
    }

    void _Erase_dupes_if_needed(const iterator& _Begin, const iterator& _End) {
        if constexpr (!_Mfl) {
            iterator _New_end =
                unique(_Begin, _End, [&](const _Kty& lhs, const _Kty& rhs) { return _Keys_equal(lhs, rhs); });
            _Get_cont().erase(_New_end, _End);
        }
    }

    template <bool _Presorted>
    void _Restore_invariants_after_insert(const typename iterator::difference_type& _Old_size) {
        key_compare& _Compare   = _Get_comp();
        const iterator _Old_end = begin() + _Old_size;
        const iterator _New_end = end();

        if constexpr (_Presorted) {
            _STD sort(_Old_end, _New_end, _Compare);
        }

        _STD inplace_merge(begin(), _Old_end, _New_end, _Compare);

        _Erase_dupes_if_needed();
    }

    void _Make_invariants_fulfilled() {
        const iterator _Begin = begin();
        const iterator _End   = end();

        if (_Begin == _End) {
            return;
        }

        _Sort_potentially_sorted(_Begin, _End);

        _Erase_dupes_if_needed();
    }

    _NODISCARD const _Container& _Get_cont() const noexcept {
        return _My_pair._Get_first();
    }

    _NODISCARD _Container& _Get_cont() noexcept {
        return _My_pair._Get_first();
    }

    _NODISCARD const key_compare& _Get_comp() const noexcept {
        return _My_pair._Myval2;
    }

    _NODISCARD key_compare& _Get_comp() noexcept {
        return _My_pair._Myval2;
    }

    _Compressed_pair<container_type, key_compare> _My_pair;
};

_EXPORT_STD struct sorted_unique_t {
    explicit sorted_unique_t() = default;
};
_EXPORT_STD inline constexpr sorted_unique_t sorted_unique{};

_EXPORT_STD struct sorted_equivalent_t {
    explicit sorted_equivalent_t() = default;
};
_EXPORT_STD inline constexpr sorted_equivalent_t sorted_equivalent{};

template <class _Kty, class _Keylt = less<_Kty>, class _Container = vector<_Kty>>
_EXPORT_STD class flat_set
    : public _Base_flat_set<_Kty, _Keylt, _Container, false, flat_set<_Kty, _Keylt, _Container>, sorted_unique_t> {
public:
    using _Base_flat_set<_Kty, _Keylt, _Container, false, flat_set, sorted_unique_t>::_Base_flat_set;
};

template <class _Kty, class _Keylt = less<_Kty>, class _Container = vector<_Kty>>
_EXPORT_STD class flat_multiset : public _Base_flat_set<_Kty, _Keylt, _Container, true,
                                      flat_multiset<_Kty, _Keylt, _Container>, sorted_equivalent_t> {
public:
    using _Base_flat_set<_Kty, _Keylt, _Container, true, flat_multiset, sorted_equivalent_t>::_Base_flat_set;
};

_EXPORT_STD template <class _Kty, class _Keylt, class _Container, class _Pred>
size_t erase_if(flat_set<_Kty, _Keylt, _Container>& _Val, _Pred _Predicate) {
    _TRY_BEGIN
    return _Erase_remove_if(_Val, _Pass_fn(_Predicate));
    _CATCH_ALL
    _Val.clear();
    _RERAISE;
    _CATCH_END
}

_EXPORT_STD template <class _Kty, class _Keylt, class _Container, class _Pred>
size_t erase_if(flat_multiset<_Kty, _Keylt, _Container>& _Val, _Pred _Predicate) {
    _TRY_BEGIN
    return _Erase_remove_if(_Val, _Pass_fn(_Predicate));
    _CATCH_ALL
    _Val.clear();
    _RERAISE;
    _CATCH_END
}

template <class _Kty, class _Keylt, class _Container, class _Alloc>
struct uses_allocator<flat_set<_Kty, _Keylt, _Container>, _Alloc>
    : bool_constant<uses_allocator_v<_Container, _Alloc>> {};

template <class _Kty, class _Keylt, class _Container, class _Alloc>
struct uses_allocator<flat_multiset<_Kty, _Keylt, _Container>, _Alloc>
    : bool_constant<uses_allocator_v<_Container, _Alloc>> {};

_EXPORT_STD template <class _Container, class _Keylt = less<typename _Container::value_type>>
flat_set(_Container, _Keylt = _Keylt()) -> flat_set<typename _Container::value_type, _Keylt, _Container>;
_EXPORT_STD template <class _Container, class _Alloc>
flat_set(_Container, _Alloc)
    -> flat_set<typename _Container::value_type, less<typename _Container::value_type>, _Container>;
_EXPORT_STD template <class _Container, class _Keylt, class _Alloc>
flat_set(_Container, _Keylt, _Alloc) -> flat_set<typename _Container::value_type, _Keylt, _Container>;

_EXPORT_STD template <class _Container, class _Keylt = less<typename _Container::value_type>>
flat_set(sorted_unique_t, _Container, _Keylt = _Keylt())
    -> flat_set<typename _Container::value_type, _Keylt, _Container>;
_EXPORT_STD template <class _Container, class _Alloc>
flat_set(sorted_unique_t, _Container, _Alloc)
    -> flat_set<typename _Container::value_type, less<typename _Container::value_type>, _Container>;
_EXPORT_STD template <class _Container, class _Keylt, class _Alloc>
flat_set(sorted_unique_t, _Container, _Keylt, _Alloc) -> flat_set<typename _Container::value_type, _Keylt, _Container>;

_EXPORT_STD template <class _Iter, class _Keylt = less<iter_value_t<_Iter>>>
flat_set(_Iter, _Iter, _Keylt = _Keylt()) -> flat_set<iter_value_t<_Iter>, _Keylt>;
_EXPORT_STD template <class _Iter, class _Keylt = less<iter_value_t<_Iter>>>
flat_set(sorted_unique_t, _Iter, _Iter, _Keylt = _Keylt()) -> flat_set<iter_value_t<_Iter>, _Keylt>;
_EXPORT_STD template <_RANGES input_range _Range, class _Keylt = less<_RANGES range_value_t<_Range>>,
    class _Alloc = allocator<_RANGES range_value_t<_Range>>>
flat_set(from_range_t, _Range&&, _Keylt = _Keylt(), _Alloc = _Alloc()) -> flat_set<_RANGES range_value_t<_Range>,
    _Keylt, vector<_RANGES range_value_t<_Range>, _Rebind_alloc_t<_Alloc, _RANGES range_value_t<_Range>>>>;
_EXPORT_STD template <_RANGES input_range _Range, class _Alloc>
flat_set(from_range_t, _Range&&, _Alloc) -> flat_set<_RANGES range_value_t<_Range>, less<_RANGES range_value_t<_Range>>,
    vector<_RANGES range_value_t<_Range>, _Rebind_alloc_t<_Alloc, _RANGES range_value_t<_Range>>>>;
_EXPORT_STD template <class _Kty, class _Keylt = less<_Kty>>
flat_set(initializer_list<_Kty>, _Keylt = _Keylt()) -> flat_set<_Kty, _Keylt>;
_EXPORT_STD template <class _Kty, class _Keylt = less<_Kty>>
flat_set(sorted_unique_t, initializer_list<_Kty>, _Keylt = _Keylt()) -> flat_set<_Kty, _Keylt>;


_EXPORT_STD template <class _Container, class _Keylt = less<typename _Container::value_type>>
flat_multiset(_Container, _Keylt = _Keylt()) -> flat_multiset<typename _Container::value_type, _Keylt, _Container>;
_EXPORT_STD template <class _Container, class _Alloc>
flat_multiset(_Container, _Alloc)
    -> flat_multiset<typename _Container::value_type, less<typename _Container::value_type>, _Container>;
_EXPORT_STD template <class _Container, class _Keylt, class _Alloc>
flat_multiset(_Container, _Keylt, _Alloc) -> flat_multiset<typename _Container::value_type, _Keylt, _Container>;

_EXPORT_STD template <class _Container, class _Keylt = less<typename _Container::value_type>>
flat_multiset(sorted_equivalent_t, _Container, _Keylt = _Keylt())
    -> flat_multiset<typename _Container::value_type, _Keylt, _Container>;
_EXPORT_STD template <class _Container, class _Alloc>
flat_multiset(sorted_equivalent_t, _Container, _Alloc)
    -> flat_multiset<typename _Container::value_type, less<typename _Container::value_type>, _Container>;
_EXPORT_STD template <class _Container, class _Keylt, class _Alloc>
flat_multiset(sorted_equivalent_t, _Container, _Keylt, _Alloc)
    -> flat_multiset<typename _Container::value_type, _Keylt, _Container>;

_EXPORT_STD template <class _Iter, class _Keylt = less<iter_value_t<_Iter>>>
flat_multiset(_Iter, _Iter, _Keylt = _Keylt()) -> flat_multiset<iter_value_t<_Iter>, iter_value_t<_Iter>, _Keylt>;
_EXPORT_STD template <class _Iter, class _Keylt = less<iter_value_t<_Iter>>>
flat_multiset(sorted_equivalent_t, _Iter, _Iter, _Keylt = _Keylt())
    -> flat_multiset<iter_value_t<_Iter>, iter_value_t<_Iter>, _Keylt>;
_EXPORT_STD template <_RANGES input_range _Range, class _Keylt = less<_RANGES range_value_t<_Range>>,
    class _Alloc = allocator<_RANGES range_value_t<_Range>>>
flat_multiset(from_range_t, _Range&&, _Keylt = _Keylt(), _Alloc = _Alloc())
    -> flat_multiset<_RANGES range_value_t<_Range>, _Keylt,
        vector<_RANGES range_value_t<_Range>, _Rebind_alloc_t<_Alloc, _RANGES range_value_t<_Range>>>>;
_EXPORT_STD template <_RANGES input_range _Range, class _Alloc>
flat_multiset(from_range_t, _Range&&, _Alloc)
    -> flat_multiset<_RANGES range_value_t<_Range>, less<_RANGES range_value_t<_Range>>,
        vector<_RANGES range_value_t<_Range>, _Rebind_alloc_t<_Alloc, _RANGES range_value_t<_Range>>>>;
_EXPORT_STD template <class _Kty, class _Keylt = less<_Kty>>
flat_multiset(initializer_list<_Kty>, _Keylt = _Keylt()) -> flat_multiset<_Kty, _Keylt>;
_EXPORT_STD template <class _Kty, class _Keylt = less<_Kty>>
flat_multiset(sorted_equivalent_t, initializer_list<_Kty>, _Keylt = _Keylt()) -> flat_multiset<_Kty, _Keylt>;

_STD_END

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _FLAT_SET_
