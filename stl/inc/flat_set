// flat_set standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _FLAT_SET_
#define _FLAT_SET_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR
#if !_HAS_CXX23
_EMIT_STL_WARNING(STL4038, "The contents of <flat_set> are available only with C++23 or later.");
#else // ^^^ !_HAS_CXX23 / _HAS_CXX23 vvv
#include <algorithm>
#include <compare>
#include <initializer_list>
#include <vector>
#include <xutility>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
template <bool _IsNoexcept, class _Container>
struct _NODISCARD _Flat_set_swap_clear_guard {
    // Invariant: (_Target1 == nullptr) == (_Target2 == nullptr)
    _Container* _Target1;
    _Container* _Target2;

    _Flat_set_swap_clear_guard& operator=(const _Flat_set_swap_clear_guard&) = delete;
    _Flat_set_swap_clear_guard& operator=(_Flat_set_swap_clear_guard&&)      = delete;

    void _Abandon() noexcept {
        _Target1 = nullptr;
        _Target2 = nullptr;
    }

    ~_Flat_set_swap_clear_guard() {
        if (_Target1) {
            _Target1->clear();
            _Target2->clear();
        }
    }
};
template <class _Container>
struct _NODISCARD _Flat_set_swap_clear_guard<true, _Container> {
    constexpr explicit _Flat_set_swap_clear_guard(_Container*, _Container*) noexcept {}

    _Flat_set_swap_clear_guard& operator=(const _Flat_set_swap_clear_guard&) = delete;
    _Flat_set_swap_clear_guard& operator=(_Flat_set_swap_clear_guard&&)      = delete;

    void _Abandon() noexcept {}
};

_EXPORT_STD template <class _Kty, class _Keylt = less<_Kty>, class _Container = vector<_Kty>>
class flat_set;

_EXPORT_STD template <class _Kty, class _Keylt = less<_Kty>, class _Container = vector<_Kty>>
class flat_multiset;

template <bool _IsUnique, class _Kty, class _Keylt, class _Container>
class _Flat_set_base {
private:
    using _Sorted_t = conditional_t<_IsUnique, sorted_unique_t, sorted_equivalent_t>;
    using _Derived =
        conditional_t<_IsUnique, flat_set<_Kty, _Keylt, _Container>, flat_multiset<_Kty, _Keylt, _Container>>;

    static constexpr const char* _Msg_not_sorted = _IsUnique ? "Input was not sorted-unique!" : "Input was not sorted!";

public:
    static_assert(same_as<_Kty, typename _Container::value_type>,
        "The C++ Standard dictates that the Key type must be the "
        "same as the container's value type [flatset.overview]");
    static_assert(
        !_Is_vector_bool<_Container>, "vector<bool, A> cannot be adapted because it is not a sequence container.");

    using key_type               = _Kty;
    using value_type             = _Kty;
    using key_compare            = _Keylt;
    using value_compare          = _Keylt;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using size_type              = _Container::size_type;
    using difference_type        = _Container::difference_type;
    using const_iterator         = _Container::const_iterator;
    using iterator               = const_iterator;
    using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
    using reverse_iterator       = const_reverse_iterator;
    using container_type         = _Container;

    static_assert(random_access_iterator<iterator>, "The C++ Standard forbids containers without random "
                                                    "access iterators from being adapted. See [flatset.overview].");

    _Flat_set_base() : _Mycont(), _Mycomp() {}

    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(const _Derived& _Set, const _Alloc& _Al)
        : _Mycont(_STD make_obj_using_allocator<container_type>(_Al, _Set._Mycont)), _Mycomp(_Set._Mycomp) {}
    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(_Derived&& _Set, const _Alloc& _Al)
        : _Mycont(_STD make_obj_using_allocator<container_type>(_Al, _STD move(_Set).extract())),
          _Mycomp(_Set._Mycomp) // intentionally copy comparator, see LWG-2227
    {}

    explicit _Flat_set_base(container_type _Cont, const key_compare& _Comp = key_compare())
        : _Mycont(_STD move(_Cont)), _Mycomp(_Comp) {
        _Make_invariants_fulfilled();
    }
    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(const container_type& _Cont, const _Alloc& _Al)
        : _Flat_set_base(_STD make_obj_using_allocator<container_type>(_Al, _Cont)) {}
    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(const container_type& _Cont, const key_compare& _Comp, const _Alloc& _Al)
        : _Flat_set_base(_STD make_obj_using_allocator<container_type>(_Al, _Cont), _Comp) {}

    _Flat_set_base(_Sorted_t, container_type _Cont, const key_compare& _Comp = key_compare())
        : _Mycont(_STD move(_Cont)), _Mycomp(_Comp) {
        _STL_ASSERT(_Is_sorted(_Mycont), _Msg_not_sorted);
    }
    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(_Sorted_t _Tag, const container_type& _Cont, const _Alloc& _Al)
        : _Flat_set_base(_Tag, _STD make_obj_using_allocator<container_type>(_Al, _Cont)) {}
    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(_Sorted_t _Tag, const container_type& _Cont, const key_compare& _Comp, const _Alloc& _Al)
        : _Flat_set_base(_Tag, _STD make_obj_using_allocator<container_type>(_Al, _Cont), _Comp) {}

    explicit _Flat_set_base(const key_compare& _Comp) : _Mycont(), _Mycomp(_Comp) {}
    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(const key_compare& _Comp, const _Alloc& _Al)
        : _Mycont(_STD make_obj_using_allocator<container_type>(_Al)), _Mycomp(_Comp) {}
    template <_Usable_allocator_for<container_type> _Alloc>
    explicit _Flat_set_base(const _Alloc& _Al)
        : _Mycont(_STD make_obj_using_allocator<container_type>(_Al)), _Mycomp() {}

    template <_Iterator_for_container _Iter>
    _Flat_set_base(_Iter _First, _Iter _Last, const key_compare& _Comp = key_compare())
        : _Flat_set_base(container_type(_First, _Last), _Comp) {}
    template <_Iterator_for_container _Iter, _Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(_Iter _First, _Iter _Last, const key_compare& _Comp, const _Alloc& _Al)
        : _Mycont(_STD make_obj_using_allocator<container_type>(_Al)), _Mycomp(_Comp) {
        _Mycont.assign(_First, _Last);
        _Make_invariants_fulfilled();
    }
    template <_Iterator_for_container _Iter, _Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(_Iter _First, _Iter _Last, const _Alloc& _Al)
        : _Mycont(_STD make_obj_using_allocator<container_type>(_Al)), _Mycomp() {
        _Mycont.assign(_First, _Last);
        _Make_invariants_fulfilled();
    }

    template <_Container_compatible_range<_Kty> _Rng>
    _Flat_set_base(from_range_t, _Rng&& _Range)
        : _Flat_set_base(container_type(from_range, _STD forward<_Rng>(_Range))) {}
    template <_Container_compatible_range<_Kty> _Rng, _Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(from_range_t, _Rng&& _Range, const _Alloc& _Al)
        : _Mycont(_STD make_obj_using_allocator<container_type>(_Al)), _Mycomp() {
        _Mycont.assign_range(_STD forward<_Rng>(_Range));
        _Make_invariants_fulfilled();
    }
    template <_Container_compatible_range<_Kty> _Rng>
    _Flat_set_base(from_range_t, _Rng&& _Range, const key_compare& _Comp)
        : _Flat_set_base(container_type(from_range, _STD forward<_Rng>(_Range)), _Comp) {}
    template <_Container_compatible_range<_Kty> _Rng, _Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(from_range_t, _Rng&& _Range, const key_compare& _Comp, const _Alloc& _Al)
        : _Mycont(_STD make_obj_using_allocator<container_type>(_Al)), _Mycomp(_Comp) {
        _Mycont.assign_range(_STD forward<_Rng>(_Range));
        _Make_invariants_fulfilled();
    }

    template <_Iterator_for_container _Iter>
    _Flat_set_base(_Sorted_t _Tag, _Iter _First, _Iter _Last, const key_compare& _Comp = key_compare())
        : _Flat_set_base(_Tag, container_type(_First, _Last), _Comp) {}
    template <_Iterator_for_container _Iter, _Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(_Sorted_t _Tag, _Iter _First, _Iter _Last, const key_compare& _Comp, const _Alloc& _Al)
        : _Flat_set_base(_Tag, _STD make_obj_using_allocator<container_type>(_Al, _First, _Last), _Comp) {}
    template <_Iterator_for_container _Iter, _Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(_Sorted_t _Tag, _Iter _First, _Iter _Last, const _Alloc& _Al)
        : _Flat_set_base(_Tag, _STD make_obj_using_allocator<container_type>(_Al, _First, _Last)) {}

    _Flat_set_base(initializer_list<_Kty> _Ilist, const key_compare& _Comp = key_compare())
        : _Flat_set_base(container_type(_Ilist), _Comp) {}
    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(initializer_list<_Kty> _Ilist, const key_compare& _Comp, const _Alloc& _Al)
        : _Flat_set_base(_Ilist.begin(), _Ilist.end(), _Comp, _Al) {}
    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(initializer_list<_Kty> _Ilist, const _Alloc& _Al)
        : _Flat_set_base(_Ilist.begin(), _Ilist.end(), _Al) {}

    _Flat_set_base(_Sorted_t _Tag, initializer_list<_Kty> _Ilist, const key_compare& _Comp = key_compare())
        : _Flat_set_base(_Tag, container_type(_Ilist), _Comp) {}
    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(_Sorted_t _Tag, initializer_list<_Kty> _Ilist, const key_compare& _Comp, const _Alloc& _Al)
        : _Flat_set_base(_Tag, _Ilist.begin(), _Ilist.end(), _Comp, _Al) {}
    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(_Sorted_t _Tag, initializer_list<_Kty> _Ilist, const _Alloc& _Al)
        : _Flat_set_base(_Tag, _Ilist.begin(), _Ilist.end(), _Al) {}

    _Flat_set_base(const _Flat_set_base&) = default;
    _Flat_set_base(_Flat_set_base&& _Other) noexcept(
        is_nothrow_move_constructible_v<container_type> && is_nothrow_copy_constructible_v<key_compare>) // strengthened
        : _Mycont(_STD move(_Other).extract()), _Mycomp(_Other._Mycomp) // intentionally copy comparator, see LWG-2227
    {}

    _Flat_set_base& operator=(const _Flat_set_base& _Other) {
        _Clear_guard<container_type> _Guard{_STD addressof(_Mycont)};
        _Mycont        = _Other._Mycont;
        _Mycomp        = _Other._Mycomp;
        _Guard._Target = nullptr;
        return *this;
    }
    _Flat_set_base& operator=(_Flat_set_base&& _Other) noexcept(
        is_nothrow_move_assignable_v<container_type> && is_nothrow_copy_assignable_v<key_compare>) // strengthened
    {
        if (this != _STD addressof(_Other)) {
            _Clear_guard<container_type> _Guard{_STD addressof(_Mycont)};
            _Clear_guard<container_type> _Always_clear{_STD addressof(_Other._Mycont)};
            _Mycont        = _STD move(_Other._Mycont);
            _Mycomp        = _Other._Mycomp; // intentionally copy comparator, see LWG-2227
            _Guard._Target = nullptr;
        }
        return *this;
    }

    _Derived& operator=(initializer_list<_Kty> _Ilist) {
        _Clear_guard<container_type> _Guard{_STD addressof(_Mycont)};
        _Mycont.assign(_Ilist);
        _Make_invariants_fulfilled();
        _Guard._Target = nullptr;
        return static_cast<_Derived&>(*this);
    }

    // iterators
    // NB: The non-const overloads are intentionally removed for brevity. This will not result in behavioral changes.
    _NODISCARD const_iterator begin() const noexcept {
        return _Mycont.begin();
    }
    _NODISCARD const_iterator end() const noexcept {
        return _Mycont.end();
    }

    _NODISCARD const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }
    _NODISCARD const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    _NODISCARD const_iterator cbegin() const noexcept {
        return _Mycont.begin();
    }
    _NODISCARD const_iterator cend() const noexcept {
        return _Mycont.end();
    }
    _NODISCARD const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }
    _NODISCARD const_reverse_iterator crend() const noexcept {
        return rend();
    }

    // capacity
    _NODISCARD_EMPTY_MEMBER bool empty() const noexcept {
        return _Mycont.empty();
    }
    _NODISCARD size_type size() const noexcept {
        return _Mycont.size();
    }
    _NODISCARD size_type max_size() const noexcept {
        return _Mycont.max_size();
    }

    // modifiers
    // FIXME, the "insert" and "erase" methods may not be able to restore the invariant, if the underlying
    // container is unable to provide strong guarantee for "erase" and "insert" methods.
    template <class... _Args>
    auto emplace(_Args&&... _Vals) {
        constexpr bool _Is_key_type = _In_place_key_extract_set<_Kty, remove_cvref_t<_Args>...>::_Extractable;
        if constexpr (_Is_key_type) {
            return _Emplace(_STD forward<_Args>(_Vals)...);
        } else {
            return _Emplace(_Kty(_STD forward<_Args>(_Vals)...));
        }
    }
    template <class... _Args>
    iterator emplace_hint(const_iterator _Hint, _Args&&... _Vals) {
        constexpr bool _Is_key_type = _In_place_key_extract_set<_Kty, remove_cvref_t<_Args>...>::_Extractable;
        if constexpr (_Is_key_type) {
            return _Emplace_hint(_Hint, _STD forward<_Args>(_Vals)...);
        } else {
            return _Emplace_hint(_Hint, _Kty(_STD forward<_Args>(_Vals)...));
        }
    }

    auto insert(const _Kty& _Val) {
        return _Emplace(_Val);
    }
    auto insert(_Kty&& _Val) {
        return _Emplace(_STD move(_Val));
    }
    template <_Different_from<_Kty> _Other>
        requires _IsUnique && _Transparent<key_compare> && is_constructible_v<_Kty, _Other>
    auto insert(_Other&& _Val) {
        return _Emplace(_STD forward<_Other>(_Val));
    }

    iterator insert(const_iterator _Hint, const _Kty& _Val) {
        return _Emplace_hint(_Hint, _Val);
    }
    iterator insert(const_iterator _Hint, _Kty&& _Val) {
        return _Emplace_hint(_Hint, _STD move(_Val));
    }
    template <_Different_from<_Kty> _Other>
        requires _IsUnique && _Transparent<key_compare> && is_constructible_v<_Kty, _Other>
    iterator insert(const_iterator _Hint, _Other&& _Val) {
        return _Emplace_hint(_Hint, _STD forward<_Other>(_Val));
    }

    template <_Iterator_for_container _Iter>
    void insert(_Iter _First, _Iter _Last) {
        _Insert_range<true>(_First, _Last);
    }
    template <_Iterator_for_container _Iter>
    void insert(_Sorted_t, _Iter _First, _Iter _Last) {
        _Insert_range<false>(_First, _Last);
    }
    template <_Container_compatible_range<_Kty> _Rng>
    void insert_range(_Rng&& _Range) {
        const size_type _Old_size = size();

        if constexpr (requires { _Mycont.append_range(_STD forward<_Rng>(_Range)); }) {
            _Mycont.append_range(_STD forward<_Rng>(_Range));
        } else {
            _Mycont.insert_range(_Mycont.end(), _STD forward<_Rng>(_Range));
        }
        _Restore_invariants_after_insert<true>(_Old_size);
    }

    void insert(initializer_list<_Kty> _Ilist) {
        _Insert_range<true>(_Ilist.begin(), _Ilist.end());
    }
    void insert(_Sorted_t, initializer_list<_Kty> _Ilist) {
        _Insert_range<false>(_Ilist.begin(), _Ilist.end());
    }

    _NODISCARD container_type extract() && noexcept(
        is_nothrow_move_constructible_v<container_type>) /* strengthened */ {
        // always clears the container (N4950 [flat.set.modifiers]/14 and [flat.multiset.modifiers]/10)
        _Clear_guard<container_type> _Always_clear{_STD addressof(_Mycont)};
        return _STD move(_Mycont);
    }
    void replace(container_type&& _Cont) {
        _STL_ASSERT(_Is_sorted(_Cont), _Msg_not_sorted);
        _Clear_guard<container_type> _Guard{_STD addressof(_Mycont)};
        _Mycont        = _STD move(_Cont);
        _Guard._Target = nullptr;
    }

    // NB: `erase(iterator)` is identical to `erase(const_iterator)`
    iterator erase(const_iterator _Where) {
        return _Mycont.erase(_Where);
    }
    size_type erase(const _Kty& _Val) {
        return _Erase(_Val);
    }
    template <_Different_from<_Kty> _Other>
        requires _Transparent<key_compare> && (!is_convertible_v<_Other, const_iterator>)
    size_type erase(_Other&& _Val) {
        return _Erase(_Val);
    }
    iterator erase(const_iterator _First, const_iterator _Last) {
        return _Mycont.erase(_First, _Last);
    }

    void swap(_Derived& _Other) noexcept(is_nothrow_swappable_v<_Container> && is_nothrow_swappable_v<_Keylt>) {
        constexpr bool _Is_noexcept = is_nothrow_swappable_v<_Container> && is_nothrow_swappable_v<_Keylt>;
        _Flat_set_swap_clear_guard<_Is_noexcept, _Container> _Guard{
            _STD addressof(_Mycont), _STD addressof(_Other._Mycont)};
        _RANGES swap(_Mycomp, _Other._Mycomp);
        _RANGES swap(_Mycont, _Other._Mycont);
        _Guard._Abandon();
    }
    void clear() noexcept {
        _Mycont.clear();
    }

    // observers
    _NODISCARD key_compare key_comp() const {
        return _Mycomp;
    }
    _NODISCARD value_compare value_comp() const {
        return _Mycomp;
    }

    _NODISCARD container_type& _Get_container_for_erase_if() noexcept {
        return _Mycont;
    }

    // set operations
    // NB: The non-const overloads are intentionally removed for brevity. This will not result in behavioral changes.
    _NODISCARD const_iterator find(const _Kty& _Val) const {
        return _Find(_Val);
    }
    template <class _Other>
        requires _Transparent<key_compare>
    _NODISCARD const_iterator find(const _Other& _Val) const {
        return _Find(_Val);
    }

    _NODISCARD size_type count(const _Kty& _Val) const {
        if constexpr (_IsUnique) {
            return contains(_Val);
        } else {
            const auto [_First, _Last] = equal_range(_Val);
            return static_cast<size_type>(_Last - _First);
        }
    }
    template <class _Other>
        requires _Transparent<key_compare>
    _NODISCARD size_type count(const _Other& _Val) const {
        const auto [_First, _Last] = equal_range(_Val);
        return static_cast<size_type>(_Last - _First);
    }

    _NODISCARD bool contains(const _Kty& _Val) const {
        return _STD binary_search(cbegin(), cend(), _Val, _Pass_comp());
    }
    template <class _Other>
        requires _Transparent<key_compare>
    _NODISCARD bool contains(const _Other& _Val) const {
        return _STD binary_search(cbegin(), cend(), _Val, _Pass_comp());
    }

    _NODISCARD const_iterator lower_bound(const _Kty& _Val) const {
        return _STD lower_bound(cbegin(), cend(), _Val, _Pass_comp());
    }
    template <class _Other>
        requires _Transparent<key_compare>
    _NODISCARD const_iterator lower_bound(const _Other& _Val) const {
        return _STD lower_bound(cbegin(), cend(), _Val, _Pass_comp());
    }

    _NODISCARD const_iterator upper_bound(const _Kty& _Val) const {
        return _STD upper_bound(cbegin(), cend(), _Val, _Pass_comp());
    }
    template <class _Other>
        requires _Transparent<key_compare>
    _NODISCARD const_iterator upper_bound(const _Other& _Val) const {
        return _STD upper_bound(cbegin(), cend(), _Val, _Pass_comp());
    }

    _NODISCARD pair<const_iterator, const_iterator> equal_range(const _Kty& _Val) const {
        return _STD equal_range(cbegin(), cend(), _Val, _Pass_comp());
    }
    template <class _Other>
        requires _Transparent<key_compare>
    _NODISCARD pair<const_iterator, const_iterator> equal_range(const _Other& _Val) const {
        return _STD equal_range(cbegin(), cend(), _Val, _Pass_comp());
    }

    _NODISCARD friend bool operator==(const _Derived& _Lhs, const _Derived& _Rhs) {
        return _RANGES equal(_Lhs._Mycont, _Rhs._Mycont);
    }

    _NODISCARD friend auto operator<=>(const _Derived& _Lhs, const _Derived& _Rhs) {
        return _STD lexicographical_compare_three_way(
            _Lhs.cbegin(), _Lhs.cend(), _Rhs.cbegin(), _Rhs.cend(), _Synth_three_way{});
    }

    friend void swap(_Derived& _Lhs, _Derived& _Rhs) noexcept(noexcept(_Lhs.swap(_Rhs))) {
        _Lhs.swap(_Rhs);
    }

private:
    _NODISCARD bool _Is_sorted(const_iterator _It, const const_iterator _End) const {
        if constexpr (_IsUnique) {
            // sorted-unique
            if (_It == _End) {
                return true;
            }
            while (++_It != _End) {
                if (!_Compare(*(_It - 1), *_It)) {
                    return false;
                }
            }
            return true;
        } else {
            return _STD is_sorted(_It, _End, _Pass_comp());
        }
    }

    _NODISCARD bool _Is_sorted(const container_type& _Cont) const {
        return _Is_sorted(_Cont.begin(), _Cont.end());
    }

    template <class _Ty>
    _NODISCARD bool _Can_insert(const const_iterator _Where, const _Ty& _Val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty, _Kty>); // only accepts _Kty

        // check that _Val can be inserted before _Where
        if constexpr (_IsUnique) {
            // check that _Where is the lower_bound for _Val, and *_Where is not equivalent to _Val
            // equivalent to checking *(_Where-1) < _Val < *_Where
            return (_Where == cend() || _Compare(_Val, *_Where))
                && (_Where == cbegin() || _Compare(*(_Where - 1), _Val));
        } else {
            // check that _Where is the upper_bound for _Val
            // equivalent to checking *(_Where-1) <= _Val < *_Where
            return (_Where == cend() || _Compare(_Val, *_Where))
                && (_Where == cbegin() || !_Compare(_Val, *(_Where - 1)));
        }
    }

    template <class _Ty>
    _NODISCARD conditional_t<_IsUnique, pair<iterator, bool>, iterator> _Emplace(_Ty&& _Val) {
        if constexpr (_IsUnique) {
            const const_iterator _Where = lower_bound(_Val);
            if (_Where != cend() && !_Compare(_Val, *_Where)) {
                return pair{_Where, false};
            }

            if constexpr (is_same_v<remove_cvref_t<_Ty>, _Kty>) {
                _STL_INTERNAL_CHECK(_Can_insert(_Where, _Val));
                return pair{_Mycont.emplace(_Where, _STD forward<_Ty>(_Val)), true};
            } else {
                // heterogeneous insertion
                // FIXME: The standard only requires `find(_Val) == find(_Keyval)` (per N4958 [flat.set.modifiers]/2),
                // which cannot guarantee `_Can_insert(_Where, _Keyval)`.
                _STL_INTERNAL_STATIC_ASSERT(_Transparent<key_compare> && is_constructible_v<_Kty, _Ty>);
                _Kty _Keyval(_STD forward<_Ty>(_Val));
                _STL_ASSERT(_Can_insert(_Where, _Keyval),
                    "The conversion from the heterogeneous key to key_type should "
                    "be consistent with the heterogeneous lookup!");
                return pair{_Mycont.emplace(_Where, _STD move(_Keyval)), true};
            }
        } else {
            _STL_INTERNAL_STATIC_ASSERT(is_same_v<remove_cvref_t<_Ty>, _Kty>);
            return _Mycont.emplace(upper_bound(_Val), _STD forward<_Ty>(_Val));
        }
    }

    template <class _Ty>
    _NODISCARD iterator _Emplace_hint(const_iterator _Where, _Ty&& _Val) {
        const const_iterator _Begin = cbegin();
        const const_iterator _End   = cend();

        if constexpr (_IsUnique) {
            // look for lower_bound(_Val)
            if (_Where == _End || !_Compare(*_Where, _Val)) {
                // _Val <= *_Where
                if (_Where == _Begin || _Compare(*(_Where - 1), _Val)) {
                    // _Val > *(_Where-1) ~ lower_bound is _Where
                } else {
                    // _Val <= *(_Where-1) ~ lower_bound is in [_Begin,_Where-1]
                    _Where = _STD lower_bound(_Begin, _Where - 1, _Val, _Pass_comp());
                }
            } else {
                // _Val > *_Where ~ lower_bound is in [_Where+1,_End]
                _Where = _STD lower_bound(_Where + 1, _End, _Val, _Pass_comp());
            }

            if (_Where != _End && !_Compare(_Val, *_Where)) {
                return _Where;
            }

            if constexpr (is_same_v<remove_cvref_t<_Ty>, _Kty>) {
                _STL_INTERNAL_CHECK(_Can_insert(_Where, _Val));
                return _Mycont.emplace(_Where, _STD forward<_Ty>(_Val));
            } else {
                // heterogeneous insertion
                // FIXME: The standard only requires `find(_Val) == find(_Keyval)` (per N4958 [flat.set.modifiers]/2),
                // which cannot guarantee `_Can_insert(_Where, _Keyval)`.
                _STL_INTERNAL_STATIC_ASSERT(_Transparent<key_compare> && is_constructible_v<_Kty, _Ty>);
                _Kty _Keyval(_STD forward<_Ty>(_Val));
                _STL_ASSERT(_Can_insert(_Where, _Keyval),
                    "The conversion from the heterogeneous key to key_type should "
                    "be consistent with the heterogeneous lookup!");
                return _Mycont.emplace(_Where, _STD move(_Keyval));
            }
        } else {
            _STL_INTERNAL_STATIC_ASSERT(is_same_v<remove_cvref_t<_Ty>, _Kty>);

            // look for upper_bound(_Val)
            if (_Where == _End || _Compare(_Val, *_Where)) {
                // _Val < *_Where
                if (_Where == _Begin || !_Compare(_Val, *(_Where - 1))) {
                    // _Val >= *(_Where-1) ~ upper_bound is _Where
                } else {
                    // _Val < *(_Where-1) ~ upper_bound is in [_Begin,_Where-1]
                    _Where = _STD upper_bound(_Begin, _Where - 1, _Val, _Pass_comp());
                }
            } else {
                // _Val >= *_Where ~ upper_bound is in [_Where+1,_End]
                _Where = _STD upper_bound(_Where + 1, _End, _Val, _Pass_comp());
            }

            _STL_INTERNAL_CHECK(_Can_insert(_Where, _Val));
            return _Mycont.emplace(_Where, _STD forward<_Ty>(_Val));
        }
    }

    template <bool _NeedSorting, class _Iter>
    void _Insert_range(const _Iter _First, const _Iter _Last) {
        const size_type _Old_size = size();
        _Clear_guard _Guard{this};
        _Mycont.insert(_Mycont.end(), _First, _Last);
        _Restore_invariants_after_insert<_NeedSorting>(_Old_size);
        _Guard._Target = nullptr;
    }

    template <class _Ty>
    _NODISCARD size_type _Erase(const _Ty& _Val) {
        _STL_INTERNAL_STATIC_ASSERT(_Transparent<key_compare> || is_same_v<_Ty, _Kty>);

        if constexpr (_IsUnique && is_same_v<_Ty, _Kty>) {
            const const_iterator _Where = lower_bound(_Val);
            if (_Where != cend() && !_Compare(_Val, *_Where)) {
                _Mycont.erase(_Where);
                return 1;
            }
            return 0;
        } else {
            const auto [_First, _Last] = equal_range(_Val);

            const auto _Removed = static_cast<size_type>(_Last - _First);
            _Mycont.erase(_First, _Last);
            return _Removed;
        }
    }

    template <class _Ty>
    _NODISCARD const_iterator _Find(const _Ty& _Val) const {
        _STL_INTERNAL_STATIC_ASSERT(_Transparent<key_compare> || is_same_v<_Ty, _Kty>);

        const const_iterator _End   = cend();
        const const_iterator _Where = lower_bound(_Val);
        if (_Where != _End && !_Compare(_Val, *_Where)) {
            return _Where;
        } else {
            return _End;
        }
    }

    void _Erase_dupes_if_not_multi() {
        if constexpr (_IsUnique) {
            const auto _Equivalent = [this](const _Kty& _Lhs, const _Kty& _Rhs) {
                return !_Compare(_Lhs, _Rhs) && !_Compare(_Rhs, _Lhs);
            };
            const auto _End = _Mycont.end();
            _Mycont.erase(_STD unique(_Mycont.begin(), _End, _Equivalent), _End);
        }
    }

    template <bool _NeedSorting>
    void _Restore_invariants_after_insert(const size_type _Old_size) {
        const auto _Begin   = _Mycont.begin();
        const auto _Old_end = _Begin + static_cast<difference_type>(_Old_size);
        const auto _End     = _Mycont.end();

        if constexpr (_NeedSorting) {
            _STD sort(_Old_end, _End, _Pass_comp());
        } else {
            _STL_ASSERT(_Is_sorted(_Old_end, _End), _Msg_not_sorted);
        }

        _STD inplace_merge(_Begin, _Old_end, _End, _Pass_comp());
        _Erase_dupes_if_not_multi();

        _STL_INTERNAL_CHECK(_Is_sorted(_Mycont));
    }

    void _Make_invariants_fulfilled() {
        const auto _Begin = _Mycont.begin();
        const auto _End   = _Mycont.end();

        if (_Begin == _End) {
            return;
        }

        // O(N) if already sorted.
        const auto _Begin_unsorted = _STD is_sorted_until(_Begin, _End, _Pass_comp());

        _STD sort(_Begin_unsorted, _End, _Pass_comp());
        _STD inplace_merge(_Begin, _Begin_unsorted, _End, _Pass_comp());
        _Erase_dupes_if_not_multi();

        _STL_INTERNAL_CHECK(_Is_sorted(_Mycont));
    }

    template <class _Lty, class _Rty>
    _NODISCARD bool _Compare(const _Lty& _Lhs, const _Rty& _Rhs) const
        noexcept(noexcept(_DEBUG_LT_PRED(_Mycomp, _Lhs, _Rhs))) {
        _STL_INTERNAL_STATIC_ASSERT(_Transparent<key_compare> || (is_same_v<_Kty, _Lty> && is_same_v<_Kty, _Rty>) );

        return _DEBUG_LT_PRED(_Mycomp, _Lhs, _Rhs);
    }

    _NODISCARD auto _Pass_comp() const noexcept {
        return _STD _Pass_fn(_Mycomp);
    }

    container_type _Mycont;
    /* [[no_unique_address]] */ key_compare _Mycomp;
};

_EXPORT_STD template <class _Kty, class _Keylt, class _Container>
class flat_set : public _Flat_set_base<true, _Kty, _Keylt, _Container> {
private:
    using _Mybase = _Flat_set_base<true, _Kty, _Keylt, _Container>;

public:
    using _Mybase::_Mybase;
    flat_set(const flat_set&) = default;
    flat_set(flat_set&&)      = default;

#if 1 // TRANSITION, P2582R1 (MSVC, Clang, EDG)
    template <_Usable_allocator_for<_Container> _Allocator>
    flat_set(const flat_set& _Other, const _Allocator& _Al) : _Mybase(_Other, _Al) {}

    template <_Usable_allocator_for<_Container> _Allocator>
    flat_set(flat_set&& _Other, const _Allocator& _Al) : _Mybase(_STD move(_Other), _Al) {}
#endif // ^^^ workaround ^^^

    using _Mybase::operator=;
    flat_set& operator=(const flat_set&) = default;
    flat_set& operator=(flat_set&&)      = default;
};

_EXPORT_STD template <class _Kty, class _Keylt, class _Container>
class flat_multiset : public _Flat_set_base<false, _Kty, _Keylt, _Container> {
private:
    using _Mybase = _Flat_set_base<false, _Kty, _Keylt, _Container>;

public:
    using _Mybase::_Mybase;
    flat_multiset(const flat_multiset&) = default;
    flat_multiset(flat_multiset&&)      = default;

#if 1 // TRANSITION, P2582R1 (MSVC, Clang, EDG)
    template <_Usable_allocator_for<_Container> _Allocator>
    flat_multiset(const flat_multiset& _Other, const _Allocator& _Al) : _Mybase(_Other, _Al) {}

    template <_Usable_allocator_for<_Container> _Allocator>
    flat_multiset(flat_multiset&& _Other, const _Allocator& _Al) : _Mybase(_STD move(_Other), _Al) {}
#endif // ^^^ workaround ^^^

    using _Mybase::operator=;
    flat_multiset& operator=(const flat_multiset&) = default;
    flat_multiset& operator=(flat_multiset&&)      = default;
};

_EXPORT_STD template <class _Kty, class _Keylt, class _Container, class _Pred>
_Container::size_type erase_if(flat_set<_Kty, _Keylt, _Container>& _Val, _Pred _Predicate) {
    // clears the container to maintain the invariants when an exception is thrown (N4950 [flat.set.erasure]/5)
    _Container& _Cont = _Val._Get_container_for_erase_if();
    _Clear_guard<_Container> _Guard{_STD addressof(_Cont)};
    const auto _Erased_count = _STD _Erase_remove_if(_Cont, _STD _Pass_fn(_Predicate));
    _Guard._Target           = nullptr;
    return _Erased_count;
}

_EXPORT_STD template <class _Kty, class _Keylt, class _Container, class _Pred>
_Container::size_type erase_if(flat_multiset<_Kty, _Keylt, _Container>& _Val, _Pred _Predicate) {
    // clears the container to maintain the invariants when an exception is thrown (N4950 [flat.multiset.erasure]/5)
    _Container& _Cont = _Val._Get_container_for_erase_if();
    _Clear_guard<_Container> _Guard{_STD addressof(_Cont)};
    const auto _Erased_count = _STD _Erase_remove_if(_Cont, _STD _Pass_fn(_Predicate));
    _Guard._Target           = nullptr;
    return _Erased_count;
}

template <class _Kty, class _Keylt, class _Container, class _Alloc>
struct uses_allocator<flat_set<_Kty, _Keylt, _Container>, _Alloc>
    : bool_constant<uses_allocator_v<_Container, _Alloc>> {};

template <class _Kty, class _Keylt, class _Container, class _Alloc>
struct uses_allocator<flat_multiset<_Kty, _Keylt, _Container>, _Alloc>
    : bool_constant<uses_allocator_v<_Container, _Alloc>> {};

template <_Not_allocator_for_container _Container,
    _Valid_compare_for_container<_Container> _Compare = less<typename _Container::value_type>>
flat_set(_Container, _Compare = _Compare()) -> flat_set<typename _Container::value_type, _Compare, _Container>;
template <_Not_allocator_for_container _Container, _Usable_allocator_for<_Container> _Alloc>
flat_set(_Container, _Alloc)
    -> flat_set<typename _Container::value_type, less<typename _Container::value_type>, _Container>;
template <_Not_allocator_for_container _Container, _Valid_compare_for_container<_Container> _Compare,
    _Usable_allocator_for<_Container> _Alloc>
flat_set(_Container, _Compare, _Alloc) -> flat_set<typename _Container::value_type, _Compare, _Container>;

template <_Not_allocator_for_container _Container,
    _Valid_compare_for_container<_Container> _Compare = less<typename _Container::value_type>>
flat_set(sorted_unique_t, _Container, _Compare = _Compare())
    -> flat_set<typename _Container::value_type, _Compare, _Container>;
template <_Not_allocator_for_container _Container, _Usable_allocator_for<_Container> _Alloc>
flat_set(sorted_unique_t, _Container, _Alloc)
    -> flat_set<typename _Container::value_type, less<typename _Container::value_type>, _Container>;
template <_Not_allocator_for_container _Container, _Valid_compare_for_container<_Container> _Compare,
    _Usable_allocator_for<_Container> _Alloc>
flat_set(sorted_unique_t, _Container, _Compare, _Alloc)
    -> flat_set<typename _Container::value_type, _Compare, _Container>;

template <_Iterator_for_container _Iter, _Not_allocator_for_container _Compare = less<iter_value_t<_Iter>>>
flat_set(_Iter, _Iter, _Compare = _Compare()) -> flat_set<iter_value_t<_Iter>, _Compare>;
template <_Iterator_for_container _Iter, _Not_allocator_for_container _Compare = less<iter_value_t<_Iter>>>
flat_set(sorted_unique_t, _Iter, _Iter, _Compare = _Compare()) -> flat_set<iter_value_t<_Iter>, _Compare>;
// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Range, _Not_allocator_for_container _Compare = less<_RANGES range_value_t<_Range>>,
    class _Alloc = allocator<_RANGES range_value_t<_Range>>, enable_if_t<_Allocator_for_container<_Alloc>, int> = 0>
flat_set(from_range_t, _Range&&, _Compare = _Compare(), _Alloc = _Alloc()) -> flat_set<_RANGES range_value_t<_Range>,
    _Compare, vector<_RANGES range_value_t<_Range>, _Rebind_alloc_t<_Alloc, _RANGES range_value_t<_Range>>>>;
// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Range, class _Alloc, enable_if_t<_Allocator_for_container<_Alloc>, int> = 0>
flat_set(from_range_t, _Range&&, _Alloc) -> flat_set<_RANGES range_value_t<_Range>, less<_RANGES range_value_t<_Range>>,
    vector<_RANGES range_value_t<_Range>, _Rebind_alloc_t<_Alloc, _RANGES range_value_t<_Range>>>>;
template <class _Kty, _Not_allocator_for_container _Compare = less<_Kty>>
flat_set(initializer_list<_Kty>, _Compare = _Compare()) -> flat_set<_Kty, _Compare>;
template <class _Kty, _Not_allocator_for_container _Compare = less<_Kty>>
flat_set(sorted_unique_t, initializer_list<_Kty>, _Compare = _Compare()) -> flat_set<_Kty, _Compare>;


template <_Not_allocator_for_container _Container,
    _Valid_compare_for_container<_Container> _Compare = less<typename _Container::value_type>>
flat_multiset(_Container, _Compare = _Compare())
    -> flat_multiset<typename _Container::value_type, _Compare, _Container>;
template <_Not_allocator_for_container _Container, _Usable_allocator_for<_Container> _Alloc>
flat_multiset(_Container, _Alloc)
    -> flat_multiset<typename _Container::value_type, less<typename _Container::value_type>, _Container>;
template <_Not_allocator_for_container _Container, _Valid_compare_for_container<_Container> _Compare,
    _Usable_allocator_for<_Container> _Alloc>
flat_multiset(_Container, _Compare, _Alloc) -> flat_multiset<typename _Container::value_type, _Compare, _Container>;

template <_Not_allocator_for_container _Container,
    _Valid_compare_for_container<_Container> _Compare = less<typename _Container::value_type>>
flat_multiset(sorted_equivalent_t, _Container, _Compare = _Compare())
    -> flat_multiset<typename _Container::value_type, _Compare, _Container>;
template <_Not_allocator_for_container _Container, _Usable_allocator_for<_Container> _Alloc>
flat_multiset(sorted_equivalent_t, _Container, _Alloc)
    -> flat_multiset<typename _Container::value_type, less<typename _Container::value_type>, _Container>;
template <_Not_allocator_for_container _Container, _Valid_compare_for_container<_Container> _Compare,
    _Usable_allocator_for<_Container> _Alloc>
flat_multiset(sorted_equivalent_t, _Container, _Compare, _Alloc)
    -> flat_multiset<typename _Container::value_type, _Compare, _Container>;

template <_Iterator_for_container _Iter, _Not_allocator_for_container _Compare = less<iter_value_t<_Iter>>>
flat_multiset(_Iter, _Iter, _Compare = _Compare()) -> flat_multiset<iter_value_t<_Iter>, _Compare>;
template <_Iterator_for_container _Iter, _Not_allocator_for_container _Compare = less<iter_value_t<_Iter>>>
flat_multiset(sorted_equivalent_t, _Iter, _Iter, _Compare = _Compare()) -> flat_multiset<iter_value_t<_Iter>, _Compare>;
// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Range, _Not_allocator_for_container _Compare = less<_RANGES range_value_t<_Range>>,
    class _Alloc = allocator<_RANGES range_value_t<_Range>>, enable_if_t<_Allocator_for_container<_Alloc>, int> = 0>
flat_multiset(from_range_t, _Range&&, _Compare = _Compare(), _Alloc = _Alloc())
    -> flat_multiset<_RANGES range_value_t<_Range>, _Compare,
        vector<_RANGES range_value_t<_Range>, _Rebind_alloc_t<_Alloc, _RANGES range_value_t<_Range>>>>;
// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Range, class _Alloc, enable_if_t<_Allocator_for_container<_Alloc>, int> = 0>
flat_multiset(from_range_t, _Range&&, _Alloc)
    -> flat_multiset<_RANGES range_value_t<_Range>, less<_RANGES range_value_t<_Range>>,
        vector<_RANGES range_value_t<_Range>, _Rebind_alloc_t<_Alloc, _RANGES range_value_t<_Range>>>>;
template <class _Kty, _Not_allocator_for_container _Compare = less<_Kty>>
flat_multiset(initializer_list<_Kty>, _Compare = _Compare()) -> flat_multiset<_Kty, _Compare>;
template <class _Kty, _Not_allocator_for_container _Compare = less<_Kty>>
flat_multiset(sorted_equivalent_t, initializer_list<_Kty>, _Compare = _Compare()) -> flat_multiset<_Kty, _Compare>;

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // ^^^ _HAS_CXX23 ^^^
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _FLAT_SET_
