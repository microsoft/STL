// flat_set standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _FLAT_SET_
#define _FLAT_SET_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR
#if !_HAS_CXX23 || !defined(__cpp_lib_concepts) // TRANSITION, GH-395
_EMIT_STL_WARNING(STL4038, "The contents of <flat_set> are available only with C++23 or later.");
#else // ^^^ not supported / supported language mode vvv
#include <algorithm>
#include <compare>
#include <initializer_list>
#include <vector>
#include <xutility>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN

template <class _Ty>
struct _NODISCARD _Clear_guard {
    _Ty* _Target;
    ~_Clear_guard() {
        if (_Target) {
            _Target->clear();
        }
    }
};

template <class _Alloc, class _Container>
concept _Allocator_for = uses_allocator_v<_Container, _Alloc>;

template <class _Kty, class _Keylt, class _Container, bool _Multi, class _Deriv, class _Tsorted>
class _Base_flat_set {
private:
    static constexpr bool _Keylt_transparent = _Is_transparent_v<_Keylt>;

public:
    static_assert(same_as<_Kty, typename _Container::value_type>,
        "The C++ Standard dictates that the Key type must be the "
        "same as the container's value type [flatset.overview]");

    using key_type               = _Kty;
    using value_type             = _Kty;
    using key_compare            = _Keylt;
    using value_compare          = _Keylt;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using size_type              = _Container::size_type;
    using difference_type        = _Container::difference_type;
    using const_iterator         = _Container::const_iterator;
    using iterator               = const_iterator;
    using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
    using reverse_iterator       = const_reverse_iterator;
    using container_type         = _Container;

    static_assert(random_access_iterator<iterator>, "The C++ Standard forbids containers without random "
                                                    "access iterators from being adapted. See [flatset.overview].");

    _Base_flat_set() : _Mycont(), _Mycomp() {}

    template <_Allocator_for<container_type> _Alloc>
    _Base_flat_set(const _Deriv& _Set, const _Alloc& _Al) : _Mycont(_Set._Mycont, _Al), _Mycomp(_Set._Mycomp) {}
    template <_Allocator_for<container_type> _Alloc>
    _Base_flat_set(_Deriv&& _Set, const _Alloc& _Al)
        : _Mycont(_STD move(_Set).extract(), _Al), _Mycomp(_Set._Mycomp) // intentionally copy comparator, see LWG-2227
    {}

    explicit _Base_flat_set(container_type _Cont, const key_compare& _Comp = key_compare())
        : _Mycont(_STD move(_Cont)), _Mycomp(_Comp) {
        _Make_invariants_fulfilled();
    }
    template <_Allocator_for<container_type> _Alloc>
    _Base_flat_set(const container_type& _Cont, const _Alloc& _Al) : _Base_flat_set(container_type(_Cont, _Al)) {}
    template <_Allocator_for<container_type> _Alloc>
    _Base_flat_set(const container_type& _Cont, const key_compare& _Comp, const _Alloc& _Al)
        : _Base_flat_set(container_type(_Cont, _Al), _Comp) {}

    _Base_flat_set(_Tsorted, container_type _Cont, const key_compare& _Comp = key_compare())
        : _Mycont(_STD move(_Cont)), _Mycomp(_Comp) {
        _STL_ASSERT(_Is_sorted(_Mycont), _Msg_not_sorted);
    }
    template <_Allocator_for<container_type> _Alloc>
    _Base_flat_set(_Tsorted _Tsort, const container_type& _Cont, const _Alloc& _Al)
        : _Base_flat_set(_Tsort, container_type(_Cont, _Al)) {}
    template <_Allocator_for<container_type> _Alloc>
    _Base_flat_set(_Tsorted _Tsort, const container_type& _Cont, const key_compare& _Comp, const _Alloc& _Al)
        : _Base_flat_set(_Tsort, container_type(_Cont, _Al), _Comp) {}

    explicit _Base_flat_set(const key_compare& _Comp) : _Mycont(), _Mycomp(_Comp) {}
    template <_Allocator_for<container_type> _Alloc>
    _Base_flat_set(const key_compare& _Comp, const _Alloc& _Al) : _Mycont(_Al), _Mycomp(_Comp) {}
    template <_Allocator_for<container_type> _Alloc>
    explicit _Base_flat_set(const _Alloc& _Al) : _Mycont(_Al), _Mycomp() {}

    // FIXME, an allocator-aware container may not support "C(_First, _Last, _Al)".
    template <input_iterator _Iter>
    _Base_flat_set(_Iter _First, _Iter _Last, const key_compare& _Comp = key_compare())
        : _Base_flat_set(container_type(_First, _Last), _Comp) {}
    template <input_iterator _Iter, _Allocator_for<container_type> _Alloc>
    _Base_flat_set(_Iter _First, _Iter _Last, const key_compare& _Comp, const _Alloc& _Al)
        : _Base_flat_set(container_type(_First, _Last, _Al), _Comp) {}
    template <input_iterator _Iter, _Allocator_for<container_type> _Alloc>
    _Base_flat_set(_Iter _First, _Iter _Last, const _Alloc& _Al) : _Base_flat_set(container_type(_First, _Last, _Al)) {}

    // FIXME, an allocator-aware container may not support "C(from_range, _STD forward<_Rng>(_Range), _Al)".
    template <_Container_compatible_range<_Kty> _Rng>
    _Base_flat_set(from_range_t, _Rng&& _Range)
        : _Base_flat_set(container_type(from_range, _STD forward<_Rng>(_Range))) {}
    template <_Container_compatible_range<_Kty> _Rng, _Allocator_for<container_type> _Alloc>
    _Base_flat_set(from_range_t, _Rng&& _Range, const _Alloc& _Al)
        : _Base_flat_set(container_type(from_range, _STD forward<_Rng>(_Range), _Al)) {}
    template <_Container_compatible_range<_Kty> _Rng>
    _Base_flat_set(from_range_t, _Rng&& _Range, const key_compare& _Comp)
        : _Base_flat_set(container_type(from_range, _STD forward<_Rng>(_Range)), _Comp) {}
    template <_Container_compatible_range<_Kty> _Rng, _Allocator_for<container_type> _Alloc>
    _Base_flat_set(from_range_t, _Rng&& _Range, const key_compare& _Comp, const _Alloc& _Al)
        : _Base_flat_set(container_type(from_range, _STD forward<_Rng>(_Range), _Al), _Comp) {}

    template <input_iterator _Iter>
    _Base_flat_set(_Tsorted _Tsort, _Iter _First, _Iter _Last, const key_compare& _Comp = key_compare())
        : _Base_flat_set(_Tsort, container_type(_First, _Last), _Comp) {}
    template <input_iterator _Iter, _Allocator_for<container_type> _Alloc>
    _Base_flat_set(_Tsorted _Tsort, _Iter _First, _Iter _Last, const key_compare& _Comp, const _Alloc& _Al)
        : _Base_flat_set(_Tsort, container_type(_First, _Last, _Al), _Comp) {}
    template <input_iterator _Iter, _Allocator_for<container_type> _Alloc>
    _Base_flat_set(_Tsorted _Tsort, _Iter _First, _Iter _Last, const _Alloc& _Al)
        : _Base_flat_set(_Tsort, container_type(_First, _Last, _Al)) {}

    // FIXME, an allocator-aware container may not support "C(_Ilist, _Al)".
    _Base_flat_set(initializer_list<_Kty> _Ilist, const key_compare& _Comp = key_compare())
        : _Base_flat_set(container_type(_Ilist), _Comp) {}
    template <_Allocator_for<container_type> _Alloc>
    _Base_flat_set(initializer_list<_Kty> _Ilist, const key_compare& _Comp, const _Alloc& _Al)
        : _Base_flat_set(container_type(_Ilist, _Al), _Comp) {}
    template <_Allocator_for<container_type> _Alloc>
    _Base_flat_set(initializer_list<_Kty> _Ilist, const _Alloc& _Al) : _Base_flat_set(container_type(_Ilist, _Al)) {}

    _Base_flat_set(_Tsorted _Tsort, initializer_list<_Kty> _Ilist, const key_compare& _Comp = key_compare())
        : _Base_flat_set(_Tsort, container_type(_Ilist), _Comp) {}
    template <_Allocator_for<container_type> _Alloc>
    _Base_flat_set(_Tsorted _Tsort, initializer_list<_Kty> _Ilist, const key_compare& _Comp, const _Alloc& _Al)
        : _Base_flat_set(_Tsort, container_type(_Ilist, _Al), _Comp) {}
    template <_Allocator_for<container_type> _Alloc>
    _Base_flat_set(_Tsorted _Tsort, initializer_list<_Kty> _Ilist, const _Alloc& _Al)
        : _Base_flat_set(_Tsort, container_type(_Ilist, _Al)) {}

    _Base_flat_set(const _Base_flat_set&) = default;
    _Base_flat_set(_Base_flat_set&& _Other) noexcept(
        is_nothrow_move_constructible_v<container_type>&& is_nothrow_copy_constructible_v<key_compare>) // strengthened
        : _Mycont(_STD move(_Other).extract()), _Mycomp(_Other._Mycomp) // intentionally copy comparator, see LWG-2227
    {}

    _Base_flat_set& operator=(const _Base_flat_set& _Other) {
        _Clear_guard<container_type> _Guard{_STD addressof(_Mycont)};
        _Mycont        = _Other._Mycont;
        _Mycomp        = _Other._Mycomp;
        _Guard._Target = nullptr;
        return *this;
    }
    _Base_flat_set& operator=(_Base_flat_set&& _Other) noexcept(
        is_nothrow_move_assignable_v<container_type>&& is_nothrow_copy_assignable_v<key_compare>) // strengthened
    {
        if (this != _STD addressof(_Other)) {
            _Clear_guard<container_type> _Guard{_STD addressof(_Mycont)};
            _Clear_guard<container_type> _Always_clear{_STD addressof(_Other._Mycont)};
            _Mycont        = _STD move(_Other._Mycont);
            _Mycomp        = _Other._Mycomp; // intentionally copy comparator, see LWG-2227
            _Guard._Target = nullptr;
        }
        return *this;
    }

    _Deriv& operator=(initializer_list<_Kty> _Ilist) {
        _Clear_guard<container_type> _Guard{_STD addressof(_Mycont)};
        _Mycont.assign(_Ilist);
        _Make_invariants_fulfilled();
        _Guard._Target = nullptr;
        return static_cast<_Deriv&>(*this);
    }

    // iterators
    _NODISCARD iterator begin() noexcept {
        return _Mycont.cbegin();
    }
    _NODISCARD const_iterator begin() const noexcept {
        return _Mycont.cbegin();
    }
    _NODISCARD iterator end() noexcept {
        return _Mycont.cend();
    }
    _NODISCARD const_iterator end() const noexcept {
        return _Mycont.cend();
    }

    _NODISCARD reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }
    _NODISCARD const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }
    _NODISCARD reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }
    _NODISCARD const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    _NODISCARD const_iterator cbegin() const noexcept {
        return _Mycont.cbegin();
    }
    _NODISCARD const_iterator cend() const noexcept {
        return _Mycont.cend();
    }
    _NODISCARD const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }
    _NODISCARD const_reverse_iterator crend() const noexcept {
        return rend();
    }

    // capacity
    _NODISCARD_EMPTY_MEMBER bool empty() const noexcept {
        return _Mycont.empty();
    }
    _NODISCARD size_type size() const noexcept {
        return _Mycont.size();
    }
    _NODISCARD size_type max_size() const noexcept {
        return _Mycont.max_size();
    }

    // modifiers
    // FIXME, the "insert" and "erase" methods may not be able to restore the invariant, if the underlying
    // container is unable to provide strong guarantee for "erase" and "insert" methods.
    template <class... _Args>
    auto emplace(_Args&&... _Vals) {
        constexpr bool _Is_key_type = _In_place_key_extract_set<_Kty, remove_cvref_t<_Args>...>::_Extractable;
        if constexpr (_Is_key_type) {
            return _Emplace(_STD forward<_Args>(_Vals)...);
        } else {
            return _Emplace(_Kty(_STD forward<_Args>(_Vals)...));
        }
    }
    template <class... _Args>
    iterator emplace_hint(const_iterator _Hint, _Args&&... _Vals) {
        constexpr bool _Is_key_type = _In_place_key_extract_set<_Kty, remove_cvref_t<_Args>...>::_Extractable;
        if constexpr (_Is_key_type) {
            return _Emplace_hint(_Hint, _STD forward<_Args>(_Vals)...);
        } else {
            return _Emplace_hint(_Hint, _Kty(_STD forward<_Args>(_Vals)...));
        }
    }

    auto insert(const _Kty& _Val) {
        return _Emplace(_Val);
    }
    auto insert(_Kty&& _Val) {
        return _Emplace(_STD move(_Val));
    }
    template <_Different_from<_Kty> _Other>
        requires (!_Multi && _Keylt_transparent && is_constructible_v<_Kty, _Other>)
    auto insert(_Other&& _Val) {
        return _Emplace(_STD forward<_Other>(_Val));
    }

    iterator insert(const_iterator _Hint, const _Kty& _Val) {
        return _Emplace_hint(_Hint, _Val);
    }
    iterator insert(const_iterator _Hint, _Kty&& _Val) {
        return _Emplace_hint(_Hint, _STD move(_Val));
    }
    template <_Different_from<_Kty> _Other>
        requires (!_Multi && _Keylt_transparent && is_constructible_v<_Kty, _Other>)
    iterator insert(const_iterator _Hint, _Other&& _Val) {
        return _Emplace_hint(_Hint, _STD forward<_Other>(_Val));
    }

    template <input_iterator _Iter>
    void insert(_Iter _First, _Iter _Last) {
        _Insert_range<false>(_First, _Last);
    }
    template <input_iterator _Iter>
    void insert(_Tsorted, _Iter _First, _Iter _Last) {
        _Insert_range<true>(_First, _Last);
    }
    template <_Container_compatible_range<_Kty> _Rng>
    void insert_range(_Rng&& _Range) {
        const size_type _Old_size = size();

        if constexpr (requires { _Mycont.append_range(_STD forward<_Rng>(_Range)); }) {
            _Mycont.append_range(_STD forward<_Rng>(_Range));
        } else {
            _Mycont.insert_range(_Mycont.end(), _STD forward<_Rng>(_Range));
        }
        _Restore_invariants_after_insert<false>(_Old_size);
    }

    void insert(initializer_list<_Kty> _Ilist) {
        _Insert_range<false>(_Ilist.begin(), _Ilist.end());
    }
    void insert(_Tsorted, initializer_list<_Kty> _Ilist) {
        _Insert_range<true>(_Ilist.begin(), _Ilist.end());
    }

    _NODISCARD container_type extract() && noexcept(
        is_nothrow_move_constructible_v<container_type>) /* strengthened */ {
        // always clears the container (N4950 [flat.set.modifiers]/14 and [flat.multiset.modifiers]/10)
        _Clear_guard<container_type> _Always_clear{_STD addressof(_Mycont)};
        return _STD move(_Mycont);
    }
    void replace(container_type&& _Cont) {
        _STL_ASSERT(_Is_sorted(_Cont), _Msg_not_sorted);
        _Clear_guard<container_type> _Guard{_STD addressof(_Mycont)};
        _Mycont        = _STD move(_Cont);
        _Guard._Target = nullptr;
    }

    iterator erase(iterator _Where)
        requires (!is_same_v<iterator, const_iterator>)
    {
        return _Mycont.erase(_Where);
    }
    iterator erase(const_iterator _Where) {
        return _Mycont.erase(_Where);
    }
    size_type erase(const _Kty& _Val) {
        return _Erase(_Val);
    }
    template <_Different_from<_Kty> _Other>
        requires (
            _Keylt_transparent && !is_convertible_v<_Other, iterator> && !is_convertible_v<_Other, const_iterator>)
    size_type erase(_Other&& _Val) {
        return _Erase(_Val);
    }
    iterator erase(const_iterator _First, const_iterator _Last) {
        return _Mycont.erase(_First, _Last);
    }

    void swap(_Deriv& _Other) noexcept {
        _RANGES swap(_Mycomp, _Other._Mycomp);
        _RANGES swap(_Mycont, _Other._Mycont);
    }
    void clear() noexcept {
        _Mycont.clear();
    }

    // observers
    _NODISCARD key_compare key_comp() const {
        return _Mycomp;
    }
    _NODISCARD value_compare value_comp() const {
        return _Mycomp;
    }

    _NODISCARD const container_type& _Get_container() const {
        return _Mycont;
    }

    // set operations
    _NODISCARD iterator find(const _Kty& _Val) {
        return _Find(_Val);
    }
    _NODISCARD const_iterator find(const _Kty& _Val) const {
        return _Find(_Val);
    }

    template <class _Other>
        requires _Keylt_transparent
    _NODISCARD iterator find(const _Other& _Val) {
        return _Find(_Val);
    }
    template <class _Other>
        requires _Keylt_transparent
    _NODISCARD const_iterator find(const _Other& _Val) const {
        return _Find(_Val);
    }

    _NODISCARD size_type count(const _Kty& _Val) const {
        if constexpr (_Multi) {
            const auto [_First, _Last] = equal_range(_Val);
            return static_cast<size_type>(_Last - _First);
        } else {
            return contains(_Val);
        }
    }
    template <class _Other>
        requires _Keylt_transparent
    _NODISCARD size_type count(const _Other& _Val) const {
        const auto [_First, _Last] = equal_range(_Val);
        return static_cast<size_type>(_Last - _First);
    }

    _NODISCARD bool contains(const _Kty& _Val) const {
        return _STD binary_search(cbegin(), cend(), _Val, _Pass_comp());
    }
    template <class _Other>
        requires _Keylt_transparent
    _NODISCARD bool contains(const _Other& _Val) const {
        return _STD binary_search(cbegin(), cend(), _Val, _Pass_comp());
    }

    _NODISCARD iterator lower_bound(const _Kty& _Val) {
        return _STD lower_bound(begin(), end(), _Val, _Pass_comp());
    }
    _NODISCARD const_iterator lower_bound(const _Kty& _Val) const {
        return _STD lower_bound(cbegin(), cend(), _Val, _Pass_comp());
    }

    template <class _Other>
        requires _Keylt_transparent
    _NODISCARD iterator lower_bound(const _Other& _Val) {
        return _STD lower_bound(begin(), end(), _Val, _Pass_comp());
    }
    template <class _Other>
        requires _Keylt_transparent
    _NODISCARD const_iterator lower_bound(const _Other& _Val) const {
        return _STD lower_bound(cbegin(), cend(), _Val, _Pass_comp());
    }

    _NODISCARD iterator upper_bound(const _Kty& _Val) {
        return _STD upper_bound(begin(), end(), _Val, _Pass_comp());
    }
    _NODISCARD const_iterator upper_bound(const _Kty& _Val) const {
        return _STD upper_bound(cbegin(), cend(), _Val, _Pass_comp());
    }

    template <class _Other>
        requires _Keylt_transparent
    _NODISCARD iterator upper_bound(const _Other& _Val) {
        return _STD upper_bound(begin(), end(), _Val, _Pass_comp());
    }
    template <class _Other>
        requires _Keylt_transparent
    _NODISCARD const_iterator upper_bound(const _Other& _Val) const {
        return _STD upper_bound(cbegin(), cend(), _Val, _Pass_comp());
    }

    _NODISCARD pair<iterator, iterator> equal_range(const _Kty& _Val) {
        return _STD equal_range(begin(), end(), _Val, _Pass_comp());
    }
    _NODISCARD pair<const_iterator, const_iterator> equal_range(const _Kty& _Val) const {
        return _STD equal_range(cbegin(), cend(), _Val, _Pass_comp());
    }

    template <class _Other>
        requires _Keylt_transparent
    _NODISCARD pair<iterator, iterator> equal_range(const _Other& _Val) {
        return _STD equal_range(begin(), end(), _Val, _Pass_comp());
    }
    template <class _Other>
        requires _Keylt_transparent
    _NODISCARD pair<const_iterator, const_iterator> equal_range(const _Other& _Val) const {
        return _STD equal_range(cbegin(), cend(), _Val, _Pass_comp());
    }

    _NODISCARD friend bool operator==(const _Deriv& _Lhs, const _Deriv& _Rhs) {
        return _RANGES equal(_Lhs._Mycont, _Rhs._Mycont);
    }

    _NODISCARD friend auto operator<=>(const _Deriv& _Lhs, const _Deriv& _Rhs) {
        return _STD lexicographical_compare_three_way(
            _Lhs.cbegin(), _Lhs.cend(), _Rhs.cbegin(), _Rhs.cend(), _Synth_three_way{});
    }

    friend void swap(_Deriv& _Lhs, _Deriv& _Rhs) noexcept {
        _Lhs.swap(_Rhs);
    }

private:
    _NODISCARD bool _Is_sorted(const_iterator _It, const const_iterator _End) const {
        if constexpr (_Multi) {
            return _STD is_sorted(_It, _End, _Pass_comp());
        } else {
            // sorted-unique
            if (_It == _End) {
                return true;
            }
            while (++_It != _End) {
                if (!_Compare(*(_It - 1), *_It)) {
                    return false;
                }
            }
            return true;
        }
    }

    _NODISCARD bool _Is_sorted(const container_type& _Cont) const {
        return _Is_sorted(_Cont.cbegin(), _Cont.cend());
    }

    static constexpr const char* _Msg_not_sorted = _Multi ? "Input was not sorted!" : "Input was not sorted-unique!";

    template <class _Ty>
    _NODISCARD bool _Can_insert(const const_iterator _Where, const _Ty& _Val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty, _Kty>); // only accepts _Kty

        // check that _Val can be inserted before _Where
        if constexpr (_Multi) {
            // check that _Where is the upper_bound for _Val
            // equivalent to checking *(_Where-1) <= _Val < *_Where
            return (_Where == cend() || _Compare(_Val, *_Where))
                && (_Where == cbegin() || !_Compare(_Val, *(_Where - 1)));
        } else {
            // check that _Where is the lower_bound for _Val, and *_Where is not equivalent to _Val
            // equivalent to checking *(_Where-1) < _Val < *_Where
            return (_Where == cend() || _Compare(_Val, *_Where))
                && (_Where == cbegin() || _Compare(*(_Where - 1), _Val));
        }
    }

    template <class _Ty>
        requires _Multi // flat_multiset
    _NODISCARD iterator _Emplace(_Ty&& _Val) {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<remove_cvref_t<_Ty>, _Kty>);
        return _Mycont.emplace(upper_bound(_Val), _STD forward<_Ty>(_Val));
    }

    template <class _Ty>
        requires (!_Multi) // flat_set
    _NODISCARD pair<iterator, bool> _Emplace(_Ty&& _Val) {
        const const_iterator _Where = lower_bound(_Val);
        if (_Where != cend() && !_Compare(_Val, *_Where)) {
            return pair{_Where, false};
        }

        if constexpr (is_same_v<remove_cvref_t<_Ty>, _Kty>) {
            _STL_INTERNAL_CHECK(_Can_insert(_Where, _Val));
            return pair{_Mycont.emplace(_Where, _STD forward<_Ty>(_Val)), true};
        } else {
            // heterogeneous insertion
            // FIXME: The standard only requires `find(_Val) == find(_Keyval)` (per N4958 [flat.set.modifiers]/2),
            // which cannot guarantee `_Can_insert(_Where, _Keyval)`.
            _STL_INTERNAL_STATIC_ASSERT(_Keylt_transparent && is_constructible_v<_Kty, _Ty>);
            _Kty _Keyval(_STD forward<_Ty>(_Val));
            _STL_ASSERT(_Can_insert(_Where, _Keyval), "The conversion from the heterogeneous key to key_type should "
                                                      "be consistent with the heterogeneous lookup!");
            return pair{_Mycont.emplace(_Where, _STD move(_Keyval)), true};
        }
    }

    template <class _Ty>
        requires _Multi // flat_multiset
    _NODISCARD iterator _Emplace_hint(const_iterator _Where, _Ty&& _Val) {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<remove_cvref_t<_Ty>, _Kty>);

        const const_iterator _Begin = cbegin();
        const const_iterator _End   = cend();

        // look for upper_bound(_Val)
        if (_Where == _End || _Compare(_Val, *_Where)) {
            // _Val < *_Where
            if (_Where == _Begin || !_Compare(_Val, *(_Where - 1))) {
                // _Val >= *(_Where-1) ~ upper_bound is _Where
            } else {
                // _Val < *(_Where-1) ~ upper_bound is in [_Begin,_Where-1]
                _Where = _STD upper_bound(_Begin, _Where - 1, _Val, _Pass_comp());
            }
        } else {
            // _Val >= *_Where ~ upper_bound is in [_Where+1,_End]
            _Where = _STD upper_bound(_Where + 1, _End, _Val, _Pass_comp());
        }

        _STL_INTERNAL_CHECK(_Can_insert(_Where, _Val));
        return _Mycont.emplace(_Where, _STD forward<_Ty>(_Val));
    }

    template <class _Ty>
        requires (!_Multi) // flat_set
    _NODISCARD iterator _Emplace_hint(const_iterator _Where, _Ty&& _Val) {
        const const_iterator _Begin = cbegin();
        const const_iterator _End   = cend();

        // look for lower_bound(_Val)
        if (_Where == _End || !_Compare(*_Where, _Val)) {
            // _Val <= *_Where
            if (_Where == _Begin || _Compare(*(_Where - 1), _Val)) {
                // _Val > *(_Where-1) ~ lower_bound is _Where
            } else {
                // _Val <= *(_Where-1) ~ lower_bound is in [_Begin,_Where-1]
                _Where = _STD lower_bound(_Begin, _Where - 1, _Val, _Pass_comp());
            }
        } else {
            // _Val > *_Where ~ lower_bound is in [_Where+1,_End]
            _Where = _STD lower_bound(_Where + 1, _End, _Val, _Pass_comp());
        }

        if (_Where != _End && !_Compare(_Val, *_Where)) {
            return _Where;
        }

        if constexpr (is_same_v<remove_cvref_t<_Ty>, _Kty>) {
            _STL_INTERNAL_CHECK(_Can_insert(_Where, _Val));
            return _Mycont.emplace(_Where, _STD forward<_Ty>(_Val));
        } else {
            // heterogeneous insertion
            // FIXME: The standard only requires `find(_Val) == find(_Keyval)` (per N4958 [flat.set.modifiers]/2),
            // which cannot guarantee `_Can_insert(_Where, _Keyval)`.
            _STL_INTERNAL_STATIC_ASSERT(_Keylt_transparent && is_constructible_v<_Kty, _Ty>);
            _Kty _Keyval(_STD forward<_Ty>(_Val));
            _STL_ASSERT(_Can_insert(_Where, _Keyval), "The conversion from the heterogeneous key to key_type should "
                                                      "be consistent with the heterogeneous lookup!");
            return _Mycont.emplace(_Where, _STD move(_Keyval));
        }
    }

    template <bool _Presorted, class _Iter>
    void _Insert_range(const _Iter _First, const _Iter _Last) {
        const size_type _Old_size = size();
        _Mycont.insert(_Mycont.end(), _First, _Last);
        _Restore_invariants_after_insert<_Presorted>(_Old_size);
    }

    template <class _Ty>
    _NODISCARD size_type _Erase(const _Ty& _Val) {
        _STL_INTERNAL_STATIC_ASSERT(_Keylt_transparent || is_same_v<_Ty, _Kty>);

        if constexpr (!_Multi && is_same_v<_Ty, _Kty>) {
            const const_iterator _Where = lower_bound(_Val);
            if (_Where != cend() && !_Compare(_Val, *_Where)) {
                _Mycont.erase(_Where);
                return 1;
            }
            return 0;
        } else {
            const auto [_First, _Last] = equal_range(_Val);

            const auto _Removed = static_cast<size_type>(_Last - _First);
            _Mycont.erase(_First, _Last);
            return _Removed;
        }
    }

    template <class _Ty>
    _NODISCARD const_iterator _Find(const _Ty& _Val) const {
        _STL_INTERNAL_STATIC_ASSERT(_Keylt_transparent || is_same_v<_Ty, _Kty>);

        const const_iterator _End   = cend();
        const const_iterator _Where = lower_bound(_Val);
        if (_Where != _End && !_Compare(_Val, *_Where)) {
            return _Where;
        } else {
            return _End;
        }
    }

    void _Erase_dupes_if_not_multi() {
        if constexpr (!_Multi) {
            const auto _Equivalent = [this](const _Kty& _Lhs, const _Kty& _Rhs) {
                return !_Compare(_Lhs, _Rhs) && !_Compare(_Rhs, _Lhs);
            };
            const auto _End = _Mycont.end();
            _Mycont.erase(_STD unique(_Mycont.begin(), _End, _Equivalent), _End);
        }
    }

    template <bool _Presorted>
    void _Restore_invariants_after_insert(const size_type _Old_size) {
        const auto _Begin   = _Mycont.begin();
        const auto _Old_end = _Begin + static_cast<difference_type>(_Old_size);
        const auto _End     = _Mycont.end();

        if constexpr (!_Presorted) {
            _STD sort(_Old_end, _End, _Pass_comp());
        } else {
            _STL_ASSERT(_Is_sorted(_Old_end, _End), _Msg_not_sorted);
        }

        _STD inplace_merge(_Begin, _Old_end, _End, _Pass_comp());
        _Erase_dupes_if_not_multi();

        _STL_INTERNAL_CHECK(_Is_sorted(_Mycont));
    }

    void _Make_invariants_fulfilled() {
        const auto _Begin = _Mycont.begin();
        const auto _End   = _Mycont.end();

        if (_Begin == _End) {
            return;
        }

        // O(N) if already sorted.
        const auto _Begin_unsorted = _STD is_sorted_until(_Begin, _End, _Pass_comp());

        _STD sort(_Begin_unsorted, _End, _Pass_comp());
        _STD inplace_merge(_Begin, _Begin_unsorted, _End, _Pass_comp());
        _Erase_dupes_if_not_multi();

        _STL_INTERNAL_CHECK(_Is_sorted(_Mycont));
    }

    template <class _Lty, class _Rty>
    _NODISCARD bool _Compare(const _Lty& _Lhs, const _Rty& _Rhs) const
        noexcept(noexcept(_DEBUG_LT_PRED(_Mycomp, _Lhs, _Rhs))) {
        _STL_INTERNAL_STATIC_ASSERT(_Keylt_transparent || (is_same_v<_Kty, _Lty> && is_same_v<_Kty, _Rty>) );

        return _DEBUG_LT_PRED(_Mycomp, _Lhs, _Rhs);
    }

    _NODISCARD auto _Pass_comp() const noexcept {
        return _STD _Pass_fn(_Mycomp);
    }

    container_type _Mycont;
    /* [[no_unique_address]] */ key_compare _Mycomp;
};

_EXPORT_STD struct sorted_unique_t {
    explicit sorted_unique_t() = default;
};
_EXPORT_STD inline constexpr sorted_unique_t sorted_unique{};

_EXPORT_STD struct sorted_equivalent_t {
    explicit sorted_equivalent_t() = default;
};
_EXPORT_STD inline constexpr sorted_equivalent_t sorted_equivalent{};

_EXPORT_STD template <class _Kty, class _Keylt = less<_Kty>, class _Container = vector<_Kty>>
class flat_set
    : public _Base_flat_set<_Kty, _Keylt, _Container, false, flat_set<_Kty, _Keylt, _Container>, sorted_unique_t> {
private:
    using _Mybase = _Base_flat_set<_Kty, _Keylt, _Container, false, flat_set, sorted_unique_t>;

public:
    using _Mybase::_Mybase;
    flat_set(const flat_set&) = default;
    flat_set(flat_set&&)      = default;

    using _Mybase::operator=;
    flat_set& operator=(const flat_set&) = default;
    flat_set& operator=(flat_set&&)      = default;
};

_EXPORT_STD template <class _Kty, class _Keylt = less<_Kty>, class _Container = vector<_Kty>>
class flat_multiset : public _Base_flat_set<_Kty, _Keylt, _Container, true, flat_multiset<_Kty, _Keylt, _Container>,
                          sorted_equivalent_t> {
private:
    using _Mybase = _Base_flat_set<_Kty, _Keylt, _Container, true, flat_multiset, sorted_equivalent_t>;

public:
    using _Mybase::_Mybase;
    flat_multiset(const flat_multiset&) = default;
    flat_multiset(flat_multiset&&)      = default;

    using _Mybase::operator=;
    flat_multiset& operator=(const flat_multiset&) = default;
    flat_multiset& operator=(flat_multiset&&)      = default;
};

_EXPORT_STD template <class _Kty, class _Keylt, class _Container, class _Pred>
_Container::size_type erase_if(flat_set<_Kty, _Keylt, _Container>& _Val, _Pred _Predicate) {
    // clears the container to maintain the invariants when an exception is thrown (N4950 [flat.set.erasure]/5)
    _Container& _Cont = const_cast<_Container&>(_Val._Get_container());
    _Clear_guard<_Container> _Guard{_STD addressof(_Cont)};
    const auto _Erased_count = _STD _Erase_remove_if(_Cont, _STD _Pass_fn(_Predicate));
    _Guard._Target           = nullptr;
    return _Erased_count;
}

_EXPORT_STD template <class _Kty, class _Keylt, class _Container, class _Pred>
_Container::size_type erase_if(flat_multiset<_Kty, _Keylt, _Container>& _Val, _Pred _Predicate) {
    // clears the container to maintain the invariants when an exception is thrown (N4950 [flat.multiset.erasure]/5)
    _Container& _Cont = const_cast<_Container&>(_Val._Get_container());
    _Clear_guard<_Container> _Guard{_STD addressof(_Cont)};
    const auto _Erased_count = _STD _Erase_remove_if(_Cont, _STD _Pass_fn(_Predicate));
    _Guard._Target           = nullptr;
    return _Erased_count;
}

template <class _Kty, class _Keylt, class _Container, class _Alloc>
struct uses_allocator<flat_set<_Kty, _Keylt, _Container>, _Alloc>
    : bool_constant<uses_allocator_v<_Container, _Alloc>> {};

template <class _Kty, class _Keylt, class _Container, class _Alloc>
struct uses_allocator<flat_multiset<_Kty, _Keylt, _Container>, _Alloc>
    : bool_constant<uses_allocator_v<_Container, _Alloc>> {};

template <class _Container, class _Keylt = less<typename _Container::value_type>>
flat_set(_Container, _Keylt = _Keylt()) -> flat_set<typename _Container::value_type, _Keylt, _Container>;
template <class _Container, class _Alloc>
flat_set(_Container, _Alloc)
    -> flat_set<typename _Container::value_type, less<typename _Container::value_type>, _Container>;
template <class _Container, class _Keylt, class _Alloc>
flat_set(_Container, _Keylt, _Alloc) -> flat_set<typename _Container::value_type, _Keylt, _Container>;

template <class _Container, class _Keylt = less<typename _Container::value_type>>
flat_set(sorted_unique_t, _Container, _Keylt = _Keylt())
    -> flat_set<typename _Container::value_type, _Keylt, _Container>;
template <class _Container, class _Alloc>
flat_set(sorted_unique_t, _Container, _Alloc)
    -> flat_set<typename _Container::value_type, less<typename _Container::value_type>, _Container>;
template <class _Container, class _Keylt, class _Alloc>
flat_set(sorted_unique_t, _Container, _Keylt, _Alloc) -> flat_set<typename _Container::value_type, _Keylt, _Container>;

template <class _Iter, class _Keylt = less<iter_value_t<_Iter>>>
flat_set(_Iter, _Iter, _Keylt = _Keylt()) -> flat_set<iter_value_t<_Iter>, _Keylt>;
template <class _Iter, class _Keylt = less<iter_value_t<_Iter>>>
flat_set(sorted_unique_t, _Iter, _Iter, _Keylt = _Keylt()) -> flat_set<iter_value_t<_Iter>, _Keylt>;
template <_RANGES input_range _Range, class _Keylt = less<_RANGES range_value_t<_Range>>,
    class _Alloc = allocator<_RANGES range_value_t<_Range>>>
flat_set(from_range_t, _Range&&, _Keylt = _Keylt(), _Alloc = _Alloc()) -> flat_set<_RANGES range_value_t<_Range>,
    _Keylt, vector<_RANGES range_value_t<_Range>, _Rebind_alloc_t<_Alloc, _RANGES range_value_t<_Range>>>>;
template <_RANGES input_range _Range, class _Alloc>
flat_set(from_range_t, _Range&&, _Alloc) -> flat_set<_RANGES range_value_t<_Range>, less<_RANGES range_value_t<_Range>>,
    vector<_RANGES range_value_t<_Range>, _Rebind_alloc_t<_Alloc, _RANGES range_value_t<_Range>>>>;
template <class _Kty, class _Keylt = less<_Kty>>
flat_set(initializer_list<_Kty>, _Keylt = _Keylt()) -> flat_set<_Kty, _Keylt>;
template <class _Kty, class _Keylt = less<_Kty>>
flat_set(sorted_unique_t, initializer_list<_Kty>, _Keylt = _Keylt()) -> flat_set<_Kty, _Keylt>;


template <class _Container, class _Keylt = less<typename _Container::value_type>>
flat_multiset(_Container, _Keylt = _Keylt()) -> flat_multiset<typename _Container::value_type, _Keylt, _Container>;
template <class _Container, class _Alloc>
flat_multiset(_Container, _Alloc)
    -> flat_multiset<typename _Container::value_type, less<typename _Container::value_type>, _Container>;
template <class _Container, class _Keylt, class _Alloc>
flat_multiset(_Container, _Keylt, _Alloc) -> flat_multiset<typename _Container::value_type, _Keylt, _Container>;

template <class _Container, class _Keylt = less<typename _Container::value_type>>
flat_multiset(sorted_equivalent_t, _Container, _Keylt = _Keylt())
    -> flat_multiset<typename _Container::value_type, _Keylt, _Container>;
template <class _Container, class _Alloc>
flat_multiset(sorted_equivalent_t, _Container, _Alloc)
    -> flat_multiset<typename _Container::value_type, less<typename _Container::value_type>, _Container>;
template <class _Container, class _Keylt, class _Alloc>
flat_multiset(sorted_equivalent_t, _Container, _Keylt, _Alloc)
    -> flat_multiset<typename _Container::value_type, _Keylt, _Container>;

template <class _Iter, class _Keylt = less<iter_value_t<_Iter>>>
flat_multiset(_Iter, _Iter, _Keylt = _Keylt()) -> flat_multiset<iter_value_t<_Iter>, iter_value_t<_Iter>, _Keylt>;
template <class _Iter, class _Keylt = less<iter_value_t<_Iter>>>
flat_multiset(sorted_equivalent_t, _Iter, _Iter, _Keylt = _Keylt())
    -> flat_multiset<iter_value_t<_Iter>, iter_value_t<_Iter>, _Keylt>;
template <_RANGES input_range _Range, class _Keylt = less<_RANGES range_value_t<_Range>>,
    class _Alloc = allocator<_RANGES range_value_t<_Range>>>
flat_multiset(from_range_t, _Range&&, _Keylt = _Keylt(), _Alloc = _Alloc())
    -> flat_multiset<_RANGES range_value_t<_Range>, _Keylt,
        vector<_RANGES range_value_t<_Range>, _Rebind_alloc_t<_Alloc, _RANGES range_value_t<_Range>>>>;
template <_RANGES input_range _Range, class _Alloc>
flat_multiset(from_range_t, _Range&&, _Alloc)
    -> flat_multiset<_RANGES range_value_t<_Range>, less<_RANGES range_value_t<_Range>>,
        vector<_RANGES range_value_t<_Range>, _Rebind_alloc_t<_Alloc, _RANGES range_value_t<_Range>>>>;
template <class _Kty, class _Keylt = less<_Kty>>
flat_multiset(initializer_list<_Kty>, _Keylt = _Keylt()) -> flat_multiset<_Kty, _Keylt>;
template <class _Kty, class _Keylt = less<_Kty>>
flat_multiset(sorted_equivalent_t, initializer_list<_Kty>, _Keylt = _Keylt()) -> flat_multiset<_Kty, _Keylt>;

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // ^^^ supported language mode ^^^
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _FLAT_SET_
