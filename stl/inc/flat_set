// flat_set standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _FLAT_SET_
#define _FLAT_SET_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR
#if !_HAS_CXX23
_EMIT_STL_WARNING(STL4038, "The contents of <flat_set> are available only with C++23 or later.");
#else // ^^^ !_HAS_CXX23 / _HAS_CXX23 vvv
#include <algorithm>
#include <compare>
#include <initializer_list>
#include <vector>
#include <xutility>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

// TRANSITION, non-_Ugly attribute tokens
#pragma push_macro("msvc")
#undef msvc

_STD_BEGIN
template <bool _IsNoexcept, class _Container>
struct _NODISCARD _Flat_set_swap_clear_guard {
    // Invariant: (_Target1 == nullptr) == (_Target2 == nullptr)
    _Container* _Target1;
    _Container* _Target2;

    _Flat_set_swap_clear_guard& operator=(const _Flat_set_swap_clear_guard&) = delete;

    void _Dismiss() noexcept {
        _Target1 = nullptr;
        _Target2 = nullptr;
    }

    ~_Flat_set_swap_clear_guard() {
        if (_Target1) {
            _Target1->clear();
            _Target2->clear();
        }
    }
};
template <class _Container>
struct _NODISCARD _Flat_set_swap_clear_guard<true, _Container> {
    constexpr explicit _Flat_set_swap_clear_guard(_Container*, _Container*) noexcept {}

    _Flat_set_swap_clear_guard& operator=(const _Flat_set_swap_clear_guard&) = delete;

    void _Dismiss() noexcept {}
};

_EXPORT_STD template <class _Key, class _Compare = less<_Key>, class _Container = vector<_Key>>
class flat_set;

_EXPORT_STD template <class _Key, class _Compare = less<_Key>, class _Container = vector<_Key>>
class flat_multiset;

template <bool _IsUnique, class _Key, class _Compare, class _Container>
class _Flat_set_base {
private:
    using _Sorted_t = conditional_t<_IsUnique, sorted_unique_t, sorted_equivalent_t>;
    using _Derived =
        conditional_t<_IsUnique, flat_set<_Key, _Compare, _Container>, flat_multiset<_Key, _Compare, _Container>>;

    static constexpr const char* _Msg_not_sorted = //
        _IsUnique ? "Input was not sorted-unique! (N5032 [flat.set.overview]/9)"
                  : "Input was not sorted! (N5032 [flat.multiset.overview]/9)";
    static constexpr const char* _Msg_replace_not_sorted =
        _IsUnique ? "Input was not sorted-unique! (N5032 [flat.set.modifiers]/18)"
                  : "Input was not sorted! (N5032 [flat.multiset.modifiers]/17)";
    static constexpr const char* _Msg_heterogeneous_insertion_inconsistent_with_lookup =
        "The conversion from the heterogeneous key to key_type should be consistent with the heterogeneous lookup!";

public:
    // [flat.set.defn] Types
    using key_type               = _Key;
    using value_type             = _Key;
    using key_compare            = _Compare;
    using value_compare          = _Compare;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using size_type              = _Container::size_type;
    using difference_type        = _Container::difference_type;
    using const_iterator         = _Container::const_iterator;
    using iterator               = const_iterator;
    using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
    using reverse_iterator       = const_reverse_iterator;
    using container_type         = _Container;

    static_assert(same_as<key_type, typename container_type::value_type>,
        "key_type and container_type::value_type must be the same. "
        "(N5032 [flat.set.overview]/8, [flat.multiset.overview]/8)");
    static_assert(!_Is_vector_bool<container_type>,
        "vector<bool> cannot be adapted because it is not a sequence container. "
        "(N5032 [flat.set.overview]/7, [flat.multiset.overview]/7)");
    static_assert(random_access_iterator<typename container_type::const_iterator>,
        "Sequence containers must support random-access iterators in order to be adapted. "
        "(N5032 [flat.set.overview]/7, [flat.multiset.overview]/7)");

    // [flat.set.cons] Constructors
    _Flat_set_base() : _Data(), _Key_compare() {}

    _Flat_set_base(const _Flat_set_base&) = default;

    _Flat_set_base(_Flat_set_base&& _Other) noexcept(
        is_nothrow_move_constructible_v<container_type> && is_nothrow_copy_constructible_v<key_compare>) // strengthened
        : _Data(_STD move(_Other).extract()),
          _Key_compare(_Other._Key_compare) // intentionally copy comparator, see LWG-2227
    {}

    explicit _Flat_set_base(const key_compare& _Comp) : _Data(), _Key_compare(_Comp) {}

    explicit _Flat_set_base(container_type _Cont, const key_compare& _Comp = key_compare())
        : _Data(_STD move(_Cont)), _Key_compare(_Comp) {
        _Establish_invariants();
    }

    _Flat_set_base(_Sorted_t, container_type _Cont, const key_compare& _Comp = key_compare())
        : _Data(_STD move(_Cont)), _Key_compare(_Comp) {
        _STL_ASSERT(_Is_sorted_and_unique(), _Msg_not_sorted);
    }

    template <_Iterator_for_container _InIt>
    _Flat_set_base(const _InIt _First, const _InIt _Last, const key_compare& _Comp = key_compare())
        : _Data(_First, _Last), _Key_compare(_Comp) {
        _Establish_invariants();
    }

    template <_Iterator_for_container _InIt>
    _Flat_set_base(_Sorted_t, const _InIt _First, const _InIt _Last, const key_compare& _Comp = key_compare())
        : _Data(_First, _Last), _Key_compare(_Comp) {
        _STL_ASSERT(_Is_sorted_and_unique(), _Msg_not_sorted);
    }

    template <_Container_compatible_range<value_type> _Rng>
    _Flat_set_base(from_range_t, _Rng&& _Range) : _Data(from_range, _STD forward<_Rng>(_Range)), _Key_compare() {
        _Establish_invariants();
    }

    template <_Container_compatible_range<value_type> _Rng>
    _Flat_set_base(from_range_t, _Rng&& _Range, const key_compare& _Comp)
        : _Data(from_range, _STD forward<_Rng>(_Range)), _Key_compare(_Comp) {
        _Establish_invariants();
    }

    _Flat_set_base(const initializer_list<value_type> _Ilist, const key_compare& _Comp = key_compare())
        : _Data(_Ilist.begin(), _Ilist.end()), _Key_compare(_Comp) {
        _Establish_invariants();
    }

    _Flat_set_base(_Sorted_t, const initializer_list<value_type> _Ilist, const key_compare& _Comp = key_compare())
        : _Data(_Ilist.begin(), _Ilist.end()), _Key_compare(_Comp) {
        _STL_ASSERT(_Is_sorted_and_unique(), _Msg_not_sorted);
    }

    // [flat.set.cons.alloc] Constructors with allocators
    template <_Usable_allocator_for<container_type> _Alloc>
    explicit _Flat_set_base(const _Alloc& _Al)
        : _Data(_STD make_obj_using_allocator<container_type>(_Al)), _Key_compare() {}

    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(const key_compare& _Comp, const _Alloc& _Al)
        : _Data(_STD make_obj_using_allocator<container_type>(_Al)), _Key_compare(_Comp) {}

    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(const container_type& _Cont, const _Alloc& _Al)
        : _Data(_STD make_obj_using_allocator<container_type>(_Al, _Cont)), _Key_compare() {
        _Establish_invariants();
    }

    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(const container_type& _Cont, const key_compare& _Comp, const _Alloc& _Al)
        : _Data(_STD make_obj_using_allocator<container_type>(_Al, _Cont)), _Key_compare(_Comp) {
        _Establish_invariants();
    }

    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(_Sorted_t, const container_type& _Cont, const _Alloc& _Al)
        : _Data(_STD make_obj_using_allocator<container_type>(_Al, _Cont)), _Key_compare() {
        _STL_ASSERT(_Is_sorted_and_unique(), _Msg_not_sorted);
    }

    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(_Sorted_t, const container_type& _Cont, const key_compare& _Comp, const _Alloc& _Al)
        : _Data(_STD make_obj_using_allocator<container_type>(_Al, _Cont)), _Key_compare(_Comp) {
        _STL_ASSERT(_Is_sorted_and_unique(), _Msg_not_sorted);
    }

    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(const _Flat_set_base& _Other, const _Alloc& _Al)
        : _Data(_STD make_obj_using_allocator<container_type>(_Al, _Other._Data)), _Key_compare(_Other._Key_compare) {}

    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(_Flat_set_base&& _Other, const _Alloc& _Al)
        : _Data(_STD make_obj_using_allocator<container_type>(_Al, _STD move(_Other).extract())),
          _Key_compare(_Other._Key_compare) // intentionally copy comparator, see LWG-2227
    {}

    template <_Iterator_for_container _InIt, _Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(const _InIt _First, const _InIt _Last, const _Alloc& _Al)
        : _Data(_STD make_obj_using_allocator<container_type>(_Al, _First, _Last)), _Key_compare() {
        _Establish_invariants();
    }

    template <_Iterator_for_container _InIt, _Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(const _InIt _First, const _InIt _Last, const key_compare& _Comp, const _Alloc& _Al)
        : _Data(_STD make_obj_using_allocator<container_type>(_Al, _First, _Last)), _Key_compare(_Comp) {
        _Establish_invariants();
    }

    template <_Iterator_for_container _InIt, _Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(_Sorted_t, const _InIt _First, const _InIt _Last, const _Alloc& _Al)
        : _Data(_STD make_obj_using_allocator<container_type>(_Al, _First, _Last)), _Key_compare() {
        _STL_ASSERT(_Is_sorted_and_unique(), _Msg_not_sorted);
    }

    template <_Iterator_for_container _InIt, _Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(_Sorted_t, const _InIt _First, const _InIt _Last, const key_compare& _Comp, const _Alloc& _Al)
        : _Data(_STD make_obj_using_allocator<container_type>(_Al, _First, _Last)), _Key_compare(_Comp) {
        _STL_ASSERT(_Is_sorted_and_unique(), _Msg_not_sorted);
    }

    template <_Container_compatible_range<value_type> _Rng, _Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(from_range_t, _Rng&& _Range, const _Alloc& _Al)
        : _Data(_STD make_obj_using_allocator<container_type>(_Al, from_range, _STD forward<_Rng>(_Range))),
          _Key_compare() {
        _Establish_invariants();
    }

    template <_Container_compatible_range<value_type> _Rng, _Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(from_range_t, _Rng&& _Range, const key_compare& _Comp, const _Alloc& _Al)
        : _Data(_STD make_obj_using_allocator<container_type>(_Al, from_range, _STD forward<_Rng>(_Range))),
          _Key_compare(_Comp) {
        _Establish_invariants();
    }

    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(const initializer_list<value_type> _Ilist, const _Alloc& _Al)
        : _Data(_STD make_obj_using_allocator<container_type>(_Al, _Ilist.begin(), _Ilist.end())), _Key_compare() {
        _Establish_invariants();
    }

    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(const initializer_list<value_type> _Ilist, const key_compare& _Comp, const _Alloc& _Al)
        : _Data(_STD make_obj_using_allocator<container_type>(_Al, _Ilist.begin(), _Ilist.end())), _Key_compare(_Comp) {
        _Establish_invariants();
    }

    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(_Sorted_t, const initializer_list<value_type> _Ilist, const _Alloc& _Al)
        : _Data(_STD make_obj_using_allocator<container_type>(_Al, _Ilist.begin(), _Ilist.end())), _Key_compare() {
        _STL_ASSERT(_Is_sorted_and_unique(), _Msg_not_sorted);
    }

    template <_Usable_allocator_for<container_type> _Alloc>
    _Flat_set_base(_Sorted_t, const initializer_list<value_type> _Ilist, const key_compare& _Comp, const _Alloc& _Al)
        : _Data(_STD make_obj_using_allocator<container_type>(_Al, _Ilist.begin(), _Ilist.end())), _Key_compare(_Comp) {
        _STL_ASSERT(_Is_sorted_and_unique(), _Msg_not_sorted);
    }

    // Assignment operators
    _Flat_set_base& operator=(const _Flat_set_base& _Other) {
        _Clear_guard _Guard{this};
        _Data          = _Other._Data;
        _Key_compare   = _Other._Key_compare;
        _Guard._Target = nullptr;
        return *this;
    }

    _Flat_set_base& operator=(_Flat_set_base&& _Other) noexcept(
        is_nothrow_move_assignable_v<container_type> && is_nothrow_copy_assignable_v<key_compare>) /* strengthened */ {
        if (this != _STD addressof(_Other)) {
            _Clear_guard _Guard{this};
            _Clear_guard _Always_clear{_STD addressof(_Other)};
            _Data          = _STD move(_Other._Data);
            _Key_compare   = _Other._Key_compare; // intentionally copy comparator, see LWG-2227
            _Guard._Target = nullptr;
        }
        return *this;
    }

    // Iterators
    // NB: The non-const overloads are intentionally removed for brevity. This will not result in behavioral changes.
    _NODISCARD const_iterator begin() const noexcept {
        return _Data.begin();
    }
    _NODISCARD const_iterator end() const noexcept {
        return _Data.end();
    }

    _NODISCARD const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator{_Data.end()};
    }
    _NODISCARD const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator{_Data.begin()};
    }

    _NODISCARD const_iterator cbegin() const noexcept {
        return _Data.begin();
    }
    _NODISCARD const_iterator cend() const noexcept {
        return _Data.end();
    }

    _NODISCARD const_reverse_iterator crbegin() const noexcept {
        return const_reverse_iterator{_Data.end()};
    }
    _NODISCARD const_reverse_iterator crend() const noexcept {
        return const_reverse_iterator{_Data.begin()};
    }

    // Capacity
    _NODISCARD_EMPTY_MEMBER bool empty() const noexcept {
        return _Data.empty();
    }
    _NODISCARD size_type size() const noexcept {
        return _Data.size();
    }
    _NODISCARD size_type max_size() const noexcept {
        return _Data.max_size();
    }

    // [flat.set.modifiers] Modifiers
    template <class... _ArgTypes>
    auto emplace(_ArgTypes&&... _Args)
        requires is_constructible_v<value_type, _ArgTypes...>
    {
        constexpr bool _Is_key_type = _In_place_key_extract_set<key_type, remove_cvref_t<_ArgTypes>...>::_Extractable;
        if constexpr (_Is_key_type) {
            return _Emplace(_STD forward<_ArgTypes>(_Args)...);
        } else {
            return _Emplace(key_type(_STD forward<_ArgTypes>(_Args)...));
        }
    }

    template <class... _ArgTypes>
    iterator emplace_hint(const const_iterator _Position, _ArgTypes&&... _Args)
        requires is_constructible_v<value_type, _ArgTypes...>
    {
        constexpr bool _Is_key_type = _In_place_key_extract_set<key_type, remove_cvref_t<_ArgTypes>...>::_Extractable;
        if constexpr (_Is_key_type) {
            return _Emplace_hint(_Position, _STD forward<_ArgTypes>(_Args)...);
        } else {
            return _Emplace_hint(_Position, key_type(_STD forward<_ArgTypes>(_Args)...));
        }
    }

    auto insert(const value_type& _Val) {
        return _Emplace(_Val);
    }
    auto insert(value_type&& _Val) {
        return _Emplace(_STD move(_Val));
    }
    template <_Different_from<value_type> _Other>
        requires _IsUnique && _Transparent<key_compare> && is_constructible_v<value_type, _Other>
    auto insert(_Other&& _Val) {
        return _Emplace(_STD forward<_Other>(_Val));
    }

    iterator insert(const const_iterator _Position, const value_type& _Val) {
        return _Emplace_hint(_Position, _Val);
    }
    iterator insert(const const_iterator _Position, value_type&& _Val) {
        return _Emplace_hint(_Position, _STD move(_Val));
    }
    template <_Different_from<value_type> _Other>
        requires _IsUnique && _Transparent<key_compare> && is_constructible_v<value_type, _Other>
    iterator insert(const const_iterator _Position, _Other&& _Val) {
        return _Emplace_hint(_Position, _STD forward<_Other>(_Val));
    }

    template <_Iterator_for_container _InIt>
    void insert(const _InIt _First, const _InIt _Last) {
        _Insert_range<true>(_First, _Last);
    }
    template <_Iterator_for_container _InIt>
    void insert(_Sorted_t, const _InIt _First, const _InIt _Last) {
        _Insert_range<false>(_First, _Last);
    }

    template <_Container_compatible_range<value_type> _Rng>
    void insert_range(_Rng&& _Range) {
        _Insert_range<true>(_STD forward<_Rng>(_Range));
    }
    template <_Container_compatible_range<value_type> _Rng>
    void insert_range(_Sorted_t, _Rng&& _Range) {
        _Insert_range<false>(_STD forward<_Rng>(_Range));
    }

    void insert(const initializer_list<value_type> _Ilist) {
        _Insert_range<true>(_Ilist.begin(), _Ilist.end());
    }
    void insert(_Sorted_t, const initializer_list<value_type> _Ilist) {
        _Insert_range<false>(_Ilist.begin(), _Ilist.end());
    }

    _NODISCARD container_type extract() && noexcept(
        is_nothrow_move_constructible_v<container_type>) /* strengthened */ {
        // always clears the container (N5032 [flat.set.modifiers]/16 and [flat.multiset.modifiers]/15)
        _Clear_guard _Always_clear{this};
        return _STD move(_Data);
    }

    void replace(container_type&& _Cont) {
        _STL_ASSERT(_Is_sorted_and_unique(_Cont.begin(), _Cont.end()), _Msg_replace_not_sorted);
        _Clear_guard _Guard{this};
        _Data          = _STD move(_Cont);
        _Guard._Target = nullptr;
    }

    // NB: `erase(iterator)` is identical to `erase(const_iterator)`
    iterator erase(const const_iterator _Position) {
        _Clear_guard _Guard{this};
        const auto _Ret = _Data.erase(_Position);
        _Guard._Target  = nullptr;
        return _Ret;
    }

    size_type erase(const key_type& _Val) {
        return _Erase(_Val);
    }
    template <_Different_from<key_type> _Other>
        requires _Transparent<key_compare> && (!is_convertible_v<_Other, const_iterator>)
    size_type erase(_Other&& _Val) {
        return _Erase(_Val);
    }

    iterator erase(const const_iterator _First, const const_iterator _Last) {
        _Clear_guard _Guard{this};
        const auto _Ret = _Data.erase(_First, _Last);
        _Guard._Target  = nullptr;
        return _Ret;
    }

    void swap(_Derived& _Other)
        noexcept(is_nothrow_swappable_v<container_type> && is_nothrow_swappable_v<key_compare>) {
        constexpr bool _Is_noexcept = is_nothrow_swappable_v<container_type> && is_nothrow_swappable_v<key_compare>;
        _Flat_set_swap_clear_guard<_Is_noexcept, container_type> _Guard{
            _STD addressof(_Data), _STD addressof(_Other._Data)};
        _RANGES swap(_Data, _Other._Data);
        _RANGES swap(_Key_compare, _Other._Key_compare);
        _Guard._Dismiss();
    }

    void clear() noexcept {
        _Data.clear();
    }

    // Observers
    _NODISCARD key_compare key_comp() const {
        return _Key_compare;
    }
    _NODISCARD value_compare value_comp() const {
        return _Key_compare;
    }

    // Set operations
    // NB: The non-const overloads are intentionally removed for brevity. This will not result in behavioral changes.
    _NODISCARD const_iterator find(const key_type& _Val) const {
        return _Find(_Val);
    }
    template <class _Other>
        requires _Transparent<key_compare>
    _NODISCARD const_iterator find(const _Other& _Val) const {
        return _Find(_Val);
    }

    _NODISCARD size_type count(const key_type& _Val) const {
        return _Count(_Val);
    }
    template <class _Other>
        requires _Transparent<key_compare>
    _NODISCARD size_type count(const _Other& _Val) const {
        return _Count(_Val);
    }

    _NODISCARD bool contains(const key_type& _Val) const {
        return _STD binary_search(cbegin(), cend(), _Val, _Pass_comp());
    }
    template <class _Other>
        requires _Transparent<key_compare>
    _NODISCARD bool contains(const _Other& _Val) const {
        return _STD binary_search(cbegin(), cend(), _Val, _Pass_comp());
    }

    _NODISCARD const_iterator lower_bound(const key_type& _Val) const {
        return _STD lower_bound(cbegin(), cend(), _Val, _Pass_comp());
    }
    template <class _Other>
        requires _Transparent<key_compare>
    _NODISCARD const_iterator lower_bound(const _Other& _Val) const {
        return _STD lower_bound(cbegin(), cend(), _Val, _Pass_comp());
    }

    _NODISCARD const_iterator upper_bound(const key_type& _Val) const {
        return _STD upper_bound(cbegin(), cend(), _Val, _Pass_comp());
    }
    template <class _Other>
        requires _Transparent<key_compare>
    _NODISCARD const_iterator upper_bound(const _Other& _Val) const {
        return _STD upper_bound(cbegin(), cend(), _Val, _Pass_comp());
    }

    _NODISCARD pair<const_iterator, const_iterator> equal_range(const key_type& _Val) const {
        return _Equal_range(_Val);
    }
    template <class _Other>
        requires _Transparent<key_compare>
    _NODISCARD pair<const_iterator, const_iterator> equal_range(const _Other& _Val) const {
        return _Equal_range(_Val);
    }

    _NODISCARD friend bool operator==(const _Derived& _Lhs, const _Derived& _Rhs) {
        return _STD equal(_Lhs._Data.begin(), _Lhs._Data.end(), _Rhs._Data.begin(), _Rhs._Data.end());
    }

    _NODISCARD friend auto operator<=>(const _Derived& _Lhs, const _Derived& _Rhs) {
        return _STD lexicographical_compare_three_way(
            _Lhs._Data.begin(), _Lhs._Data.end(), _Rhs._Data.begin(), _Rhs._Data.end(), _Synth_three_way{});
    }

    friend void swap(_Derived& _Lhs, _Derived& _Rhs) noexcept(noexcept(_Lhs.swap(_Rhs))) {
        _Lhs.swap(_Rhs);
    }

#ifdef _ENABLE_STL_INTERNAL_CHECK
public:
#else
private:
#endif
    _NODISCARD bool _Is_sorted_and_unique() const {
        return _Is_sorted_and_unique(_Data.begin(), _Data.end());
    }

private:
    _NODISCARD bool _Is_sorted_and_unique(const const_iterator _It, const const_iterator _End) const {
        if constexpr (_IsUnique) {
            // sorted-unique
            auto _Negated = [this](const key_type& _Lhs, const key_type& _Rhs) { return !_Compare_keys(_Lhs, _Rhs); };
            return _STD adjacent_find(_It, _End, _Negated) == _End;
        } else {
            return _STD is_sorted(_It, _End, _Pass_comp());
        }
    }

    template <class _Ty>
    _NODISCARD bool _Can_insert(const const_iterator _Where, const _Ty& _Val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty, key_type>); // only accepts key_type

        // check that _Val can be inserted before _Where
        if constexpr (_IsUnique) {
            // check that _Where is the lower_bound for _Val, and *_Where is not equivalent to _Val
            // equivalent to checking *(_Where-1) < _Val < *_Where
            return (_Where == cend() || _Compare_keys(_Val, *_Where))
                && (_Where == cbegin() || _Compare_keys(*(_Where - 1), _Val));
        } else {
            // check that _Where is the upper_bound for _Val
            // equivalent to checking *(_Where-1) <= _Val < *_Where
            return (_Where == cend() || _Compare_keys(_Val, *_Where))
                && (_Where == cbegin() || !_Compare_keys(_Val, *(_Where - 1)));
        }
    }

    template <class _Ty>
    _NODISCARD iterator _Emplace_with_clear_guard(const const_iterator _Where, _Ty&& _Val) {
        if constexpr (_Has_guaranteed_single_insertion<container_type>) {
            return _Data.emplace(_Where, _STD forward<_Ty>(_Val));
        } else {
            _Clear_guard _Guard{this};
            auto _Iter     = _Data.emplace(_Where, _STD forward<_Ty>(_Val));
            _Guard._Target = nullptr;
            return _Iter;
        }
    }

    template <class _Ty>
    _NODISCARD conditional_t<_IsUnique, pair<iterator, bool>, iterator> _Emplace(_Ty&& _Val) {
        if constexpr (_IsUnique) {
            const const_iterator _Where = lower_bound(_Val);
            if (_Where != cend() && !_Compare_keys(_Val, *_Where)) {
                return pair{_Where, false};
            }

            if constexpr (is_same_v<remove_cvref_t<_Ty>, key_type>) {
                _STL_INTERNAL_CHECK(_Can_insert(_Where, _Val));
                return pair{_Emplace_with_clear_guard(_Where, _STD forward<_Ty>(_Val)), true};
            } else {
                // heterogeneous insertion
                _STL_INTERNAL_STATIC_ASSERT(_Transparent<key_compare> && is_constructible_v<key_type, _Ty>);
                key_type _Keyval(_STD forward<_Ty>(_Val));
                _STL_ASSERT(_Can_insert(_Where, _Keyval), _Msg_heterogeneous_insertion_inconsistent_with_lookup);
                return pair{_Emplace_with_clear_guard(_Where, _STD move(_Keyval)), true};
            }
        } else {
            _STL_INTERNAL_STATIC_ASSERT(is_same_v<remove_cvref_t<_Ty>, key_type>);
            return _Emplace_with_clear_guard(upper_bound(_Val), _STD forward<_Ty>(_Val));
        }
    }

    template <class _Ty>
    _NODISCARD iterator _Emplace_hint(const_iterator _Where, _Ty&& _Val) {
        const const_iterator _Begin = cbegin();
        const const_iterator _End   = cend();

        if constexpr (_IsUnique) {
            // look for lower_bound(_Val)
            if (_Where == _End || !_Compare_keys(*_Where, _Val)) {
                // _Val <= *_Where
                if (_Where == _Begin || _Compare_keys(*(_Where - 1), _Val)) {
                    // _Val > *(_Where-1) ~ lower_bound is _Where
                } else {
                    // _Val <= *(_Where-1) ~ lower_bound is in [_Begin,_Where-1]
                    _Where = _STD lower_bound(_Begin, _Where - 1, _Val, _Pass_comp());
                }
            } else {
                // _Val > *_Where ~ lower_bound is in [_Where+1,_End]
                _Where = _STD lower_bound(_Where + 1, _End, _Val, _Pass_comp());
            }

            if (_Where != _End && !_Compare_keys(_Val, *_Where)) {
                return _Where;
            }

            if constexpr (is_same_v<remove_cvref_t<_Ty>, key_type>) {
                _STL_INTERNAL_CHECK(_Can_insert(_Where, _Val));
                return _Emplace_with_clear_guard(_Where, _STD forward<_Ty>(_Val));
            } else {
                // heterogeneous insertion
                _STL_INTERNAL_STATIC_ASSERT(_Transparent<key_compare> && is_constructible_v<key_type, _Ty>);
                key_type _Keyval(_STD forward<_Ty>(_Val));
                _STL_ASSERT(_Can_insert(_Where, _Keyval), _Msg_heterogeneous_insertion_inconsistent_with_lookup);
                return _Emplace_with_clear_guard(_Where, _STD move(_Keyval));
            }
        } else {
            _STL_INTERNAL_STATIC_ASSERT(is_same_v<remove_cvref_t<_Ty>, key_type>);

            // look for closest position just prior to _Where, respecting ordering
            if (_Where == _End || _Compare_keys(_Val, *_Where)) {
                // _Val < *_Where
                if (_Where == _Begin || !_Compare_keys(_Val, *(_Where - 1))) {
                    // _Val >= *(_Where-1) ~ closest valid position is _Where
                } else {
                    // _Val < *(_Where-1) ~ closest valid position is upper_bound(_Val) located in [_Begin,_Where-1]
                    _Where = _STD upper_bound(_Begin, _Where - 1, _Val, _Pass_comp());
                }
                // _Val < *_Where, so upper_bound is indeed "as close as possible"
                _STL_INTERNAL_CHECK(_Can_insert(_Where, _Val));
            } else {
                // _Val >= *_Where ~ search for lower_bound in [_Where,_End] to place _Val "as close as possible"
                _Where = _STD lower_bound(_Where, _End, _Val, _Pass_comp());
            }

            return _Emplace_with_clear_guard(_Where, _STD forward<_Ty>(_Val));
        }
    }

    template <bool _NeedSorting, class _InIt>
    void _Insert_range(const _InIt _First, const _InIt _Last) {
        const size_type _Old_size = size();
        _Clear_guard _Guard{this};
        _Data.insert(_Data.end(), _First, _Last);
        _Restore_invariants<_NeedSorting>(_Old_size);
        _Guard._Target = nullptr;
    }

    template <bool _NeedSorting, _Container_compatible_range<value_type> _Rng>
    void _Insert_range(_Rng&& _Range) {
        const size_type _Old_size = size();
        _Clear_guard _Guard{this};
        if constexpr (_Has_guaranteed_append_range<container_type>) {
            _Data.append_range(_STD forward<_Rng>(_Range));
        } else {
            _Data.insert_range(_Data.end(), _STD forward<_Rng>(_Range));
        }
        _Restore_invariants<_NeedSorting>(_Old_size);
        _Guard._Target = nullptr;
    }

    template <class _Ty>
    _NODISCARD size_type _Erase(const _Ty& _Val) {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty, key_type> || _Transparent<key_compare>);

        if constexpr (_IsUnique && is_same_v<_Ty, key_type>) { // Optimization restricted due to GH-5992
            const const_iterator _Where = lower_bound(_Val);
            if (_Where != cend() && !_Compare_keys(_Val, *_Where)) {
                _Clear_guard _Guard{this};
                _Data.erase(_Where);
                _Guard._Target = nullptr;
                return 1;
            }
            return 0;
        } else {
            const auto [_First, _Last] = equal_range(_Val);

            const auto _Removed = static_cast<size_type>(_Last - _First);
            _Clear_guard _Guard{this};
            _Data.erase(_First, _Last);
            _Guard._Target = nullptr;
            return _Removed;
        }
    }

    // typename is a workaround for VSO-2680018 (EDG)
    template <class _Key2, class _Compare2, class _Container2, class _Predicate2>
    friend typename _Container2::size_type erase_if(flat_set<_Key2, _Compare2, _Container2>&, _Predicate2);
    template <class _Key2, class _Compare2, class _Container2, class _Predicate2>
    friend typename _Container2::size_type erase_if(flat_multiset<_Key2, _Compare2, _Container2>&, _Predicate2);

    template <class _Predicate>
    _NODISCARD size_type _Erase_if(_Predicate _Pred) {
        // Maintain invariants when an exception is thrown (N5032 [flat.set.erasure]/5, [flat.multiset.erasure]/5)
        _Clear_guard _Guard{this};
        const auto _Erased_count = _STD _Erase_remove_if(_Data, _Pred);
        _Guard._Target           = nullptr;
        return _Erased_count;
    }

    template <class _Ty>
    _NODISCARD const_iterator _Find(const _Ty& _Val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty, key_type> || _Transparent<key_compare>);

        const const_iterator _End   = cend();
        const const_iterator _Where = lower_bound(_Val);
        if (_Where != _End && !_Compare_keys(_Val, *_Where)) {
            return _Where;
        } else {
            return _End;
        }
    }

    template <class _KeyTy>
    _NODISCARD size_type _Count(const _KeyTy& _Key_val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Transparent<key_compare>);
        if constexpr (_IsUnique && is_same_v<_KeyTy, key_type>) { // Optimization restricted due to GH-5992
            return contains(_Key_val);
        } else {
            const auto [_First, _Last] = _Equal_range(_Key_val);
            return static_cast<size_type>(_Last - _First);
        }
    }

    template <class _KeyTy>
    _NODISCARD pair<const_iterator, const_iterator> _Equal_range(const _KeyTy& _Key_val) const {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_KeyTy, key_type> || _Transparent<key_compare>);
        if constexpr (_IsUnique && is_same_v<_KeyTy, key_type>) { // Optimization restricted due to GH-5992
            // In a non-multi container, equal_range can have size at most 1
            const auto _First   = _STD lower_bound(_Data.begin(), _Data.end(), _Key_val, _Pass_comp());
            const bool _Missing = _First == _Data.end() || _Compare_keys(_Key_val, *_First);
            return pair{_First, _Missing ? _First : _First + 1};
        } else {
            return _STD equal_range(begin(), end(), _Key_val, _Pass_comp());
        }
    }

    _NODISCARD auto _Erase_dupes_if_not_multi_pred() {
        _STL_INTERNAL_STATIC_ASSERT(_IsUnique);
        if constexpr (_Equivalence_is_equality<key_compare, key_type>) {
            return equal_to<>{};
        } else {
            return [this](const key_type& _Lhs, const key_type& _Rhs) { return !_Compare_keys(_Lhs, _Rhs); };
        }
    }

    void _Erase_dupes_if_not_multi() {
        if constexpr (_IsUnique) {
            // No _Clear_guard needed. The only caller is _Restore_invariants().
            // That's called only by _Insert_range() (which has a _Clear_guard)
            // and _Establish_invariants() (which is called only by constructors which don't need guards
            // and operator=() which has a _Clear_guard).
            const auto _End = _Data.end();
            _Data.erase(_STD unique(_Data.begin(), _End, _Erase_dupes_if_not_multi_pred()), _End);
        }
    }

    template <bool _NeedSorting>
    void _Restore_invariants(const size_type _Old_size) {
        const auto _Begin   = _Data.begin();
        const auto _Old_end = _Begin + static_cast<difference_type>(_Old_size);
        const auto _End     = _Data.end();

        if constexpr (_NeedSorting) {
            _STD sort(_Old_end, _End, _Pass_comp());
        } else {
            _STL_ASSERT(_Is_sorted_and_unique(_Old_end, _End), _Msg_not_sorted);
        }

        _STD inplace_merge(_Begin, _Old_end, _End, _Pass_comp());

        _Erase_dupes_if_not_multi();

        _STL_INTERNAL_CHECK(_Is_sorted_and_unique());
    }

    void _Establish_invariants() {
        if (_Data.empty()) {
            return;
        }

        const auto _Begin        = _Data.begin();
        const auto _End          = _Data.end();
        const auto _Sorted_until = _STD is_sorted_until(_Begin, _End, _Pass_comp()); // O(N) if already sorted.
        const auto _Sorted_size  = static_cast<size_type>(_Sorted_until - _Begin);
        _Restore_invariants<true>(_Sorted_size);
    }

    template <class _Lty, class _Rty>
    _NODISCARD bool _Compare_keys(const _Lty& _Lhs, const _Rty& _Rhs) const
        noexcept(noexcept(_DEBUG_LT_PRED(_Key_compare, _Lhs, _Rhs))) {
        _STL_INTERNAL_STATIC_ASSERT(
            (is_same_v<_Lty, key_type> && is_same_v<_Rty, key_type>) || _Transparent<key_compare>);

        return _DEBUG_LT_PRED(_Key_compare, _Lhs, _Rhs);
    }

    _NODISCARD auto _Pass_comp() const noexcept {
        return _STD _Pass_fn(_Key_compare);
    }

    container_type _Data;
    _MSVC_NO_UNIQUE_ADDRESS key_compare _Key_compare;
};

_EXPORT_STD template <class _Key, class _Compare, class _Container>
class flat_set : public _Flat_set_base<true, _Key, _Compare, _Container> {
private:
    using _Mybase = _Flat_set_base<true, _Key, _Compare, _Container>;

public:
    using _Mybase::_Mybase;
    flat_set(const flat_set&) = default;
    flat_set(flat_set&&)      = default;

#if 1 // TRANSITION, P2582R1 (MSVC, Clang, EDG)
    template <_Usable_allocator_for<_Container> _Alloc>
    flat_set(const flat_set& _Other, const _Alloc& _Al) : _Mybase(_Other, _Al) {}

    template <_Usable_allocator_for<_Container> _Alloc>
    flat_set(flat_set&& _Other, const _Alloc& _Al) : _Mybase(_STD move(_Other), _Al) {}
#endif // ^^^ workaround ^^^

    flat_set& operator=(const flat_set&) = default;
    flat_set& operator=(flat_set&&)      = default;

    flat_set& operator=(const initializer_list<_Key> _Ilist) {
        this->clear();
        this->insert(_Ilist.begin(), _Ilist.end());
        return *this;
    }
};

_EXPORT_STD template <class _Key, class _Compare, class _Container>
class flat_multiset : public _Flat_set_base<false, _Key, _Compare, _Container> {
private:
    using _Mybase = _Flat_set_base<false, _Key, _Compare, _Container>;

public:
    using _Mybase::_Mybase;
    flat_multiset(const flat_multiset&) = default;
    flat_multiset(flat_multiset&&)      = default;

#if 1 // TRANSITION, P2582R1 (MSVC, Clang, EDG)
    template <_Usable_allocator_for<_Container> _Alloc>
    flat_multiset(const flat_multiset& _Other, const _Alloc& _Al) : _Mybase(_Other, _Al) {}

    template <_Usable_allocator_for<_Container> _Alloc>
    flat_multiset(flat_multiset&& _Other, const _Alloc& _Al) : _Mybase(_STD move(_Other), _Al) {}
#endif // ^^^ workaround ^^^

    flat_multiset& operator=(const flat_multiset&) = default;
    flat_multiset& operator=(flat_multiset&&)      = default;

    flat_multiset& operator=(const initializer_list<_Key> _Ilist) {
        this->clear();
        this->insert(_Ilist.begin(), _Ilist.end());
        return *this;
    }
};

_EXPORT_STD template <class _Key, class _Compare, class _Container, class _Predicate>
_Container::size_type erase_if(flat_set<_Key, _Compare, _Container>& _Val, _Predicate _Pred) {
    return _Val._Erase_if(_STD _Pass_fn(_Pred));
}
_EXPORT_STD template <class _Key, class _Compare, class _Container, class _Predicate>
_Container::size_type erase_if(flat_multiset<_Key, _Compare, _Container>& _Val, _Predicate _Pred) {
    return _Val._Erase_if(_STD _Pass_fn(_Pred));
}

template <class _Key, class _Compare, class _Container, class _Alloc>
struct uses_allocator<flat_set<_Key, _Compare, _Container>, _Alloc>
    : bool_constant<uses_allocator_v<_Container, _Alloc>> {};

template <class _Key, class _Compare, class _Container, class _Alloc>
struct uses_allocator<flat_multiset<_Key, _Compare, _Container>, _Alloc>
    : bool_constant<uses_allocator_v<_Container, _Alloc>> {};

template <_Not_allocator_for_container _Container,
    _Valid_compare_for_container<_Container> _Compare = less<typename _Container::value_type>>
flat_set(_Container, _Compare = _Compare()) -> flat_set<typename _Container::value_type, _Compare, _Container>;
template <_Not_allocator_for_container _Container, _Usable_allocator_for<_Container> _Alloc>
flat_set(_Container, _Alloc)
    -> flat_set<typename _Container::value_type, less<typename _Container::value_type>, _Container>;
template <_Not_allocator_for_container _Container, _Valid_compare_for_container<_Container> _Compare,
    _Usable_allocator_for<_Container> _Alloc>
flat_set(_Container, _Compare, _Alloc) -> flat_set<typename _Container::value_type, _Compare, _Container>;

template <_Not_allocator_for_container _Container,
    _Valid_compare_for_container<_Container> _Compare = less<typename _Container::value_type>>
flat_set(sorted_unique_t, _Container, _Compare = _Compare())
    -> flat_set<typename _Container::value_type, _Compare, _Container>;
template <_Not_allocator_for_container _Container, _Usable_allocator_for<_Container> _Alloc>
flat_set(sorted_unique_t, _Container, _Alloc)
    -> flat_set<typename _Container::value_type, less<typename _Container::value_type>, _Container>;
template <_Not_allocator_for_container _Container, _Valid_compare_for_container<_Container> _Compare,
    _Usable_allocator_for<_Container> _Alloc>
flat_set(sorted_unique_t, _Container, _Compare, _Alloc)
    -> flat_set<typename _Container::value_type, _Compare, _Container>;

template <_Iterator_for_container _InIt, _Not_allocator_for_container _Compare = less<iter_value_t<_InIt>>>
flat_set(_InIt, _InIt, _Compare = _Compare()) -> flat_set<iter_value_t<_InIt>, _Compare>;
template <_Iterator_for_container _InIt, _Not_allocator_for_container _Compare = less<iter_value_t<_InIt>>>
flat_set(sorted_unique_t, _InIt, _InIt, _Compare = _Compare()) -> flat_set<iter_value_t<_InIt>, _Compare>;

// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Range, _Not_allocator_for_container _Compare = less<_RANGES range_value_t<_Range>>,
    class _Alloc = allocator<_RANGES range_value_t<_Range>>, enable_if_t<_Allocator_for_container<_Alloc>, int> = 0>
flat_set(from_range_t, _Range&&, _Compare = _Compare(), _Alloc = _Alloc()) -> flat_set<_RANGES range_value_t<_Range>,
    _Compare, vector<_RANGES range_value_t<_Range>, _Rebind_alloc_t<_Alloc, _RANGES range_value_t<_Range>>>>;

// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Range, class _Alloc, enable_if_t<_Allocator_for_container<_Alloc>, int> = 0>
flat_set(from_range_t, _Range&&, _Alloc) -> flat_set<_RANGES range_value_t<_Range>, less<_RANGES range_value_t<_Range>>,
    vector<_RANGES range_value_t<_Range>, _Rebind_alloc_t<_Alloc, _RANGES range_value_t<_Range>>>>;

template <class _Key, _Not_allocator_for_container _Compare = less<_Key>>
flat_set(initializer_list<_Key>, _Compare = _Compare()) -> flat_set<_Key, _Compare>;
template <class _Key, _Not_allocator_for_container _Compare = less<_Key>>
flat_set(sorted_unique_t, initializer_list<_Key>, _Compare = _Compare()) -> flat_set<_Key, _Compare>;

template <_Not_allocator_for_container _Container,
    _Valid_compare_for_container<_Container> _Compare = less<typename _Container::value_type>>
flat_multiset(_Container, _Compare = _Compare())
    -> flat_multiset<typename _Container::value_type, _Compare, _Container>;
template <_Not_allocator_for_container _Container, _Usable_allocator_for<_Container> _Alloc>
flat_multiset(_Container, _Alloc)
    -> flat_multiset<typename _Container::value_type, less<typename _Container::value_type>, _Container>;
template <_Not_allocator_for_container _Container, _Valid_compare_for_container<_Container> _Compare,
    _Usable_allocator_for<_Container> _Alloc>
flat_multiset(_Container, _Compare, _Alloc) -> flat_multiset<typename _Container::value_type, _Compare, _Container>;

template <_Not_allocator_for_container _Container,
    _Valid_compare_for_container<_Container> _Compare = less<typename _Container::value_type>>
flat_multiset(sorted_equivalent_t, _Container, _Compare = _Compare())
    -> flat_multiset<typename _Container::value_type, _Compare, _Container>;
template <_Not_allocator_for_container _Container, _Usable_allocator_for<_Container> _Alloc>
flat_multiset(sorted_equivalent_t, _Container, _Alloc)
    -> flat_multiset<typename _Container::value_type, less<typename _Container::value_type>, _Container>;
template <_Not_allocator_for_container _Container, _Valid_compare_for_container<_Container> _Compare,
    _Usable_allocator_for<_Container> _Alloc>
flat_multiset(sorted_equivalent_t, _Container, _Compare, _Alloc)
    -> flat_multiset<typename _Container::value_type, _Compare, _Container>;

template <_Iterator_for_container _InIt, _Not_allocator_for_container _Compare = less<iter_value_t<_InIt>>>
flat_multiset(_InIt, _InIt, _Compare = _Compare()) -> flat_multiset<iter_value_t<_InIt>, _Compare>;
template <_Iterator_for_container _InIt, _Not_allocator_for_container _Compare = less<iter_value_t<_InIt>>>
flat_multiset(sorted_equivalent_t, _InIt, _InIt, _Compare = _Compare()) -> flat_multiset<iter_value_t<_InIt>, _Compare>;

// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Range, _Not_allocator_for_container _Compare = less<_RANGES range_value_t<_Range>>,
    class _Alloc = allocator<_RANGES range_value_t<_Range>>, enable_if_t<_Allocator_for_container<_Alloc>, int> = 0>
flat_multiset(from_range_t, _Range&&, _Compare = _Compare(), _Alloc = _Alloc())
    -> flat_multiset<_RANGES range_value_t<_Range>, _Compare,
        vector<_RANGES range_value_t<_Range>, _Rebind_alloc_t<_Alloc, _RANGES range_value_t<_Range>>>>;

// TRANSITION, CWG-2369, should just use constrained template parameters.
template <_RANGES input_range _Range, class _Alloc, enable_if_t<_Allocator_for_container<_Alloc>, int> = 0>
flat_multiset(from_range_t, _Range&&, _Alloc)
    -> flat_multiset<_RANGES range_value_t<_Range>, less<_RANGES range_value_t<_Range>>,
        vector<_RANGES range_value_t<_Range>, _Rebind_alloc_t<_Alloc, _RANGES range_value_t<_Range>>>>;

template <class _Key, _Not_allocator_for_container _Compare = less<_Key>>
flat_multiset(initializer_list<_Key>, _Compare = _Compare()) -> flat_multiset<_Key, _Compare>;
template <class _Key, _Not_allocator_for_container _Compare = less<_Key>>
flat_multiset(sorted_equivalent_t, initializer_list<_Key>, _Compare = _Compare()) -> flat_multiset<_Key, _Compare>;

_STD_END

// TRANSITION, non-_Ugly attribute tokens
#pragma pop_macro("msvc")

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // ^^^ _HAS_CXX23 ^^^
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _FLAT_SET_
