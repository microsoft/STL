// format standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _FORMAT_
#define _FORMAT_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR
#ifndef __cpp_lib_concepts
#pragma message("The contents of <format> are available only with C++20 concepts support.")
#else // ^^^ !defined(__cpp_lib_concepts) / defined(__cpp_lib_concepts) vvv

#include <array>
#include <charconv>
#include <concepts>
#include <exception>
#include <iterator>
#include <locale>
#include <string>
#include <string_view>
#include <variant>
#include <xutility>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN

class format_error : public runtime_error {
    using runtime_error::runtime_error;
};

enum class _Align { _None, _Left, _Right, _Center };

enum class _Sign { _None, _Plus, _Minus, _Space };

enum class _Basic_format_arg_type : uint8_t {
    _None,
    _Int_type,
    _UInt_type,
    _Long_long_type,
    _ULong_long_type,
    _Bool_type,
    _Char_type,
    _Float_type,
    _Double_type,
    _Long_double_type,
    _Pointer_type,
    _CString_type,
    _String_type,
    _Custom_type,
};
static_assert(static_cast<int>(_Basic_format_arg_type::_Custom_type) <= 16);

constexpr bool _Is_integral_fmt_type(_Basic_format_arg_type _Ty) {
    return _Ty > _Basic_format_arg_type::_None && _Ty <= _Basic_format_arg_type::_ULong_long_type;
}
constexpr bool _Is_arithmetic_fmt_type(_Basic_format_arg_type _Ty) {
    return _Ty > _Basic_format_arg_type::_None && _Ty <= _Basic_format_arg_type::_Long_double_type;
}
struct _Auto_id_tag {};

// clang-format off
template <class _Ty, class _CharT>
concept _Parse_spec_callbacks = requires(_Ty _At, basic_string_view<_CharT> _Sv, _Align _Aln, _Sign _Sgn) {
    { _At._On_align(_Aln) } -> same_as<void>;
    { _At._On_fill(_Sv) } -> same_as<void>;
    { _At._On_width(int{}) } -> same_as<void>;
    { _At._On_dynamic_width(size_t{}) } -> same_as<void>;
    { _At._On_dynamic_width(_Auto_id_tag{}) } -> same_as<void>;
    { _At._On_precision(int{}) } -> same_as<void>;
    { _At._On_dynamic_precision(size_t{}) } -> same_as<void>;
    { _At._On_dynamic_precision(_Auto_id_tag{}) } -> same_as<void>;
    { _At._On_sign(_Sgn) } -> same_as<void>;
    { _At._On_hash() } -> same_as<void>;
    { _At._On_zero() } -> same_as<void>;
    { _At._On_localized() } -> same_as<void>;
    { _At._On_type(_CharT{}) } -> same_as<void>;
};
template <class _Ty, class _CharT>
concept _Parse_arg_id_callbacks = requires(_Ty _At) {
    { _At._On_auto_id() } -> same_as<void>;
    { _At._On_manual_id(size_t{}) } -> same_as<void>;
};

template <class _Ty, class _CharT>
concept _Parse_replacement_field_callbacks = requires(_Ty _At, const _CharT* _Begin, const _CharT* _End) {
    { _At._Parse_context };
    { _At._On_text(_Begin, _End) } -> same_as<void>;
    { _At._On_replacement_field(size_t{}, static_cast<const _CharT*>(nullptr)) } -> same_as<void>;
    { _At._On_format_specs(size_t{}, _Begin, _End) } -> same_as<const _CharT*>;
};

template <class _Ty, class _CharT>
concept _CharT_or_bool = same_as<_Ty, _CharT> || same_as<_Ty, bool>;

// clang-format on

template <class _Ty, class _CharT = char>
struct formatter;

inline void _You_see_this_error_because_arg_id_is_out_of_range() noexcept {}

template <class _CharT>
class basic_format_parse_context {
public:
    using char_type      = _CharT;
    using const_iterator = typename basic_string_view<_CharT>::const_iterator;
    using iterator       = const_iterator;

    constexpr explicit basic_format_parse_context(basic_string_view<_CharT> _Fmt, size_t _Num_args_ = 0) noexcept
        : _Format_string(_Fmt), _Num_args(_Num_args_) {}
    basic_format_parse_context(const basic_format_parse_context&) = delete;
    basic_format_parse_context& operator=(const basic_format_parse_context&) = delete;

    _NODISCARD constexpr const_iterator begin() const noexcept {
        return _Format_string.begin();
    }
    _NODISCARD constexpr const_iterator end() const noexcept {
        return _Format_string.end();
    }
    constexpr void advance_to(const const_iterator _It) {
        _Adl_verify_range(_It, _Format_string.end());
        // _It must be after _Format_string.begin().
        const auto _Diff = static_cast<size_t>(_It._Unwrapped() - _Format_string._Unchecked_begin());
        _Format_string.remove_prefix(_Diff);
    }

    // While the standard presents an exposition-only enum value for
    // the indexing mode (manual, automatic, or unknown) we use _Next_arg_id to indicate it.
    // _Next_arg_id > 0 means automatic
    // _Next_arg_id == 0 means unknown
    // _Next_arg_id < 0 means manual
    constexpr size_t next_arg_id() {
        if (_Next_arg_id < 0) {
            throw format_error("Can not switch from manual to automatic indexing");
        }

        return static_cast<size_t>(_Next_arg_id++);
    }

    constexpr void check_arg_id(const size_t _Id) {
        if (_STD is_constant_evaluated()) {
            if (_Id >= _Num_args) {
                _You_see_this_error_because_arg_id_is_out_of_range();
            }
        }

        if (_Next_arg_id > 0) {
            throw format_error("Can not switch from automatic to manual indexing");
        }
        _Next_arg_id = -1;
    }

private:
    basic_string_view<_CharT> _Format_string;
    size_t _Num_args;
    // The standard says this is size_t, however we use ptrdiff_t to save some space
    // by not having to store the indexing mode. Above is a more detailed explanation
    // of how this works.
    ptrdiff_t _Next_arg_id = 0;
};

template <class _Context>
class basic_format_arg {
public:
    using _CharType = typename _Context::char_type;

    class handle {
    private:
        const void* _Ptr;
        void (*_Format)(basic_format_parse_context<_CharType>& _Parse_ctx, _Context& _Format_ctx, const void*);
        friend basic_format_arg;

    public:
        template <class _Ty>
        explicit handle(const _Ty& _Val) noexcept
            : _Ptr(_STD addressof(_Val)),
              _Format([](basic_format_parse_context<_CharType>& _Parse_ctx, _Context& _Format_ctx, const void* _Ptr) {
                  typename _Context::template formatter_type<_Ty> _Formatter;
                  _Parse_ctx.advance_to(_Formatter.parse(_Parse_ctx));
                  _Format_ctx.advance_to(_Formatter.format(*static_cast<const _Ty*>(_Ptr), _Format_ctx));
              }) {}

        void format(basic_format_parse_context<_CharType>& _Parse_ctx, _Context& _Format_ctx) {
            _Format(_Parse_ctx, _Format_ctx, _Ptr);
        }
    };

    // TRANSITION, LLVM-49072
    basic_format_arg() noexcept : _Active_state(_Basic_format_arg_type::_None), _No_state() {}

    explicit basic_format_arg(const int _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_Int_type), _Int_state(_Val) {}
    explicit basic_format_arg(const unsigned int _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_UInt_type), _UInt_state(_Val) {}
    explicit basic_format_arg(const long long _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_Long_long_type), _Long_long_state(_Val) {}
    explicit basic_format_arg(const unsigned long long _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_ULong_long_type), _ULong_long_state(_Val) {}
    explicit basic_format_arg(const bool _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_Bool_type), _Bool_state(_Val) {}
    explicit basic_format_arg(const _CharType _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_Char_type), _Char_state(_Val) {}
    explicit basic_format_arg(const float _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_Float_type), _Float_state(_Val) {}
    explicit basic_format_arg(const double _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_Double_type), _Double_state(_Val) {}
    explicit basic_format_arg(const long double _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_Long_double_type), _Long_double_state(_Val) {}
    explicit basic_format_arg(const void* _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_Pointer_type), _Pointer_state(_Val) {}
    explicit basic_format_arg(const _CharType* _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_CString_type), _CString_state(_Val) {}
    explicit basic_format_arg(const basic_string_view<_CharType> _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_String_type), _String_state(_Val) {}
    explicit basic_format_arg(const handle _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_Custom_type), _Custom_state(_Val) {}
    explicit operator bool() const noexcept {
        return _Active_state != _Basic_format_arg_type::_None;
    }

    _Basic_format_arg_type _Active_state = _Basic_format_arg_type::_None;
    union {
        monostate _No_state = monostate{};
        int _Int_state;
        unsigned int _UInt_state;
        long long _Long_long_state;
        unsigned long long _ULong_long_state;
        bool _Bool_state;
        _CharType _Char_state;
        float _Float_state;
        double _Double_state;
        long double _Long_double_state;
        const void* _Pointer_state;
        const _CharType* _CString_state;
        basic_string_view<_CharType> _String_state;
        handle _Custom_state;
    };
};

template <class _Visitor, class _Context>
auto visit_format_arg(_Visitor&& _Vis, basic_format_arg<_Context> _Arg) {
    switch (_Arg._Active_state) {
    case _Basic_format_arg_type::_None:
        return _Vis(_Arg._No_state);
    case _Basic_format_arg_type::_Int_type:
        return _Vis(_Arg._Int_state);
    case _Basic_format_arg_type::_UInt_type:
        return _Vis(_Arg._UInt_state);
    case _Basic_format_arg_type::_Long_long_type:
        return _Vis(_Arg._Long_long_state);
    case _Basic_format_arg_type::_ULong_long_type:
        return _Vis(_Arg._ULong_long_state);
    case _Basic_format_arg_type::_Bool_type:
        return _Vis(_Arg._Bool_state);
    case _Basic_format_arg_type::_Char_type:
        return _Vis(_Arg._Char_state);
    case _Basic_format_arg_type::_Float_type:
        return _Vis(_Arg._Float_state);
    case _Basic_format_arg_type::_Double_type:
        return _Vis(_Arg._Double_state);
    case _Basic_format_arg_type::_Long_double_type:
        return _Vis(_Arg._Long_double_state);
    case _Basic_format_arg_type::_Pointer_type:
        return _Vis(_Arg._Pointer_state);
    case _Basic_format_arg_type::_CString_type:
        return _Vis(_Arg._CString_state);
    case _Basic_format_arg_type::_String_type:
        return _Vis(_Arg._String_state);
    case _Basic_format_arg_type::_Custom_type:
        return _Vis(_Arg._Custom_state);
    default:
        _STL_VERIFY(false, "basic_format_arg is in impossible state");
        return _Vis(0);
    }
}

// we need to implement this ourselves because from_chars does not work with wide characters and isn't constexpr
template <class _CharT>
constexpr const _CharT* _Parse_nonnegative_integer(const _CharT* _Begin, const _CharT* _End, unsigned int& _Value) {
    _STL_INTERNAL_CHECK(_Begin != _End && '0' <= *_Begin && *_Begin <= '9');
    _Value                          = 0;
    constexpr unsigned int _Max_int = static_cast<unsigned int>((numeric_limits<int>::max)());
    constexpr unsigned int _Big_int = _Max_int / 10;

    do {
        if (_Value > _Big_int) {
            _Value = _Max_int + 1;
            break;
        }
        _Value = _Value * 10 + static_cast<unsigned int>(*_Begin - '0');
        ++_Begin;
    } while (_Begin != _End && '0' <= *_Begin && *_Begin <= '9');
    if (_Value > _Max_int) {
        throw format_error("Number is too big");
    }
    return _Begin;
}

template <class _CharT>
constexpr const _CharT* _Parse_nonnegative_integer(const _CharT* _Begin, const _CharT* _End, int& _Value) {
    unsigned int _Val_unsigned = 0;

    _Begin = _Parse_nonnegative_integer(_Begin, _End, _Val_unsigned);
    // Never invalid because _Parse_nonnegative_integer throws an error for values that don't fit in signed integers
    _Value = static_cast<int>(_Val_unsigned);
    return _Begin;
}

template <class _CharT, _Parse_arg_id_callbacks<_CharT> _Callbacks_type>
constexpr const _CharT* _Parse_arg_id(const _CharT* _Begin, const _CharT* _End, _Callbacks_type&& _Callbacks) {
    _STL_INTERNAL_CHECK(_Begin != _End);
    _CharT _Ch = *_Begin;
    // No id provided, format string is using automatic indexing.
    if (_Ch == '}' || _Ch == ':') {
        _Callbacks._On_auto_id();
        return _Begin;
    }

    if (_Ch >= '0' && _Ch <= '9') {
        unsigned int _Index = 0;
        // arg_id is not allowed to have any leading zeros, but is allowed to be
        // equal to zero (but not '00'). So if _Ch is zero we skip the parsing, leave
        // _Index set to zero and let the validity checks below ensure that the arg_id
        // wasn't something like "00", or "023".
        if (_Ch != '0') {
            _Begin = _Parse_nonnegative_integer(_Begin, _End, _Index);
        } else {
            ++_Begin;
        }
        // The format string shouldn't end right after the index number.
        // The only things permitted after the index are the end of the replacement field ('}')
        // or the beginning of the format spec (':').
        if (_Begin == _End || (*_Begin != '}' && *_Begin != ':')) {
            throw format_error("Invalid format string.");
        }
        _Callbacks._On_manual_id(_Index);
        return _Begin;
    }
    // This is where we would parse named arg ids if std::format were to support them.
    throw format_error("Invalid format string.");
}

template <class _CharT, _Parse_spec_callbacks<_CharT> _Callbacks_type>
constexpr const _CharT* _Parse_align(const _CharT* _Begin, const _CharT* _End, _Callbacks_type&& _Callbacks) {
    _STL_INTERNAL_CHECK(_Begin != _End && *_Begin != '}');
    // align and fill
    auto _Parsed_align = _Align::_None;

    // TODO: should increment one code point
    auto _Align_pt = _Begin + 1;
    if (_Align_pt == _End) {
        _Align_pt = _Begin;
    }
    for (;;) {
        switch (*_Align_pt) {
        case '<':
            _Parsed_align = _Align::_Left;
            break;
        case '>':
            _Parsed_align = _Align::_Right;
            break;
        case '^':
            _Parsed_align = _Align::_Center;
            break;
        }
        if (_Parsed_align != _Align::_None) {
            if (_Align_pt != _Begin) {
                if (*_Begin == '{') {
                    throw format_error("invalid fill character '{'");
                }
                _Callbacks._On_fill({_Begin, static_cast<size_t>(_Align_pt - _Begin)});
                _Begin = _Align_pt + 1;
            } else {
                ++_Begin;
            }
            _Callbacks._On_align(_Parsed_align);
            break;
        } else if (_Align_pt == _Begin) {
            break;
        }
        _Align_pt = _Begin;
    }
    return _Begin;
}

// Adapts a type modeling _Parse_spec_callbacks to model _Parse_arg_id_callbacks.
// Used in _Parse_width so that _Parse_arg_id can be used to parse dynamic widths.
template <class _CharT, _Parse_spec_callbacks<_CharT> _Callbacks_type>
struct _Width_adapter {
    _Callbacks_type& _Callbacks;

    constexpr explicit _Width_adapter(_Callbacks_type& _Handler) : _Callbacks(_Handler) {}

    constexpr void _On_auto_id() {
        _Callbacks._On_dynamic_width(_Auto_id_tag{});
    }
    constexpr void _On_manual_id(size_t _Id) {
        _Callbacks._On_dynamic_width(_Id);
    }
};

// Adapts a type modeling _Parse_spec_callbacks to model _Parse_arg_id_callbacks.
// Used in _Parse_precision so that _Parse_arg_id can be used to parse dynamic precisions.
template <class _CharT, _Parse_spec_callbacks<_CharT> _Callbacks_type>
struct _Precision_adapter {
    _Callbacks_type& _Callbacks;

    constexpr explicit _Precision_adapter(_Callbacks_type& _Handler) : _Callbacks(_Handler) {}

    constexpr void _On_auto_id() {
        _Callbacks._On_dynamic_precision(_Auto_id_tag{});
    }
    constexpr void _On_manual_id(size_t _Id) {
        _Callbacks._On_dynamic_precision(_Id);
    }
};

// _Parse_arg_id expects a handler when it finds an argument id, however
// _Parse_replacement_field actually needs to know the value of that argument ID to pass on
// to _Handler._On_replacement_field or _Handler._On_format_specs. This _Parse_arg_id wrapper
// stores the value of the arg id for later use, so _Parse_replacement_field has access to it.
template <class _CharT>
struct _Id_adapter {
    basic_format_parse_context<_CharT>& _Parse_context;
    size_t _Arg_id = static_cast<size_t>(-1);
    constexpr void _On_auto_id() {
        _Arg_id = _Parse_context.next_arg_id();
        _STL_INTERNAL_CHECK(_Arg_id != static_cast<size_t>(-1));
    }
    constexpr void _On_manual_id(size_t _Id) {
        _Parse_context.check_arg_id(_Id);
        _Arg_id = _Id;
        _STL_INTERNAL_CHECK(_Arg_id != static_cast<size_t>(-1));
    }
};

template <class _CharT, _Parse_spec_callbacks<_CharT> _Callbacks_type>
constexpr const _CharT* _Parse_width(const _CharT* _Begin, const _CharT* _End, _Callbacks_type&& _Callbacks) {
    _STL_INTERNAL_CHECK(_Begin != _End);
    if ('1' <= *_Begin && *_Begin <= '9') {
        int _Value = 0;
        _Begin     = _Parse_nonnegative_integer(_Begin, _End, _Value);
        _Callbacks._On_width(_Value);
    } else if (*_Begin == '{') {
        ++_Begin;
        if (_Begin != _End) {
            _Begin = _Parse_arg_id(_Begin, _End, _Width_adapter<_CharT, _Callbacks_type>{_Callbacks});
        }
        if (_Begin == _End || *_Begin != '}') {
            throw format_error("Invalid format string.");
        }
        ++_Begin;
    }
    return _Begin;
}

template <class _CharT, _Parse_spec_callbacks<_CharT> _Callbacks_type>
constexpr const _CharT* _Parse_precision(const _CharT* _Begin, const _CharT* _End, _Callbacks_type&& _Callbacks) {
    ++_Begin;
    _CharT _Ch = '\0';
    if (_Begin != _End) {
        _Ch = *_Begin;
    }

    if ('0' <= _Ch && _Ch <= '9') {
        int _Precision = 0;
        _Begin         = _Parse_nonnegative_integer(_Begin, _End, _Precision);
        _Callbacks._On_precision(_Precision);
    } else if (_Ch == '{') {
        ++_Begin;
        if (_Begin != _End) {
            _Begin = _Parse_arg_id(_Begin, _End, _Precision_adapter<_CharT, _Callbacks_type>{_Callbacks});
        }

        if (_Begin == _End || *_Begin != '}') {
            throw format_error("Invalid format string.");
        }
    } else {
        throw format_error("Missing precision specifier.");
    }
    return _Begin;
}

template <class _CharT, _Parse_spec_callbacks<_CharT> _Callbacks_type>
constexpr const _CharT* _Parse_format_specs(const _CharT* _Begin, const _CharT* _End, _Callbacks_type&& _Callbacks) {
    if (_Begin == _End || *_Begin == '}') {
        return _Begin;
    }

    _Begin = _Parse_align(_Begin, _End, _Callbacks);
    if (_Begin == _End) {
        return _Begin;
    }

    switch (*_Begin) {
    case '+':
        _Callbacks._On_sign(_Sign::_Plus);
        ++_Begin;
        break;
    case '-':
        _Callbacks._On_sign(_Sign::_Minus);
        ++_Begin;
        break;
    case ' ':
        _Callbacks._On_sign(_Sign::_Space);
        ++_Begin;
        break;
    default:
        break;
    }

    if (_Begin == _End) {
        return _Begin;
    }

    if (*_Begin == '#') {
        _Callbacks._On_hash();
        if (++_Begin == _End) {
            return _Begin;
        }
    }

    if (*_Begin == '0') {
        _Callbacks._On_zero();
        if (++_Begin == _End) {
            return _Begin;
        }
    }

    _Begin = _Parse_width(_Begin, _End, _Callbacks);
    if (_Begin == _End) {
        return _Begin;
    }

    if (*_Begin == '.') {
        _Begin = _Parse_precision(_Begin, _End, _Callbacks);
        if (_Begin == _End) {
            return _Begin;
        }
    }

    if (*_Begin == 'L') {
        _Callbacks._On_localized();
        if (++_Begin == _End) {
            return _Begin;
        }
    }

    // If there's anything remaining we assume it's a type.
    if (*_Begin != '}') {
        _Callbacks._On_type(*_Begin++);
    }
    return _Begin;
}

template <class _CharT, _Parse_replacement_field_callbacks<_CharT> _HandlerT>
constexpr const _CharT* _Parse_replacement_field(const _CharT* _Begin, const _CharT* _End, _HandlerT&& _Handler) {
    ++_Begin;
    if (_Begin == _End) {
        throw format_error("Invalid format string.");
    }

    if (*_Begin == '}') {
        // string was "{}", and we have a replacement field
        _Handler._On_replacement_field(_Handler._Parse_context.next_arg_id(), _Begin);
    } else if (*_Begin == '{') {
        // string was "{{", so we have a literal "{" to print
        _Handler._On_text(_Begin, _Begin + 1);
    } else {
        _Id_adapter<_CharT> _Adapter{_Handler._Parse_context};
        _Begin     = _Parse_arg_id(_Begin, _End, _Adapter);
        _CharT _Ch = _CharT{};
        if (_Begin != _End) {
            _Ch = *_Begin;
        }
        if (_Ch == '}') {
            _Handler._On_replacement_field(_Adapter._Arg_id, _Begin);
        } else if (_Ch == ':') {
            _Begin = _Handler._On_format_specs(_Adapter._Arg_id, _Begin + 1, _End);
            if (_Begin == _End || *_Begin != '}') {
                throw format_error("Unknown format specifier.");
            }
        } else {
            throw format_error("Missing '}' in format string.");
        }
    }
    return _Begin + 1;
}

template <class _CharT, _Parse_replacement_field_callbacks<_CharT> _HandlerT>
constexpr void _Parse_format_string(basic_string_view<_CharT> _Format_str, _HandlerT&& _Handler) {
    auto _Begin = _Format_str.data();
    auto _End   = _Begin + _Format_str.size();
    while (_Begin != _End) {
        const _CharT* _OpeningCurl = _Begin;
        if (*_Begin != '{') {
            // we didn't start at an opening curl, find the next one
            _OpeningCurl = _Find_unchecked(_Begin + 1, _End, '{');
            for (;;) {
                const _CharT* _ClosingCurl = _Find_unchecked(_Begin, _OpeningCurl, '}');

                // In this case there are neither closing nor opening curls in [_Begin, _OpenCurl)
                // Write the whole thing out.
                if (_ClosingCurl == _OpeningCurl) {
                    _Handler._On_text(_Begin, _OpeningCurl);
                    break;
                }
                // We know _ClosingCurl isn't past the end because
                // the above condition was not met.
                ++_ClosingCurl;
                if (_ClosingCurl == _OpeningCurl || *_ClosingCurl != '}') {
                    throw format_error("Unmatched '}' in format string.");
                }
                // We found two closing curls, so output only one of them
                _Handler._On_text(_Begin, _ClosingCurl);

                // skip over the second closing curl
                _Begin = _ClosingCurl + 1;
            }

            // We are done, there were no replacement fields.
            if (_OpeningCurl == _End) {
                return;
            }
        }
        // Parse the replacement field starting at _OpeningCurl and ending sometime before _End.
        _Begin = _Parse_replacement_field(_OpeningCurl, _End, _Handler);
    }
}


template <class _CharT>
struct _Basic_format_specs {
    int _Width         = 0;
    int _Precision     = -1;
    char _Type         = '\0';
    _Align _Alignment  = _Align::_None;
    _Sign _Sgn         = _Sign::_None;
    bool _Alt          = false;
    bool _Localized    = false;
    bool _Leading_zero = false;
    // At most one codepoint (so one char32_t or four utf-8 char8_t).
    _CharT _Fill[4] = {' ', _CharT{0}, _CharT{0}, _CharT{0}};
};

// Model of _Parse_specs_callbacks that fills a _Basic_format_specs with the parsed data.
template <class _CharT>
class _Specs_setter {
public:
    explicit constexpr _Specs_setter(_Basic_format_specs<_CharT>& _Specs_) : _Specs(_Specs_) {}

    constexpr void _On_align(_Align _Aln) {
        _Specs._Alignment = _Aln;
    }

    constexpr void _On_fill(basic_string_view<_CharT> _Sv) {
        if (_Sv.size() > 4) {
            throw format_error("Invalid fill (too long).");
        }
        _STD fill(_Specs._Fill, _Specs._Fill + 4, _CharT{});
        _STD copy(_Sv.begin(), _Sv.end(), _Specs._Fill);
    }

    constexpr void _On_sign(_Sign _Sgn) {
        _Specs._Sgn = _Sgn;
    }

    constexpr void _On_hash() {
        _Specs._Alt = true;
    }

    constexpr void _On_zero() {
        _Specs._Leading_zero = true;
    }

    constexpr void _On_width(int _Width) {
        _Specs._Width = _Width;
    }

    constexpr void _On_precision(int _Precision) {
        _Specs._Precision = _Precision;
    }

    constexpr void _On_localized() {
        _Specs._Localized = true;
    }

    constexpr void _On_type(_CharT _Type) {
        // performance note: this could be optimized to one comparison by
        // first casting to unsigned int (the negative values will be 128-255)
        if (_Type < 0 || _Type > (numeric_limits<signed char>::max)()) {
            throw format_error("Invalid type specification.");
        }
        _Specs._Type = static_cast<char>(_Type);
    }

protected:
    _Basic_format_specs<_CharT>& _Specs;
};

template <class _Context>
constexpr basic_format_arg<_Context> _Get_arg(_Context _Ctx, size_t _Arg_id) {
    // note: while this is parameterized on the _Arg_id type in libfmt we don't
    // need to do that in std::format because it's only called with either an integer
    // id or a named id (which we do not support in std::format)
    auto _Arg = _Ctx.arg(_Arg_id);
    if (!_Arg) {
        throw format_error("Argument not found.");
    }
    return _Arg;
}

// Checks that the type and value of an argument associated with a dynamic
// width specifier are valid.
class _Width_checker {
public:
    template <class _Ty>
    constexpr unsigned long long operator()(_Ty _Value) {
        if constexpr (is_integral_v<_Ty>) {
            if constexpr (is_signed_v<_Ty>) {
                if (_Value < 0) {
                    throw format_error("Negative width.");
                }
            }
            return static_cast<unsigned long long>(_Value);
        } else {
            throw format_error("Width is not an integer.");
        }
    }
};

// Checks that the type and value of an argument associated with a dynamic
// precision specifier are valid.
class _Precision_checker {
public:
    template <class _Ty>
    constexpr unsigned long long operator()(_Ty _Value) {
        if constexpr (is_integral_v<_Ty>) {
            if constexpr (is_signed_v<_Ty>) {
                if (_Value < 0) {
                    throw format_error("Negative precision.");
                }
            }
            return static_cast<unsigned long long>(_Value);
        } else {
            throw format_error("Precision is not an integer.");
        }
    }
};

// Parses standard format specs into a _Basic_format_specs using _Specs_setter, and,
// in addition handles dynamic width and precision. This is separate from _Specs setter
// because it needs to know about the current basic_format_parse_context and basic_format_context
// in order to fetch the width from the arguments.
template <class _ParseContext, class _Context>
class _Specs_handler : public _Specs_setter<typename _Context::char_type> {
public:
    using _CharT = typename _Context::char_type;

    constexpr _Specs_handler(_Basic_format_specs<_CharT>& _Specs_, _ParseContext& _Parse_ctx_, _Context& _Ctx_)
        : _Specs_setter<_CharT>(_Specs_), _Parse_ctx(_Parse_ctx_), _Ctx(_Ctx_) {}

    template <class _Id>
    constexpr void _On_dynamic_width(_Id _Arg_id) {
        this->_Specs._Width = _Get_dynamic_specs<_Width_checker>(_Get_arg(_Arg_id));
    }

    template <class _Id>
    constexpr void _On_dynamic_precision(_Id _Arg_id) {
        this->_Specs._Precision = _Get_dynamic_specs<_Precision_checker>(_Get_arg(_Arg_id));
    }

private:
    _ParseContext& _Parse_ctx;
    _Context& _Ctx;

    constexpr basic_format_arg<_Context> _Get_arg(_Auto_id_tag) {
        return _STD _Get_arg(_Ctx, _Parse_ctx.next_arg_id());
    }

    constexpr basic_format_arg<_Context> _Get_arg(size_t _Arg_id) {
        _Parse_ctx.check_arg_id(_Arg_id);
        return _STD _Get_arg(_Ctx, _Arg_id);
    }

    // Fetch the value of an argument associated with a dynamic
    // width or precision specifier. This will be called with either
    // _Width_checker or _Precision_checker as "_Handler".
    template <class _Handler, class _FormatArg>
    static constexpr int _Get_dynamic_specs(_FormatArg _Arg) {
        unsigned long long _Val = _STD visit_format_arg(_Handler(), _Arg);
        if (_Val > (numeric_limits<int>::max)()) {
            throw format_error("Number is too big.");
        }
        return static_cast<int>(_Val);
    }
};

class _Numeric_specs_checker {
private:
    _Basic_format_arg_type _Arg_type = _Basic_format_arg_type::_None;

public:
    constexpr explicit _Numeric_specs_checker(_Basic_format_arg_type _Arg_type_) : _Arg_type(_Arg_type_) {}

    constexpr void _Require_numeric_argument() const {
        if (!_Is_arithmetic_fmt_type(_Arg_type)) {
            throw format_error("Format specifier requires numeric argument.");
        }
    }

    constexpr void _Check_sign() const {
        _Require_numeric_argument();
        if (_Is_integral_fmt_type(_Arg_type) && _Arg_type != _Basic_format_arg_type::_Int_type
            && _Arg_type != _Basic_format_arg_type::_Long_long_type
            && _Arg_type != _Basic_format_arg_type::_Char_type) {
            throw format_error("Format specifier requires signed argument.");
        }
    }

    constexpr void _Check_precision() const {
        if (_Is_integral_fmt_type(_Arg_type) || _Arg_type == _Basic_format_arg_type::_Pointer_type) {
            throw format_error("Precision not allowed for this argument type.");
        }
    }
};

// Uses _Numeric_specs_checker to check that the type of the argument printed by
// a replacement field with format specs actually satisfies the requirements for
// that format spec. If the requirements are met then calls the base class
// handler method.
template <class _Handler>
class _Specs_checker : public _Handler {
private:
    _Numeric_specs_checker _Numeric_checker;

public:
    constexpr explicit _Specs_checker(const _Handler& _Handler_inst, _Basic_format_arg_type _Arg_type_)
        : _Handler(_Handler_inst), _Numeric_checker(_Arg_type_) {}

    // _On_align has no checking, since we don't implement numeric alignments.

    constexpr void _On_hash() {
        // Note that '#' is not valid for CharT or bool unless you
        // pass a numeric presentation type, but we encounter '#' before
        // the presentation type so we can not check that requirement here
        _Numeric_checker._Require_numeric_argument();
        _Handler::_On_hash();
    }

    constexpr void _On_zero() {
        // Note 0 is again not valid for CharT or bool unless a numeric
        // presentation type is uesd.
        _Numeric_checker._Require_numeric_argument();
        _Handler::_On_zero();
    }

    constexpr void _On_precision(int _Precision) {
        _Numeric_checker._Check_precision();
        _Handler::_On_precision(_Precision);
    }
};

// clang-format off
template <class _Context, class _Ty>
concept _Has_formatter = requires(const _Ty& _Val, _Context& _Ctx) {
    _STD declval<typename _Context::template formatter_type<_Ty>>().format(_Val, _Ctx);
};
// clang-format on

template <class _CharT>
constexpr size_t _Get_format_arg_type_storage_size(_Basic_format_arg_type _Type);

// See N4878 [format.arg]/5
// clang-format off
template <class _Context, class _Ty>
    requires _Has_formatter<_Context, _Ty>
/* consteval */ constexpr auto _Get_format_arg_storage_type(const _Ty& _Val) noexcept {
    // clang-format on
    return typename basic_format_arg<_Context>::handle{_Val};
}

// clang-format off
template <class _Context, class _Ty>
    requires integral<_Ty> || floating_point<_Ty>
/* consteval */ constexpr auto _Get_format_arg_storage_type(_Ty) noexcept {
    // clang-format on
    using _Char_type = typename _Context::char_type;
    if constexpr (is_same_v<_Ty, monostate>) {
        return monostate{};
    } else if constexpr (is_same_v<_Ty, bool>) {
        return bool{};
    } else if constexpr (is_same_v<_Ty, _Char_type>) {
        return _Char_type{};
    } else if constexpr (is_same_v<_Ty, char> && is_same_v<_Char_type, wchar_t>) {
        return _Char_type{};
    } else if constexpr (signed_integral<_Ty> && sizeof(_Ty) <= sizeof(int)) {
        return int{};
    } else if constexpr (unsigned_integral<_Ty> && sizeof(_Ty) <= sizeof(unsigned int)) {
        return static_cast<unsigned int>(42);
    } else if constexpr (signed_integral<_Ty> && sizeof(_Ty) <= sizeof(long long)) {
        return static_cast<long long>(42);
    } else if constexpr (unsigned_integral<_Ty> && sizeof(_Ty) <= sizeof(unsigned long long)) {
        return static_cast<unsigned long long>(42);
    } else if constexpr (is_same_v<_Ty, float>) {
        return float{};
    } else if constexpr (is_same_v<_Ty, double>) {
        return double{};
    } else if constexpr (is_same_v<_Ty, long double>) {
        return static_cast<long double>(42);
    } else {
        static_assert(_Always_false<_Ty>, "Invalid type passed to _Get_format_arg_storage_type");
        return static_cast<size_t>(-1);
    }
}

template <class _Context, class _Char_type = typename _Context::char_type>
/* consteval */ constexpr auto _Get_format_arg_storage_type(const _Char_type*) noexcept {
    return static_cast<const _Char_type*>(nullptr);
}

template <class _Context, class _Traits, class _Char_type = typename _Context::char_type>
/* consteval */ constexpr auto _Get_format_arg_storage_type(basic_string_view<_Char_type, _Traits>) noexcept {
    return basic_string_view<_Char_type>{};
}

template <class _Context, class _Traits, class _Alloc, class _Char_type = typename _Context::char_type>
/* consteval */ constexpr auto _Get_format_arg_storage_type(const basic_string<_Char_type, _Traits, _Alloc>&) noexcept {
    return basic_string_view<_Char_type>{};
}

template <class _Context>
/* consteval */ constexpr auto _Get_format_arg_storage_type(nullptr_t) noexcept {
    return static_cast<const void*>(nullptr);
}

// clang-format off
template <class _Context, class _Ty>
    requires is_void_v<_Ty>
/* consteval */ constexpr auto _Get_format_arg_storage_type(const _Ty*) noexcept {
    // clang-format on
    return static_cast<const void*>(nullptr);
}

template <class _Context, class _Ty>
inline constexpr size_t _Get_format_arg_storage_size = sizeof(
    _Get_format_arg_storage_type<_Context>(_STD declval<_Ty>()));

struct _Format_arg_store_packed_index {
    // TRANSITION, Should be templated on number of arguments for even less storage
    using _Index_type = size_t;

    constexpr _Format_arg_store_packed_index() = default;
    constexpr explicit _Format_arg_store_packed_index(const size_t _Index)
        : _Index(static_cast<_Index_type>(_Index)), _Type(_Basic_format_arg_type::_None) {}

    _Index_type _Index : (sizeof(_Index_type) * 8 - 4);
    _Basic_format_arg_type _Type : 4;
};

template <class _Context>
class basic_format_args;

template <class _Context, class... _Args>
class _Format_arg_store {
private:
    using _CharType   = typename _Context::char_type;
    using _Index_type = _Format_arg_store_packed_index;

    friend basic_format_args<_Context>;

    static constexpr size_t _Num_args       = sizeof...(_Args);
    static constexpr size_t _Index_length   = _Num_args * sizeof(_Index_type);
    static constexpr size_t _Storage_length = (_Get_format_arg_storage_size<_Context, _Args> + ... + 0);

    // we store the data in memory as _Format_arg_store_packed_index[_Index_length] + unsigned char[_Storage_length]
    unsigned char _Storage[_Index_length + _Storage_length];

    template <class _Ty>
    void _Store_impl(const size_t _Arg_index, const _Basic_format_arg_type _Arg_type, _Ty _Val) noexcept {
        const auto _Index_array = reinterpret_cast<_Index_type*>(_Storage);
        const auto _Store_index = _Index_array[_Arg_index]._Index;
        const auto _Length      = _Get_format_arg_type_storage_size<_CharType>(_Arg_type);

        _CSTD memcpy(_Storage + _Index_length + _Store_index, _STD addressof(_Val), _Length);
        _Index_array[_Arg_index]._Type = _Arg_type;
        if (_Arg_index + 1 < _Num_args) {
            // Set the starting index of the next arg, as that is dynamic, must be called with increasing index
            _Index_array[_Arg_index + 1] = _Format_arg_store_packed_index{_Store_index + _Length};
        }
    }

    // See [format.arg]/5
    // clang-format off
    template <class _Ty>
        requires _Has_formatter<_Context, _Ty>
    void _Store(const size_t _Arg_index, const _Ty& _Val) noexcept {
        // clang-format on
        using _Handle_type = typename basic_format_arg<_Context>::handle;
        _Store_impl<_Handle_type>(_Arg_index, _Basic_format_arg_type::_Custom_type, _Handle_type{_Val});
    }

    // clang-format off
    template <class _Ty>
        requires integral<_Ty> || floating_point<_Ty>
    void _Store(const size_t _Arg_index, _Ty _Val) noexcept {
        // clang-format on
        if constexpr (is_same_v<_Ty, bool>) {
            _Store_impl<bool>(_Arg_index, _Basic_format_arg_type::_Bool_type, _Val);
        } else if constexpr (is_same_v<_Ty, _CharType>) {
            _Store_impl<_CharType>(_Arg_index, _Basic_format_arg_type::_Char_type, _Val);
        } else if constexpr (is_same_v<_Ty, char> && is_same_v<_CharType, wchar_t>) {
            _Store_impl<_CharType>(_Arg_index, _Basic_format_arg_type::_Char_type, static_cast<wchar_t>(_Val));
        } else if constexpr (signed_integral<_Ty> && sizeof(_Ty) <= sizeof(int)) {
            _Store_impl<int>(_Arg_index, _Basic_format_arg_type::_Int_type, static_cast<int>(_Val));
        } else if constexpr (unsigned_integral<_Ty> && sizeof(_Ty) <= sizeof(unsigned int)) {
            _Store_impl<unsigned int>(_Arg_index, _Basic_format_arg_type::_UInt_type, static_cast<unsigned int>(_Val));
        } else if constexpr (signed_integral<_Ty> && sizeof(_Ty) <= sizeof(long long)) {
            _Store_impl<long long>(_Arg_index, _Basic_format_arg_type::_Long_long_type, static_cast<long long>(_Val));
        } else if constexpr (unsigned_integral<_Ty> && sizeof(_Ty) <= sizeof(unsigned long long)) {
            _Store_impl<unsigned long long>(
                _Arg_index, _Basic_format_arg_type::_ULong_long_type, static_cast<unsigned long long>(_Val));
        } else if constexpr (is_same_v<_Ty, float>) {
            _Store_impl<float>(_Arg_index, _Basic_format_arg_type::_Float_type, _Val);
        } else if constexpr (is_same_v<_Ty, double>) {
            _Store_impl<double>(_Arg_index, _Basic_format_arg_type::_Double_type, _Val);
        } else if constexpr (is_same_v<_Ty, long double>) {
            _Store_impl<long double>(_Arg_index, _Basic_format_arg_type::_Long_double_type, _Val);
        } else {
            static_assert(_Always_false<_Ty>, "Invalid type passed to _Format_arg_store::_Store");
        }
    }

    void _Store(const size_t _Arg_index, const _CharType* _Val) noexcept {
        _Store_impl<const _CharType*>(_Arg_index, _Basic_format_arg_type::_CString_type, _Val);
    }

    template <class _Traits>
    void _Store(const size_t _Arg_index, basic_string_view<_CharType, _Traits> _Val) noexcept {
        _Store_impl<basic_string_view<_CharType>>(
            _Arg_index, _Basic_format_arg_type::_String_type, basic_string_view<_CharType>{_Val});
    }

    template <class _Traits, class _Alloc>
    void _Store(const size_t _Arg_index, const basic_string<_CharType, _Traits, _Alloc>& _Val) noexcept {
        _Store_impl<basic_string_view<_CharType>>(
            _Arg_index, _Basic_format_arg_type::_String_type, basic_string_view<_CharType>{_Val.data(), _Val.size()});
    }

    void _Store(const size_t _Arg_index, nullptr_t) noexcept {
        _Store_impl<const void*>(_Arg_index, _Basic_format_arg_type::_Pointer_type, static_cast<const void*>(nullptr));
    }

    // clang-format off
    template <class _Ty>
        requires is_void_v<_Ty>
    void _Store(const size_t _Arg_index, const _Ty* _Ptr) noexcept {
        // clang-format on
        _Store_impl<const void*>(_Arg_index, _Basic_format_arg_type::_Pointer_type, static_cast<const void*>(_Ptr));
    }

public:
    _Format_arg_store(const _Args&... _Vals) noexcept {
        // Note: _Storage is uninitialized, so manually initialize the first index
        _STD construct_at(reinterpret_cast<_Format_arg_store_packed_index*>(_Storage));
        size_t _Arg_index = 0;
        (_Store(_Arg_index++, _Vals), ...);
    }
};

template <class _Context>
class _Format_arg_store<_Context> {};

template <class _Context>
class basic_format_args {
private:
    template <class _Ty>
    _NODISCARD static auto _Get_value_from_memory(const unsigned char* _Val) noexcept {
        auto& _Temp = *reinterpret_cast<const unsigned char(*)[sizeof(_Ty)]>(_Val);
        return _Bit_cast<_Ty>(_Temp);
    }

public:
    basic_format_args() noexcept;
    basic_format_args(const _Format_arg_store<_Context>&) noexcept {}
    template <class... _Args>
    basic_format_args(const _Format_arg_store<_Context, _Args...>& _Store) noexcept
        : _Num_args(sizeof...(_Args)), _Storage(_Store._Storage) {}

    basic_format_arg<_Context> get(const size_t _Index) const noexcept {
        if (_Index >= _Num_args) {
            return basic_format_arg<_Context>{};
        }

        using _CharType                   = typename _Context::char_type;
        const auto _Packed_index          = reinterpret_cast<const _Format_arg_store_packed_index*>(_Storage)[_Index];
        const auto _Index_length          = _Num_args * sizeof(_Format_arg_store_packed_index);
        const unsigned char* _Arg_storage = _Storage + _Index_length + _Packed_index._Index;

        switch (_Packed_index._Type) {
        case _Basic_format_arg_type::_None:
            return basic_format_arg<_Context>{};
        case _Basic_format_arg_type::_Int_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<int>(_Arg_storage)};
        case _Basic_format_arg_type::_UInt_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<unsigned int>(_Arg_storage)};
        case _Basic_format_arg_type::_Long_long_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<long long>(_Arg_storage)};
        case _Basic_format_arg_type::_ULong_long_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<unsigned long long>(_Arg_storage)};
        case _Basic_format_arg_type::_Bool_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<bool>(_Arg_storage)};
        case _Basic_format_arg_type::_Char_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<_CharType>(_Arg_storage)};
        case _Basic_format_arg_type::_Float_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<float>(_Arg_storage)};
        case _Basic_format_arg_type::_Double_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<double>(_Arg_storage)};
        case _Basic_format_arg_type::_Long_double_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<long double>(_Arg_storage)};
        case _Basic_format_arg_type::_Pointer_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<const void*>(_Arg_storage)};
        case _Basic_format_arg_type::_CString_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<const _CharType*>(_Arg_storage)};
        case _Basic_format_arg_type::_String_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<basic_string_view<_CharType>>(_Arg_storage)};
        case _Basic_format_arg_type::_Custom_type:
            return basic_format_arg<_Context>{
                _Get_value_from_memory<typename basic_format_arg<_Context>::handle>(_Arg_storage)};
        default:
            _STL_ASSERT(false, "Invalid basic_format_arg type");
            return basic_format_arg<_Context>{};
        }
    }

private:
    size_t _Num_args              = 0;
    const unsigned char* _Storage = nullptr;
};

// TODO: test coverage
// clang-format off
template <class _Out, class _CharT>
    requires output_iterator<_Out, _CharT>
class basic_format_context {
    // clang-format on
private:
    _Out _OutputIt;
    basic_format_args<basic_format_context> _Args;
    locale _Loc;

public:
    using iterator  = _Out;
    using char_type = _CharT;

    template <class _Ty>
    using formatter_type = formatter<_Ty, _CharT>;

    constexpr basic_format_context(
        _Out _OutputIt_, basic_format_args<basic_format_context> _Ctx_args, const locale& _Loc_)
        : _OutputIt(_OutputIt_), _Args(_Ctx_args), _Loc(_Loc_) {}

    basic_format_arg<basic_format_context> arg(size_t _Id) const {
        return _Args.get(_Id);
    }
    locale locale() {
        return _Loc;
    }

    iterator out() {
        return _OutputIt;
    }
    void advance_to(iterator _It) {
        // TODO: IDL support probably required
        _OutputIt = _It;
    }

    const basic_format_args<basic_format_context>& _Get_args() const {
        return _Args;
    }
};

template <class _CharT>
constexpr size_t _Get_format_arg_type_storage_size(_Basic_format_arg_type _Type) {
    switch (_Type) {
    case _Basic_format_arg_type::_Int_type:
        return sizeof(int);
    case _Basic_format_arg_type::_UInt_type:
        return sizeof(unsigned int);
    case _Basic_format_arg_type::_Long_long_type:
        return sizeof(long long);
    case _Basic_format_arg_type::_ULong_long_type:
        return sizeof(unsigned long long);
    case _Basic_format_arg_type::_Bool_type:
        return sizeof(bool);
    case _Basic_format_arg_type::_Char_type:
        return sizeof(_CharT);
    case _Basic_format_arg_type::_Float_type:
        return sizeof(float);
    case _Basic_format_arg_type::_Double_type:
        return sizeof(double);
    case _Basic_format_arg_type::_Long_double_type:
        return sizeof(long double);
    case _Basic_format_arg_type::_Pointer_type:
        return sizeof(void*);
    case _Basic_format_arg_type::_CString_type:
        return sizeof(const _CharT*);
    case _Basic_format_arg_type::_String_type:
        return sizeof(basic_string_view<_CharT>);
    case _Basic_format_arg_type::_Custom_type:
        return sizeof(void*) + sizeof(void (*)());
    case _Basic_format_arg_type::_None:
    default:
        _STL_INTERNAL_CHECK(false);
        return 0;
    }
}

template <class _CharT, class _OutputIt>
_OutputIt _Write(_OutputIt _Out, monostate) {
    _STL_INTERNAL_CHECK(false);
    return _Out;
}

// This size is derived from the maximum length of an arithmetic type. The two contenders for widest are double and long
// long. long long has a max length of ceil(log_10(2^64)) = 20 characters. double has a max length of
// limits<double>::max_digits10 + the decimal + the sign + e + the exponent's sign + ceil(log_10(DBL_MAX_10_EXP))
// = 17 + 1 + 1 + 1 + 3 = 24. An example is DBL_MAX which is "-1.7976931348623158e+308".
inline constexpr size_t _Format_min_buffer_length = 24;

#pragma warning(push)
#pragma warning(disable : 4365) // 'argument': conversion from 'char' to 'const wchar_t', signed/unsigned mismatch
// clang-format off
template <class _CharT, class _OutputIt, class _Arithmetic>
    requires (is_arithmetic_v<_Arithmetic> && !_CharT_or_bool<_Arithmetic, _CharT>)
_OutputIt _Write(_OutputIt _Out, const _Arithmetic _Value) {
    // clang-format on
    // TRANSITION, Reusable buffer
    array<char, _Format_min_buffer_length> _Buffer;
    const auto [_End, _Ec] = _STD to_chars(_Buffer.data(), _Buffer.data() + _Buffer.size(), _Value);
    _STL_ASSERT(_Ec == errc{}, "to_chars failed");
    return _STD copy(_Buffer.data(), _End, _Out);
}
#pragma warning(pop)

template <class _CharT, class _OutputIt>
_OutputIt _Write(_OutputIt _Out, const bool _Value) {
    if constexpr (is_same_v<_CharT, wchar_t>) {
        return _Write(_Out, _Value ? L"true" : L"false");
    } else {
        return _Write(_Out, _Value ? "true" : "false");
    }
}

template <class _CharT, class _OutputIt>
_OutputIt _Write(_OutputIt _Out, const _CharT _Value) {
    *_Out = _Value;
    return ++_Out;
}

#pragma warning(push)
#pragma warning(disable : 4365) // 'argument': conversion from 'char' to 'const wchar_t', signed/unsigned mismatch
template <class _CharT, class _OutputIt>
_OutputIt _Write(_OutputIt _Out, const void* const _Value) {
    // TRANSITION, Reusable buffer
    array<char, _Format_min_buffer_length> _Buffer;
    const auto [_End, _Ec] =
        _STD to_chars(_Buffer.data(), _Buffer.data() + _Buffer.size(), reinterpret_cast<uintptr_t>(_Value), 16);
    _STL_ASSERT(_Ec == errc{}, "to_chars failed");
    *_Out++ = '0';
    *_Out++ = 'x';
    return _STD copy(_Buffer.data(), _End, _Out);
}
#pragma warning(pop)

template <class _CharT, class _OutputIt>
_OutputIt _Write(_OutputIt _Out, const _CharT* _Value) {
    if (!_Value) {
        throw format_error("String pointer is null.");
    }
    while (*_Value) {
        *_Out++ = *_Value++;
    }
    return _Out;
}

template <class _CharT, class _OutputIt>
_OutputIt _Write(_OutputIt _Out, const basic_string_view<_CharT> _Value) {
    return _STD copy(_Value.begin(), _Value.end(), _Out);
}

template <class _CharT, class _OutputIt, class _Func>
_OutputIt _Write_aligned(_OutputIt _Out, const int _Width, const _Basic_format_specs<_CharT>& _Specs,
    const _Align _Default_align, _Func&& _Fn) {
    int _Fill_left  = 0;
    int _Fill_right = 0;
    auto _Alignment = _Specs._Alignment;

    if (_Alignment == _Align::_None) {
        _Alignment = _Default_align;
    }

    if (_Width < _Specs._Width) {
        switch (_Alignment) {
        case _Align::_Left:
            _Fill_right = _Specs._Width - _Width;
            break;
        case _Align::_Right:
            _Fill_left = _Specs._Width - _Width;
            break;
        case _Align::_Center:
            _Fill_left  = (_Specs._Width - _Width) / 2;
            _Fill_right = _Specs._Width - _Width - _Fill_left;
            break;
        case _Align::_None:
            _STL_ASSERT(false, "Invalid alignment");
            break;
        }
    }

    // TRANSITION, add support for unicode/wide formats
    _Out = _STD fill_n(_Out, _Fill_left, _Specs._Fill[0]);
    _Out = _Fn(_Out);
    return _STD fill_n(_Out, _Fill_right, _Specs._Fill[0]);
}

template <integral _Integral>
_NODISCARD constexpr string_view _Get_integral_prefix(const char _Type, const _Integral _Value) {
    switch (_Type) {
    case 'b':
        return "0b"sv;
    case 'B':
        return "0B"sv;
    case 'x':
        return "0x"sv;
    case 'X':
        return "0X"sv;
    case 'o':
        if (_Value != _Integral{0}) {
            return "0"sv;
        }
        return {};
    default:
        return {};
    }
}

template <class _OutputIt>
_OutputIt _Write_sign(_OutputIt _Out, const _Sign _Sgn, const bool _Is_negative) {
    if (_Is_negative) {
        *_Out = '-';
    } else {
        switch (_Sgn) {
        case _Sign::_Plus:
            *_Out = '+';
            break;
        case _Sign::_Space:
            *_Out = ' ';
            break;
        case _Sign::_None:
        case _Sign::_Minus:
            break;
        }
    }
    return ++_Out;
}

inline void _Buffer_to_uppercase(char* _Begin, const char* _End) {
    for (; _Begin != _End; ++_Begin) {
        *_Begin = static_cast<char>(_CSTD toupper(*_Begin));
    }
}

template <class _CharT, integral _Ty>
_NODISCARD constexpr bool _In_bounds(const _Ty _Value) {
    if constexpr (is_unsigned_v<_CharT> && is_unsigned_v<_Ty>) {
        return _Value <= (numeric_limits<_CharT>::max)();
    } else if constexpr (is_unsigned_v<_CharT>) {
        return _Value >= 0 && static_cast<make_unsigned_t<_Ty>>(_Value) <= (numeric_limits<_CharT>::max)();
    } else if constexpr (is_unsigned_v<_Ty>) {
        return _Value <= static_cast<make_unsigned_t<_CharT>>((numeric_limits<_CharT>::max)());
    } else {
        return (numeric_limits<_CharT>::min)() <= _Value && _Value <= (numeric_limits<_CharT>::max)();
    }
}

_NODISCARD inline int _Count_separators(size_t _Digits, const string_view _Groups) {
    int _Separators = 0;
    if (!_Groups.empty()) {
        // Calculate the amount of separators that are going to be inserted based on the groupings of the locale.
        auto _Group_it = _Groups.begin();
        while (_Digits > static_cast<size_t>(*_Group_it)) {
            _Digits -= static_cast<size_t>(*_Group_it);
            ++_Separators;
            if (_Group_it + 1 != _Groups.end()) {
                ++_Group_it;
            }
        }
    }
    return _Separators;
}

template <class _CharT, class _OutputIt>
_OutputIt _Write_separated_integer(const char* _Start, const char* const _End, const string_view _Groups,
    const _CharT _Separator, int _Separators, _OutputIt _Out) {
    auto _Group_it = _Groups.begin();
    auto _Repeats  = 0;
    auto _Grouped  = 0;

    for (int _Section = 0; _Section < _Separators; ++_Section) {
        _Grouped += *_Group_it;
        if (_Group_it + 1 != _Groups.end()) {
            ++_Group_it;
        } else {
            ++_Repeats;
        }
    }
    _Out   = _STD copy(_Start, _End - _Grouped, _Out);
    _Start = _End - _Grouped;

    for (; _Separators > 0; --_Separators) {
        if (_Repeats > 0) {
            --_Repeats;
        } else {
            --_Group_it;
        }

        *_Out++ = _Separator;
        _Out    = _STD copy(_Start, _Start + *_Group_it, _Out);
        _Start += *_Group_it;
    }
    _STL_INTERNAL_CHECK(_Start == _End);
    return _Out;
}

template <class _CharT, class _OutputIt>
_OutputIt _Write(_OutputIt _Out, monostate, const _Basic_format_specs<_CharT>&, locale) {
    _STL_INTERNAL_CHECK(false);
    return _Out;
}

#pragma warning(push)
#pragma warning(disable : 4365) // 'argument': conversion from 'char' to 'const wchar_t', signed/unsigned mismatch
template <class _CharT, class _OutputIt, integral _Integral>
_OutputIt _Write_integral(_OutputIt _Out, const _Integral _Value, _Basic_format_specs<_CharT> _Specs, locale _Locale) {
    if (_Specs._Type == 'c') {
        if (!_In_bounds<_CharT>(_Value)) {
            throw format_error("integral cannot be stored in charT");
        }
        _Specs._Alt = false;
        return _Write(_Out, static_cast<_CharT>(_Value), _Specs, _Locale);
    }

    if (_Specs._Precision != -1) {
        throw format_error("integral cannot have a precision");
    }

    if (_Specs._Sgn == _Sign::_None) {
        _Specs._Sgn = _Sign::_Minus;
    }

    int _Base      = 10;
    bool _To_upper = false;

    switch (_Specs._Type) {
    case '\0':
    case 'd':
        break;
    case 'B':
        _To_upper = true;
        [[fallthrough]];
    case 'b':
        _Base = 2;
        break;
    case 'X':
        _To_upper = true;
        [[fallthrough]];
    case 'x':
        _Base = 16;
        break;
    case 'o':
        _Base = 8;
        break;
    default:
        throw format_error("invalid integral type");
    }

    // long long -1 representation in binary is 64 bits + sign
    array<char, 65> _Buffer;
    const auto [_End, _Ec] = _STD to_chars(_Buffer.data(), _Buffer.data() + _Buffer.size(), _Value, _Base);
    _STL_ASSERT(_Ec == errc{}, "to_chars failed");

    auto _Buffer_start = _Buffer.data();
    auto _Width        = static_cast<int>(_End - _Buffer_start);

    if (_Value >= _Integral{0}) {
        if (_Specs._Sgn != _Sign::_Minus) {
            _Width += 1;
        }
    } else {
        // Remove the '-', it will be dealt with directly
        _Buffer_start += 1;
    }

    if (_To_upper) {
        _Buffer_to_uppercase(_Buffer_start, _End);
    }

    string_view _Prefix;
    if (_Specs._Alt) {
        _Prefix = _Get_integral_prefix(_Specs._Type, _Value);
        _Width += static_cast<int>(_Prefix.size());
    }

    auto _Separators = 0;
    string _Groups;
    if (_Specs._Localized) {
        _Groups     = _STD use_facet<numpunct<_CharT>>(_Locale).grouping();
        _Separators = _Count_separators(_End - _Buffer_start, _Groups);
        // TRANSITION, separators may be wider for wide chars
        _Width += _Separators;
    }

    const bool _Write_leading_zeroes = _Specs._Leading_zero && _Specs._Alignment == _Align::_None;
    auto _Writer                     = [&, _End = _End](_OutputIt _Out) {
        _Out = _Write_sign(_Out, _Specs._Sgn, _Value < _Integral{0});
        _Out = _STD copy(_Prefix.begin(), _Prefix.end(), _Out);
        if (_Write_leading_zeroes && _Width < _Specs._Width) {
            _Out = _STD fill_n(_Out, _Specs._Width - _Width, '0');
        }
        if (_Separators > 0) {
            return _Write_separated_integer(_Buffer_start, _End, _Groups,
                _STD use_facet<numpunct<_CharT>>(_Locale).thousands_sep(), _Separators, _Out);
        }
        return _STD copy(_Buffer_start, _End, _Out);
    };

    if (_Write_leading_zeroes) {
        return _Writer(_Out);
    }

    return _Write_aligned(_Out, _Width, _Specs, _Align::_Right, _Writer);
}
#pragma warning(pop)

// clang-format off
template <class _CharT, class _OutputIt, integral _Integral>
    requires (!_CharT_or_bool<_Integral, _CharT>)
_OutputIt _Write(_OutputIt _Out, const _Integral _Value, const _Basic_format_specs<_CharT>& _Specs, locale _Locale) {
    // clang-format on
    return _Write_integral(_Out, _Value, _Specs, _Locale);
}

template <class _CharT, class _OutputIt>
_OutputIt _Write(_OutputIt _Out, const bool _Value, _Basic_format_specs<_CharT> _Specs, locale _Locale) {
    if (_Specs._Type != '\0' && _Specs._Type != 's') {
        return _Write_integral(_Out, static_cast<unsigned char>(_Value), _Specs, _Locale);
    }

    if (_Specs._Precision != -1) {
        throw format_error("bool cannot have a precision");
    }

    if (_Specs._Localized) {
        _Specs._Localized = false;
        return _Write(_Out,
            _Value ? static_cast<basic_string_view<_CharT>>(_STD use_facet<numpunct<_CharT>>(_Locale).truename())
                   : static_cast<basic_string_view<_CharT>>(_STD use_facet<numpunct<_CharT>>(_Locale).falsename()),
            _Specs, _Locale);
    }

    if constexpr (is_same_v<_CharT, wchar_t>) {
        return _Write(_Out, _Value ? L"true" : L"false", _Specs, _Locale);
    } else {
        return _Write(_Out, _Value ? "true" : "false", _Specs, _Locale);
    }
}

template <class _CharT, class _OutputIt>
_OutputIt _Write(_OutputIt _Out, const _CharT _Value, _Basic_format_specs<_CharT> _Specs, locale _Locale) {
    if (_Specs._Type != '\0' && _Specs._Type != 'c') {
        return _Write_integral(_Out, _Value, _Specs, _Locale);
    }

    if (_Specs._Precision != -1) {
        throw format_error("charT cannot have a precision");
    }

    // Clear the type so that the string_view writer doesn't fail on 'c'.
    _Specs._Type = '\0';
    return _Write(_Out, basic_string_view<_CharT>{&_Value, 1}, _Specs, _Locale);
}

#pragma warning(push)
#pragma warning(disable : 4365) // 'argument': conversion from 'char' to 'const wchar_t', signed/unsigned mismatch
template <class _CharT, class _OutputIt, floating_point _Float>
_OutputIt _Write(_OutputIt _Out, const _Float _Value, const _Basic_format_specs<_CharT>& _Specs, locale _Locale) {
    auto _Sgn = _Specs._Sgn;
    if (_Sgn == _Sign::_None) {
        _Sgn = _Sign::_Minus;
    }

    auto _To_upper  = false;
    auto _Format    = chars_format::general;
    auto _Exponent  = '\0';
    auto _Precision = _Specs._Precision;

    switch (_Specs._Type) {
    case '\0':
        break;
    case 'A':
        _To_upper = true;
        [[fallthrough]];
    case 'a':
        _Format   = chars_format::hex;
        _Exponent = 'p';
        break;
    case 'E':
        _To_upper = true;
        [[fallthrough]];
    case 'e':
        if (_Precision == -1) {
            _Precision = 6;
        }
        _Format   = chars_format::scientific;
        _Exponent = 'e';
        break;
    case 'F':
    case 'f':
        if (_Precision == -1) {
            _Precision = 6;
        }
        _Format = chars_format::fixed;
        break;
    case 'G':
        _To_upper = true;
        [[fallthrough]];
    case 'g':
        if (_Precision == -1) {
            _Precision = 6;
        }
        _Format   = chars_format::general;
        _Exponent = 'e';
        break;
    default:
        throw format_error("invalid floating point type");
    }

    // Consider the powers of 2 in decimal:
    // 2^-1 = 0.5
    // 2^-2 = 0.25
    // 2^-3 = 0.125
    // 2^-4 = 0.0625
    // Each power of 2 consumes one more decimal digit. This is because:
    // 2^-N * 5^-N = 10^-N
    // 2^-N = 10^-N * 5^N
    // Example: 2^-4 = 10^-4 * 5^4 = 0.0001 * 625
    // Therefore, the min subnormal 2^-1074 consumes 1074 digits of precision (digits after the decimal point).
    // We need 3 more characters for a potential negative sign, the zero integer part, and the decimal point.
    // Therefore, the precision can be clamped to 1074.
    // The largest number consumes 309 digits before the decimal point. With a precision of 1074, and it being negative,
    // it would use a buffer of size 1074+309+2.
    // We need to add an additional number to the max exponent to accommodate the ones place.
    constexpr auto _Max_precision = 1074;
    constexpr auto _Buffer_size   = _Max_precision + DBL_MAX_10_EXP + 3;
    array<char, _Buffer_size> _Buffer;
    to_chars_result _Result;

    auto _Extra_precision = 0;
    if (_Precision > _Max_precision) {
        _Extra_precision = _Precision - _Max_precision;
        _Precision       = _Max_precision;
    }

    if (_Precision == -1) {
        _Result = _STD to_chars(_Buffer.data(), _Buffer.data() + _Buffer.size(), _Value, _Format);
    } else {
        _Result = _STD to_chars(_Buffer.data(), _Buffer.data() + _Buffer.size(), _Value, _Format, _Precision);
    }

    _STL_ASSERT(_Result.ec == errc{}, "to_chars failed");

    auto _Buffer_start = _Buffer.data();
    auto _Width        = static_cast<int>(_Result.ptr - _Buffer_start);

    const auto _Is_negative = _STD signbit(_Value);

    if (_Is_negative) {
        // Remove the '-', it will be dealt with directly
        _Buffer_start += 1;
    } else {
        if (_Sgn != _Sign::_Minus) {
            _Width += 1;
        }
    }

    if (_To_upper) {
        _Buffer_to_uppercase(_Buffer_start, _Result.ptr);
        _Exponent = static_cast<char>(_CSTD toupper(_Exponent));
    }

    const auto _Is_finite = !_STD isnan(_Value) && !_STD isinf(_Value);

    auto _Append_decimal   = false;
    auto _Exponent_start   = _Result.ptr;
    auto _Radix_point      = _Result.ptr;
    auto _Integral_end     = _Result.ptr;
    auto _Zeroes_to_append = 0;
    auto _Separators       = 0;
    string _Groups;

    if ((_Specs._Alt || _Specs._Localized) && _Is_finite) {
        for (auto _It = _Buffer_start; _It < _Result.ptr; ++_It) {
            if (*_It == '.') {
                _Radix_point = _It;
            } else if (*_It == _Exponent) {
                _Exponent_start = _It;
            }
        }
        _Integral_end = (_STD min)(_Radix_point, _Exponent_start);

        if (_Specs._Alt) {
            if (_Radix_point == _Result.ptr) {
                // TRANSITION, decimal point may be wider
                ++_Width;
                _Append_decimal = true;
            }
            if (_Specs._Type == 'g' || _Specs._Type == 'G') {
                _Zeroes_to_append = _Extra_precision + _Precision - static_cast<int>(_Exponent_start - _Buffer_start);
                if (!_Append_decimal) {
                    _Zeroes_to_append += 1;
                }
            }
        }

        if (_Specs._Localized) {
            _Groups     = _STD use_facet<numpunct<_CharT>>(_Locale).grouping();
            _Separators = _Count_separators(_Integral_end - _Buffer_start, _Groups);
        }
    }

    if (_Is_finite && (_Specs._Type == 'f' || _Specs._Type == 'F')) {
        _Zeroes_to_append = _Extra_precision;
    }

    _Width += _Zeroes_to_append;

    const bool _Write_leading_zeroes = _Specs._Leading_zero && _Specs._Alignment == _Align::_None && _Is_finite;

    auto _Writer = [&](_OutputIt _Out) {
        _Out = _Write_sign(_Out, _Sgn, _Is_negative);

        if (_Write_leading_zeroes && _Width < _Specs._Width) {
            _Out = _STD fill_n(_Out, _Specs._Width - _Width, '0');
        }

        if (_Specs._Localized) {
            _Out = _Write_separated_integer(_Buffer_start, _Integral_end, _Groups,
                _STD use_facet<numpunct<_CharT>>(_Locale).thousands_sep(), _Separators, _Out);
            if (_Radix_point != _Result.ptr || _Append_decimal) {
                *_Out++         = _STD use_facet<numpunct<_CharT>>(_Locale).decimal_point();
                _Append_decimal = false;
            }
            _Buffer_start = _Integral_end;
            if (_Radix_point != _Result.ptr) {
                ++_Buffer_start;
            }
        }

        _Out          = _STD copy(_Buffer_start, _Exponent_start, _Out);
        _Buffer_start = _Exponent_start;

        if (_Specs._Alt && _Append_decimal) {
            *_Out++ = '.';
        }

        for (; _Zeroes_to_append > 0; --_Zeroes_to_append) {
            *_Out++ = '0';
        }

        return _STD copy(_Buffer_start, _Result.ptr, _Out);
    };

    if (_Write_leading_zeroes) {
        return _Writer(_Out);
    }

    return _Write_aligned(_Out, _Width, _Specs, _Align::_Right, _Writer);
}
#pragma warning(pop)

template <class _CharT, class _OutputIt>
_OutputIt _Write(_OutputIt _Out, const void* const _Value, const _Basic_format_specs<_CharT>& _Specs, locale) {
    if (_Specs._Type != '\0' && _Specs._Type != 'p') {
        throw format_error("invalid const void* type");
    }

    if (_Specs._Sgn != _Sign::_None) {
        throw format_error("const void* cannot have a sign");
    }

    if (_Specs._Alt) {
        throw format_error("const void* cannot have an alternative representation");
    }

    if (_Specs._Precision != -1) {
        throw format_error("const void* cannot have a precision");
    }

    if (_Specs._Leading_zero) {
        throw format_error("const void* cannot have a leading zero");
    }

    if (_Specs._Localized) {
        throw format_error("const void* cannot be localized");
    }

    // Compute the bit width of the pointer (i.e. how many bits it takes to be represented).
    // Add 3 to the bit width so we always round up on the division.
    // Divide that by the amount of bits a hex number represents (log2(16) = log2(2^4) = 4).
    // Add 2 for the 0x prefix.
    auto _Width = 2 + static_cast<int>(_STD bit_width(reinterpret_cast<uintptr_t>(_Value)) + 3) / 4;

    // Since the bit width of 0 is 0, special case it instead of complicating the math even more.
    if (_Value == nullptr) {
        _Width = 3;
    }

    return _Write_aligned(
        _Out, _Width, _Specs, _Align::_Left, [=](_OutputIt _Out) { return _Write<_CharT>(_Out, _Value); });
}

template <class _CharT, class _OutputIt>
_OutputIt _Write(_OutputIt _Out, const _CharT* _Value, const _Basic_format_specs<_CharT>& _Specs, locale _Locale) {
    return _Write(_Out, basic_string_view<_CharT>{_Value}, _Specs, _Locale);
}

template <class _CharT, class _OutputIt>
_OutputIt _Write(
    _OutputIt _Out, const basic_string_view<_CharT> _Value, const _Basic_format_specs<_CharT>& _Specs, locale) {
    if (_Specs._Type != '\0' && _Specs._Type != 's') {
        throw format_error("invalid string type");
    }

    if (_Specs._Sgn != _Sign::_None) {
        throw format_error("string cannot have a sign");
    }

    if (_Specs._Alt) {
        throw format_error("string cannot have an alternative representation");
    }

    if (_Specs._Leading_zero) {
        throw format_error("string cannot have a leading zero");
    }

    if (_Specs._Localized) {
        throw format_error("string cannot be localized");
    }

    auto _Printed_size = static_cast<int>(_Value.size());

    if (_Specs._Precision != -1 && _Printed_size > _Specs._Precision) {
        _Printed_size = _Specs._Precision;
    }

    return _Write_aligned(_Out, _Printed_size, _Specs, _Align::_Left,
        [=](_OutputIt _Out) { return _Write(_Out, _Value.substr(size_t{0}, static_cast<size_t>(_Printed_size))); });
}

// This is the visitor that's used for "simple" replacement fields,
// it could be a generic lambda (with overloaded), but that's
// bad for throughput. A simple replacement field is a replacement field
// that's just "{}", without any format specs.
template <class _OutputIt, class _CharT>
struct _Default_arg_formatter {
    using _Context = basic_format_context<_OutputIt, _CharT>;

    _OutputIt _Out;
    basic_format_args<_Context> _Args;
    locale _Loc;

    template <class _Ty>
    _OutputIt operator()(_Ty _Val) {
        return _Write<_CharT>(_Out, _Val);
    }

    _OutputIt operator()(typename basic_format_arg<_Context>::handle _Handle) {
        basic_format_parse_context<_CharT> _Parse_ctx({});
        basic_format_context<_OutputIt, _CharT> _Format_ctx(_Out, _Args, _Loc);
        _Handle.format(_Parse_ctx, _Format_ctx);
        return _Format_ctx.out();
    }
};

// Visitor used for replacement fields that contain specs
template <class _OutputIt, class _CharT>
struct _Arg_formatter {
    using _Context = basic_format_context<_OutputIt, _CharT>;

    _Context* _Ctx                                 = nullptr;
    _Basic_format_specs<_CharT>* _Specs            = nullptr;
    basic_format_parse_context<_CharT>* _Parse_ctx = nullptr;

    _OutputIt operator()(typename basic_format_arg<_Context>::handle _Handle) {
        _STL_ASSERT(false, "The custom handler should be structurally unreachable for _Arg_formatter");
        _STL_INTERNAL_CHECK(_Parse_ctx);
        _STL_INTERNAL_CHECK(_Ctx);
        _Handle.format(*_Parse_ctx, *_Ctx);
        return _Ctx->out();
    }

    template <class _Ty>
    _OutputIt operator()(_Ty _Val) {
        _STL_INTERNAL_CHECK(_Specs);
        _STL_INTERNAL_CHECK(_Ctx);
        return _Write(_Ctx->out(), _Val, *_Specs, _Ctx->locale());
    }
};

// The top level set of parsing "actions".
template <class _OutputIt, class _CharT, class _Context>
struct _Format_handler {
    basic_format_parse_context<_CharT> _Parse_context;
    _Context _Ctx;

    explicit _Format_handler(
        _OutputIt _Out, basic_string_view<_CharT> _Str, basic_format_args<_Context> _Format_args, const locale& _Loc)
        : _Parse_context(_Str), _Ctx(_Out, _Format_args, _Loc) {}

    void _On_text(const _CharT* _Begin, const _CharT* _End) {
        auto _Size = _End - _Begin;
        auto _Out  = _Ctx.out();
        _Out       = _STD copy_n(_Begin, _Size, _Out);
        _Ctx.advance_to(_Out);
    }

    void _On_replacement_field(size_t _Id, const _CharT*) {
        auto _Arg = _Ctx.arg(_Id);
        _Ctx.advance_to(visit_format_arg(
            _Default_arg_formatter<_OutputIt, _CharT>{_Ctx.out(), _Ctx._Get_args(), _Ctx.locale()}, _Arg));
    }

    const _CharT* _On_format_specs(size_t _Id, const _CharT* _Begin, const _CharT* _End) {
        _Parse_context.advance_to(_Parse_context.begin() + (_Begin - &*_Parse_context.begin()));
        auto _Arg = _Ctx.arg(_Id);
        _Basic_format_specs<_CharT> _Specs;
        _Specs_checker<_Specs_handler<basic_format_parse_context<_CharT>, _Context>> _Handler(
            _Specs_handler<basic_format_parse_context<_CharT>, _Context>(_Specs, _Parse_context, _Ctx),
            _Arg._Active_state);
        _Begin = _Parse_format_specs(_Begin, _End, _Handler);
        if (_Begin == _End || *_Begin != '}') {
            throw format_error("Missing '}' in format string.");
        }
        _Ctx.advance_to(_STD visit_format_arg(
            _Arg_formatter<_OutputIt, _CharT>{
                ._Ctx       = _STD addressof(_Ctx),
                ._Specs     = _STD addressof(_Specs),
                ._Parse_ctx = _STD addressof(_Parse_context),
            },
            _Arg));
        return _Begin;
    }
};

// Generic formatter definition, the deleted default constructor
// makes it "disabled" as per N4868 [formatter.formatter.spec]/5
template <class _Ty, class _CharT>
struct formatter {
    formatter()                 = delete;
    formatter(const formatter&) = delete;
    formatter operator=(const formatter&) = delete;
};

using format_context  = basic_format_context<back_insert_iterator<string>, string::value_type>;
using wformat_context = basic_format_context<back_insert_iterator<wstring>, wstring::value_type>;
using format_args     = basic_format_args<format_context>;
using wformat_args    = basic_format_args<wformat_context>;

template <class _Context = format_context, class... _Args>
auto make_format_args(const _Args&... _Vals) {
    return _Format_arg_store<_Context, _Args...>{_Vals...};
}

template <class _Context = wformat_context, class... _Args>
auto make_wformat_args(const _Args&... _Vals) {
    return _Format_arg_store<_Context, _Args...>{_Vals...};
}

template <class _Out, class _CharT>
using format_args_t = basic_format_args<basic_format_context<_Out, _CharT>>;

template <class _OutputIt>
_OutputIt vformat_to(_OutputIt _Out, string_view _Fmt, format_args_t<type_identity_t<_OutputIt>, char> _Args) {
    _Format_handler<_OutputIt, char, basic_format_context<_OutputIt, char>> _Handler(
        _Out, _Fmt, _Args, locale::classic());
    _Parse_format_string(_Fmt, _Handler);
    return _Handler._Ctx.out();
}

template <class _OutputIt>
_OutputIt vformat_to(_OutputIt _Out, wstring_view _Fmt, format_args_t<type_identity_t<_OutputIt>, wchar_t> _Args) {
    _Format_handler<_OutputIt, wchar_t, basic_format_context<_OutputIt, wchar_t>> _Handler(
        _Out, _Fmt, _Args, locale::classic());
    _Parse_format_string(_Fmt, _Handler);
    return _Handler._Ctx.out();
}

template <class _OutputIt>
_OutputIt vformat_to(
    _OutputIt _Out, const locale& _Loc, string_view _Fmt, format_args_t<type_identity_t<_OutputIt>, char> _Args) {
    _Format_handler<_OutputIt, char, basic_format_context<_OutputIt, char>> _Handler(_Out, _Fmt, _Args, _Loc);
    _Parse_format_string(_Fmt, _Handler);
    return _Handler._Ctx.out();
}

template <class _OutputIt>
_OutputIt vformat_to(
    _OutputIt _Out, const locale& _Loc, wstring_view _Fmt, format_args_t<type_identity_t<_OutputIt>, wchar_t> _Args) {
    _Format_handler<_OutputIt, wchar_t, basic_format_context<_OutputIt, wchar_t>> _Handler(_Out, _Fmt, _Args, _Loc);
    _Parse_format_string(_Fmt, _Handler);
    return _Handler._Ctx.out();
}

inline string vformat(string_view _Fmt, format_args _Args) {
    string _Str;
    _STD vformat_to(_STD back_inserter(_Str), _Fmt, _Args);
    return _Str;
}

inline wstring vformat(wstring_view _Fmt, wformat_args _Args) {
    wstring _Str;
    _STD vformat_to(_STD back_inserter(_Str), _Fmt, _Args);
    return _Str;
}

inline string vformat(const locale& _Loc, string_view _Fmt, format_args _Args) {
    string _Str;
    _STD vformat_to(_STD back_inserter(_Str), _Loc, _Fmt, _Args);
    return _Str;
}

inline wstring vformat(const locale& _Loc, wstring_view _Fmt, wformat_args _Args) {
    wstring _Str;
    _STD vformat_to(_STD back_inserter(_Str), _Loc, _Fmt, _Args);
    return _Str;
}

template <class... _Types>
string format(string_view _Fmt, const _Types&... _Args) {
    return _STD vformat(_Fmt, _STD make_format_args(_Args...));
}

template <class... _Types>
wstring format(wstring_view _Fmt, const _Types&... _Args) {
    return _STD vformat(_Fmt, _STD make_wformat_args(_Args...));
}

template <class... _Types>
string format(const locale& _Loc, string_view _Fmt, const _Types&... _Args) {
    return _STD vformat(_Loc, _Fmt, _STD make_format_args(_Args...));
}

template <class... _Types>
wstring format(const locale& _Loc, wstring_view _Fmt, const _Types&... _Args) {
    return _STD vformat(_Loc, _Fmt, _STD make_wformat_args(_Args...));
}

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // __cpp_lib_concepts
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _FORMAT_
